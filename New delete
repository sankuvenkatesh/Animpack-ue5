bl_info = {
    "name": "Keyframe Tools Interval",
    "author": "Venkatesh Sanku",
    "version": (2, 8, 2),
    "blender": (5, 0, 1),
    "location": "View3D > Sidebar > Item",
    "description": "Delete or bake keyframes by interval on transforms and bone custom properties",
    "category": "Animation",
}

import bpy
from bpy.types import Operator, Panel, PropertyGroup


# ------------------------------------------------------------------------
# Properties
# ------------------------------------------------------------------------

class DelKeyProperties(PropertyGroup):

    start_frame: bpy.props.IntProperty(name="Start", default=1, min=0)
    end_frame: bpy.props.IntProperty(name="End", default=250, min=1)
    interval: bpy.props.IntProperty(name="Interval", default=0, min=0)
    inverse_interval: bpy.props.BoolProperty(name="Inverse", default=False)

    pos: bpy.props.BoolProperty(name="Position", default=True)
    rot: bpy.props.BoolProperty(name="Rotation", default=True)
    scl: bpy.props.BoolProperty(name="Scale", default=True)
    custom_props: bpy.props.BoolProperty(name="Custom Props", default=False)

    all_channels: bpy.props.BoolProperty(name="All Channels", default=True)


# ------------------------------------------------------------------------
# Utilities
# ------------------------------------------------------------------------

def frame_allowed(frame, interval, key_frames, inverse):
    if interval == 0:
        return not inverse
    return frame in key_frames if inverse else frame not in key_frames


# ------------------------------------------------------------------------
# DELETE OPERATOR (FIXED)
# ------------------------------------------------------------------------

class DeleteKeyframeOperator(Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scene = context.scene
        props = scene.del_keyframe_props

        obj = context.active_object
        if not obj or obj.type != 'ARMATURE':
            self.report({'WARNING'}, "Select an Armature in Pose Mode")
            return {'CANCELLED'}

        original_mode = obj.mode
        bpy.ops.object.mode_set(mode='POSE')

        bones = list(context.selected_pose_bones)
        if not bones:
            self.report({'WARNING'}, "No pose bones selected")
            return {'CANCELLED'}

        paths = []
        if props.pos:
            paths.append("location")
        if props.rot:
            paths.extend(["rotation_euler", "rotation_quaternion"])
        if props.scl:
            paths.append("scale")

        frames = range(props.start_frame, props.end_frame)
        key_frames = (
            set(range(props.start_frame, props.end_frame, props.interval + 1))
            if props.interval > 0 else set()
        )

        for frame in frames:
            if not frame_allowed(frame, props.interval, key_frames, props.inverse_interval):
                continue

            for pb in bones:
                for path in paths:
                    try:
                        pb.keyframe_delete(data_path=path, frame=frame)
                    except:
                        pass

                if props.custom_props and pb.animation_data:
                    ad = pb.animation_data.action
                    if ad:
                        for fc in ad.fcurves:
                            if fc.data_path.startswith('["'):
                                fc.keyframe_points.remove(
                                    next((kp for kp in fc.keyframe_points
                                          if int(kp.co.x) == frame), None)
                                )

        bpy.ops.object.mode_set(mode=original_mode)
        return {'FINISHED'}


# ------------------------------------------------------------------------
# BAKE OPERATOR (FIXED)
# ------------------------------------------------------------------------

class BakeKeyframeOperator(Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scene = context.scene
        props = scene.del_keyframe_props
        depsgraph = context.evaluated_depsgraph_get()

        obj = context.active_object
        if not obj or obj.type != 'ARMATURE':
            self.report({'WARNING'}, "Select an Armature in Pose Mode")
            return {'CANCELLED'}

        original_mode = obj.mode
        bpy.ops.object.mode_set(mode='POSE')

        bones = list(context.selected_pose_bones)
        if not bones:
            self.report({'WARNING'}, "No pose bones selected")
            return {'CANCELLED'}

        if not obj.animation_data:
            obj.animation_data_create()
        if not obj.animation_data.action:
            obj.animation_data.action = bpy.data.actions.new(
                name=f"{obj.name}_Baked"
            )

        frames = range(props.start_frame, props.end_frame)
        key_frames = (
            set(range(props.start_frame, props.end_frame, props.interval + 1))
            if props.interval > 0 else set()
        )

        bake_frames = [
            f for f in frames
            if frame_allowed(f, props.interval, key_frames, props.inverse_interval)
        ]

        for frame in bake_frames:
            scene.frame_set(frame)
            depsgraph.update()

            for pb in bones:

                if props.pos:
                    pb.keyframe_insert("location", frame=frame)

                if props.rot:
                    if pb.rotation_mode == 'QUATERNION':
                        pb.keyframe_insert("rotation_quaternion", frame=frame)
                    else:
                        pb.keyframe_insert("rotation_euler", frame=frame)

                if props.scl:
                    pb.keyframe_insert("scale", frame=frame)

                if props.custom_props:
                    for k in pb.keys():
                        if k != "_RNA_UI":
                            pb.keyframe_insert(f'["{k}"]', frame=frame)

        bpy.ops.object.mode_set(mode=original_mode)
        return {'FINISHED'}


# ------------------------------------------------------------------------
# UI PANEL
# ------------------------------------------------------------------------

class KeyframeIntervalPanel(Panel):
    bl_label = "Keyframe Interval Tools"
    bl_idname = "VIEW3D_PT_keyframe_interval_tools"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Item'

    def draw(self, context):
        p = context.scene.del_keyframe_props
        l = self.layout

        l.prop(p, "start_frame")
        l.prop(p, "end_frame")
        l.prop(p, "interval")
        l.prop(p, "inverse_interval")

        l.separator()
        l.prop(p, "all_channels")

        col = l.column()
        col.enabled = not p.all_channels
        col.prop(p, "pos")
        col.prop(p, "rot")
        col.prop(p, "scl")
        col.prop(p, "custom_props")

        l.separator()
        l.operator("object.delete_keyframe_by_interval", icon='KEY_HLT')
        l.operator("object.bake_keyframe_by_interval", icon='REC')


# ------------------------------------------------------------------------
# REGISTER
# ------------------------------------------------------------------------

classes = (
    DelKeyProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    KeyframeIntervalPanel,
)

def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DelKeyProperties)

def unregister():
    for c in reversed(classes):
        bpy.utils.unregister_class(c)
    del bpy.types.Scene.del_keyframe_props


if __name__ == "__main__":
    register()
