bl_info = {
    "name": "Keyframe Tools Interval",
    "author": "Venkatesh Sanku",
    "version": (2, 5, 3),
    "blender": (5, 0, 0),
    "location": "View3D > Sidebar > Item",
    "description": "Delete or bake keyframes by interval for objects and bones with detailed frame reporting",
    "category": "Animation",
}

import bpy


class DelKeyProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=1, min=1
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=250, min=1
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=0, min=0, max=100
    )
    pos: bpy.props.BoolProperty(
        name="Position", default=True
    )
    rot: bpy.props.BoolProperty(
        name="Rotation", default=True
    )
    scl: bpy.props.BoolProperty(
        name="Scale", default=True
    )
    inverse_interval: bpy.props.BoolProperty(
        name="Inverse Interval",
        description="Invert interval behavior (delete/bake only kept frames)",
        default=False
    )
    selected_only: bpy.props.BoolProperty(
        name="Selected Only",
        description="Affect only selected objects / selected pose bones",
        default=True
    )
    
    # UI reporting properties
    op_result: bpy.props.StringProperty(name="Result", default="")
    affected_frames_ui: bpy.props.StringProperty(name="Frames", default="")
    affected_keyframes_ui: bpy.props.StringProperty(name="Keyframes", default="")
    affected_objects_ui: bpy.props.StringProperty(name="Objects", default="")
    affected_bones_ui: bpy.props.StringProperty(name="Bones", default="")


class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_description = "Delete keyframes by interval on objects/bones"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.scene is not None

    def execute(self, context):
        props = context.scene.del_keyframe_props
        # Clear previous results
        props.op_result = ""
        props.affected_frames_ui = ""
        props.affected_keyframes_ui = ""
        props.affected_objects_ui = ""
        props.affected_bones_ui = ""

        if props.start_frame >= props.end_frame:
            self.report({'WARNING'}, "Start frame must be less than end frame")
            return {'CANCELLED'}

        start = props.start_frame
        end = props.end_frame

        paths = []
        if props.pos:
            paths.append("location")
        if props.rot:
            paths.extend(["rotation_euler", "rotation_quaternion"])
        if props.scl:
            paths.append("scale")

        if not paths:
            self.report({'WARNING'}, "No channels selected")
            return {'CANCELLED'}

        if props.selected_only:
            objects = list(context.selected_objects)
            if not objects:
                self.report({'WARNING'}, "No objects selected")
                return {'CANCELLED'}
        else:
            objects = [o for o in context.scene.objects]

        all_frames = range(start, end)
        key_frames = set(range(start, end, props.interval + 1)) if props.interval > 0 else set()

        deleted_frames = set()
        affected_objects = set()
        affected_bones = set()
        frame_details = {}
        affected_keyframes = set()

        for frame in all_frames:
            if not self._frame_should_be_processed(frame, props.interval, key_frames, props.inverse_interval):
                continue

            touched_any = False
            frame_affected = set()

            for obj in objects:
                touched_obj, bones, frame_keyframes = self._delete_on_object(
                    obj, frame, paths, context, props.selected_only
                )
                if touched_obj:
                    touched_any = True
                    affected_objects.add(obj.name)
                    frame_affected.add(obj.name)
                    affected_keyframes.update(frame_keyframes)
                    for b in bones:
                        affected_bones.add(f"{obj.name}:{b}")
                        frame_affected.add(f"{obj.name}:{b}")

            if touched_any:
                deleted_frames.add(frame)
                frame_details[frame] = sorted(frame_affected)

        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        if deleted_frames:
            frames_sorted = sorted(deleted_frames)
            keyframes_sorted = sorted(affected_keyframes)
            
            # Update UI properties
            props.affected_frames_ui = ', '.join(map(str, frames_sorted)) if len(frames_sorted) <= 15 else f"{frames_sorted[0]}-{frames_sorted[-1]} ({len(frames_sorted)})"
            props.affected_keyframes_ui = ', '.join(map(str, sorted(list(affected_keyframes)))) if len(affected_keyframes) <= 15 else f"{len(affected_keyframes)} keyframes"
            props.affected_objects_ui = ', '.join(sorted(affected_objects)) if len(affected_objects) <= 10 else f"{len(affected_objects)} objects"
            props.affected_bones_ui = ', '.join(sorted(affected_bones)) if len(affected_bones) <= 10 else f"{len(affected_bones)} bones"
            props.op_result = f"Deleted {len(affected_keyframes)} keyframes"
            
            # Console output
            print("
=== KEYFRAME DELETION REPORT ===")
            print(f"Processed frames: {frames_sorted}")
            print(f"Affected keyframes: {', '.join(map(str, sorted(list(affected_keyframes))))}")
            print(f"Affected objects: {sorted(affected_objects)}")
            if affected_bones:
                print(f"Affected bones: {sorted(affected_bones)}")
            
            print("
Frame-by-frame details:")
            for frame in frames_sorted:
                affected = frame_details[frame]
                print(f"  Frame {frame}: {', '.join(affected)}")
            
            self.report({'INFO'}, props.op_result)
        else:
            props.op_result = "No keyframes deleted"
            self.report({'INFO'}, props.op_result)

        return {'FINISHED'}

    def _frame_should_be_processed(self, frame, interval, key_frames, inverse):
        if interval == 0:
            return not inverse
        if inverse:
            return frame in key_frames
        return frame not in key_frames

    def _delete_on_object(self, obj, frame, paths, context, selected_only_flag):
        touched = False
        touched_bones = set()
        frame_keyframes = set()

        for path in paths:
            try:
                result = obj.keyframe_delete(data_path=path, frame=frame)
                if result:
                    touched = True
                    frame_keyframes.add(frame)  # Just track frame numbers
            except Exception:
                pass

        if obj.type == 'ARMATURE' and obj.animation_data:
            if obj.mode == 'POSE':
                if selected_only_flag and context.selected_pose_bones:
                    pose_bones = list(context.selected_pose_bones)
                else:
                    pose_bones = list(obj.pose.bones)

                for pbone in pose_bones:
                    bone_keyframes = self._delete_on_bone(pbone, frame, paths)
                    if bone_keyframes:
                        touched = True
                        touched_bones.add(pbone.name)
                        frame_keyframes.update(bone_keyframes)

        return touched, touched_bones, frame_keyframes

    def _delete_on_bone(self, pbone, frame, paths):
        touched_keyframes = set()
        for path in paths:
            try:
                result = pbone.keyframe_delete(data_path=path, frame=frame)
                if result:
                    touched_keyframes.add(frame)
            except Exception:
                pass
        return touched_keyframes


class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_description = "Bake keyframes on interval frames for objects and bones"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.scene is not None

    def execute(self, context):
        props = context.scene.del_keyframe_props
        # Clear previous results
        props.op_result = ""
        props.affected_frames_ui = ""
        props.affected_keyframes_ui = ""
        props.affected_objects_ui = ""
        props.affected_bones_ui = ""

        if props.start_frame >= props.end_frame:
            self.report({'WARNING'}, "Start frame must be less than end frame")
            return {'CANCELLED'}

        start = props.start_frame
        end = props.end_frame

        scene = context.scene
        original_frame = scene.frame_current

        if props.selected_only:
            objects = list(context.selected_objects)
            if not objects:
                self.report({'WARNING'}, "No objects selected")
                return {'CANCELLED'}
        else:
            objects = [o for o in scene.objects]

        all_frames = range(start, end)
        key_frames = set(range(start, end, props.interval + 1)) if props.interval > 0 else set()

        bake_frames = [
            f for f in all_frames
            if self._frame_should_be_baked(f, props.interval, key_frames, props.inverse_interval)
        ]
        if not bake_frames:
            props.op_result = "No frames to bake"
            self.report({'INFO'}, props.op_result)
            return {'CANCELLED'}

        baked_objects = set()
        baked_bones = set()
        frame_details = {}
        affected_keyframes = set()

        for obj in objects:
            prev_selection = [o for o in context.selected_objects]
            prev_active = context.view_layer.objects.active

            for o in context.view_layer.objects:
                o.select_set(False)
            obj.select_set(True)
            context.view_layer.objects.active = obj

            paths = []
            if props.pos: paths.append("location")
            if props.rot: paths.extend(["rotation_euler", "rotation_quaternion"])
            if props.scl: paths.append("scale")

            try:
                for frame in bake_frames:
                    scene.frame_set(frame)
                    bpy.ops.anim.keyframe_insert_menu(
                        type='LocRotScale' if (props.pos or props.rot or props.scl) else 'BUILTIN_KSI_VisualLocRotScale'
                    )
                    frame_details.setdefault(frame, set()).add(obj.name)
                    affected_keyframes.add(frame)

                baked_objects.add(obj.name)

                if obj.type == 'ARMATURE' and obj.pose:
                    if obj.mode == 'POSE' and props.selected_only and context.selected_pose_bones:
                        for p in context.selected_pose_bones:
                            baked_bones.add(f"{obj.name}:{p.name}")
                            for frame in bake_frames:
                                frame_details.setdefault(frame, set()).add(f"{obj.name}:{p.name}")
                    else:
                        for p in obj.pose.bones:
                            baked_bones.add(f"{obj.name}:{p.name}")
                            for frame in bake_frames:
                                frame_details.setdefault(frame, set()).add(f"{obj.name}:{p.name}")

            except Exception as e:
                print(f"Bake failed on {obj.name}: {e}")

            for o in context.view_layer.objects:
                o.select_set(False)
            for o in prev_selection:
                o.select_set(True)
            context.view_layer.objects.active = prev_active

        scene.frame_current = original_frame

        if baked_objects:
            frames_sorted = sorted(bake_frames)
            
            # Update UI properties
            props.affected_frames_ui = ', '.join(map(str, frames_sorted)) if len(frames_sorted) <= 15 else f"{frames_sorted[0]}-{frames_sorted[-1]} ({len(frames_sorted)})"
            props.affected_keyframes_ui = ', '.join(map(str, sorted(list(affected_keyframes)))) if len(affected_keyframes) <= 15 else f"{len(affected_keyframes)} keyframes"
            props.affected_objects_ui = ', '.join(sorted(baked_objects)) if len(baked_objects) <= 10 else f"{len(baked_objects)} objects"
            props.affected_bones_ui = ', '.join(sorted(baked_bones)) if len(baked_bones) <= 10 else f"{len(baked_bones)} bones"
            props.op_result = f"Baked {len(affected_keyframes)} keyframes"
            
            # Console output
            print("
=== KEYFRAME BAKE REPORT ===")
            print(f"Baked frames: {frames_sorted}")
            print(f"Affected keyframes: {', '.join(map(str, sorted(list(affected_keyframes))))}")
            print(f"Baked objects: {sorted(baked_objects)}")
            if baked_bones:
                print(f"Baked bones: {sorted(baked_bones)}")
            
            self.report({'INFO'}, props.op_result)
        else:
            props.op_result = "No objects baked"
            self.report({'INFO'}, props.op_result)

        return {'FINISHED'}

    def _frame_should_be_baked(self, frame, interval, key_frames, inverse):
        if interval == 0:
            return not inverse
        if inverse:
            return frame in key_frames
        return frame not in key_frames


class KeyframeIntervalPanel(bpy.types.Panel):
    bl_label = "Keyframe Interval Tools"
    bl_idname = "VIEW3D_PT_keyframe_interval_tools"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Item'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props

        layout.label(text="Frame Range")
        row = layout.row(align=True)
        row.prop(props, "start_frame")
        row.prop(props, "end_frame")

        layout.label(text="Interval (0 = all)")
        row = layout.row()
        row.prop(props, "interval")
        row.prop(props, "inverse_interval")

        layout.label(text="Channels")
        row = layout.row(align=True)
        row.prop(props, "pos")
        row.prop(props, "rot")
        row.prop(props, "scl")

        layout.prop(props, "selected_only")

        layout.separator()
        col = layout.column(align=True)
        col.operator("object.delete_keyframe_by_interval", icon="KEY_HLT")
        col.operator("object.bake_keyframe_by_interval", icon="REC")

        # Results display
        layout.separator()
        layout.label(text="Results:", icon="INFO")
        if props.op_result:
            box = layout.box()
            box.label(text=props.op_result, icon="CHECKMARK")
            if props.affected_frames_ui:
                box.label(text=f"Frames: {props.affected_frames_ui}")
            if props.affected_keyframes_ui:
                box.label(text=f"Keyframes: {props.affected_keyframes_ui}")
            if props.affected_objects_ui:
                box.label(text=f"Objects: {props.affected_objects_ui}")
            if props.affected_bones_ui:
                box.label(text=f"Bones: {props.affected_bones_ui}")


classes = (
    DelKeyProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    KeyframeIntervalPanel,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DelKeyProperties)


def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props


if __name__ == "__main__":
    register()
