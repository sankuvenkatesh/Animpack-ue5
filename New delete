bl_info = {
    "name": "Interval Delete Like Native",
    "author": "Venkatesh Sanku",
    "version": (1, 0, 0),
    "blender": (5, 0, 0),
    "location": "Dope Sheet / Graph Editor",
    "description": "Delete keyframes by interval using Blender's own delete operators (near-native speed)",
    "category": "Animation",
}

import bpy


class IntervalDeleteProps(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(name="Start", default=0)
    end_frame: bpy.props.IntProperty(name="End", default=250)
    interval: bpy.props.IntProperty(name="Every", default=2, min=1)
    use_graph: bpy.props.BoolProperty(
        name="Use Graph Editor",
        description="If ON, operate on Graph Editor (bpy.ops.graph.*); otherwise on Dope Sheet/Action (bpy.ops.action.*)",
        default=False,
    )


def calc_frames(props):
    if props.end_frame < props.start_frame:
        return []
    return list(range(props.start_frame, props.end_frame + 1, props.interval))


def select_keys_by_interval(context, frames):
    """
    Mark keys on the active action as selected if their frame is in frames.
    Works on all F-curves in the active action. [web:6][web:15]
    """
    fset = set(int(f) for f in frames)

    ob = context.active_object
    if not ob or not ob.animation_data or not ob.animation_data.action:
        return 0

    action = ob.animation_data.action
    count = 0

    for fc in action.fcurves:
        for k in fc.keyframe_points:
            k.select_control_point = False  # clear first
            fr = int(round(k.co.x))
            if fr in fset:
                k.select_control_point = True
                count += 1

    return count


class INTERVAL_OT_delete(bpy.types.Operator):
    bl_idname = "anim.interval_delete_like_native"
    bl_label = "Delete Interval Keys (Native)"
    bl_options = {"REGISTER", "UNDO"}

    def execute(self, context):
        scene = context.scene
        props = scene.interval_delete_props
        frames = calc_frames(props)
        if not frames:
            self.report({"WARNING"}, "No frames")
            return {"CANCELLED"}

        # 1) Select keys in the active action that match the interval.
        num_sel = select_keys_by_interval(context, frames)
        if num_sel == 0:
            self.report({"WARNING"}, "No keys on those frames in active action")
            return {"CANCELLED"}

        # 2) Call Blender's own delete operator once, same as pressing X in editor. [web:72][web:74][web:76]
        if props.use_graph:
            # Graph Editor mode: delete selected keys in Graph Editor
            bpy.ops.graph.delete(confirm=False)  # [web:72][web:69]
        else:
            # Dope Sheet / Action Editor mode
            bpy.ops.action.delete(confirm=False)  # [web:74][web:76]

        self.report({"INFO"}, f"Deleted {num_sel} keys")
        return {"FINISHED"}


class INTERVAL_PT_panel(bpy.types.Panel):
    bl_label = "Interval Delete Like Native"
    bl_space_type = "DOPESHEET_EDITOR"
    bl_region_type = "UI"
    bl_category = "Interval"

    def draw(self, context):
        layout = self.layout
        props = context.scene.interval_delete_props

        layout.prop(props, "start_frame")
        layout.prop(props, "end_frame")
        layout.prop(props, "interval")
        layout.prop(props, "use_graph")

        frames = calc_frames(props)
        layout.label(text=f"Frames: {len(frames)}")
        layout.operator("anim.interval_delete_like_native", icon="TRASH")


classes = (
    IntervalDeleteProps,
    INTERVAL_OT_delete,
    INTERVAL_PT_panel,
)


def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.Scene.interval_delete_props = bpy.props.PointerProperty(type=IntervalDeleteProps)


def unregister():
    for c in reversed(classes):
        bpy.utils.unregister_class(c)
    del bpy.types.Scene.interval_delete_props


if __name__ == "__main__":
    register()
