bl_info = {
    "name": "Keyframe Tools Interval",
    "author": "Venkatesh Sanku",
    "version": (2, 6, 7),
    "blender": (5, 0, 0),
    "location": "View3D > Sidebar > Item",
    "description": "Delete or bake keyframes by interval with live preview & all checkbox",
    "category": "Animation",
}

import bpy
from bpy.types import Operator, Panel, PropertyGroup


class DelKeyProperties(PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=0, min=0,
        update=lambda self, context: self._update_preview(context)
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=250, min=1,
        update=lambda self, context: self._update_preview(context)
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=0, min=0, max=100,
        update=lambda self, context: self._update_preview(context)
    )
    pos: bpy.props.BoolProperty(
        name="Position", default=True,
        update=lambda self, context: self._update_preview(context)
    )
    rot: bpy.props.BoolProperty(
        name="Rotation", default=True,
        update=lambda self, context: self._update_preview(context)
    )
    scl: bpy.props.BoolProperty(
        name="Scale", default=True,
        update=lambda self, context: self._update_preview(context)
    )
    all_channels: bpy.props.BoolProperty(
        name="All Channels",
        description="Select all position, rotation, scale channels",
        default=True,
        update=lambda self, context: self._all_channels_update(context)
    )
    inverse_interval: bpy.props.BoolProperty(
        name="Inverse Interval",
        description="Invert interval behavior (delete/bake only kept frames)",
        default=False,
        update=lambda self, context: self._update_preview(context)
    )
    preview_keyframes: bpy.props.StringProperty(name="Preview Keyframes", default="")
    preview_count: bpy.props.IntProperty(name="Preview Count", default=0)

    def _all_channels_update(self, context):
        self.pos = self.all_channels
        self.rot = self.all_channels
        self.scl = self.all_channels
        self._update_preview(context)

    def _update_preview(self, context):
        bpy.app.timers.register(
            lambda: update_live_preview(context.scene, self),
            first_interval=0.05
        )


def update_live_preview(scene, props):
    if props.start_frame >= props.end_frame:
        props.preview_keyframes = "Invalid range"
        props.preview_count = 0
        return

    start = props.start_frame
    end = props.end_frame
    interval = props.interval

    all_frames = range(start, end)
    key_frames = set(range(start, end, interval + 1)) if interval > 0 else set()

    preview_keyframes = set()

    for frame in all_frames:
        should_process = (
            (interval == 0 and not props.inverse_interval) or
            (props.inverse_interval and frame in key_frames) or
            (not props.inverse_interval and frame not in key_frames)
        )
        if should_process:
            preview_keyframes.add(frame)

    props.preview_keyframes = ', '.join(
        map(str, sorted(preview_keyframes)[:15])
    ) + ('...' if len(preview_keyframes) > 15 else '')
    props.preview_count = len(preview_keyframes)


class LivePreviewUpdateOperator(Operator):
    bl_idname = "object.update_keyframe_preview"
    bl_label = "Update Preview"
    bl_description = "Update live preview of affected keyframes"

    def execute(self, context):
        props = context.scene.del_keyframe_props
        update_live_preview(context.scene, props)
        return {'FINISHED'}


def get_selected_pose_bones_for_object(context, obj):
    """Return only pose bones selected on this specific armature (active object)."""
    if obj.type != 'ARMATURE' or not obj.pose:
        return []

    # Blender provides a helper: selected_pose_bones_from_active_object
    bones = getattr(context, "selected_pose_bones_from_active_object", None)
    if bones is None:
        return []

    # Only if this armature is active
    if context.object is not obj:
        return []

    return list(bones)


class DeleteKeyframeOperator(Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_description = "Delete keyframes by interval on objects/bones"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.scene is not None

    def execute(self, context):
        props = context.scene.del_keyframe_props

        if props.start_frame >= props.end_frame:
            self.report({'WARNING'}, "Start frame must be less than end frame")
            return {'CANCELLED'}

        paths = []
        if props.pos:
            paths.append("location")
        if props.rot:
            paths.extend(["rotation_euler", "rotation_quaternion"])
        if props.scl:
            paths.append("scale")

        if not paths:
            self.report({'WARNING'}, "No channels selected")
            return {'CANCELLED'}

        objects = list(context.selected_objects)
        if not objects:
            self.report({'WARNING'}, "No objects selected")
            return {'CANCELLED'}

        all_frames = range(props.start_frame, props.end_frame)
        key_frames = set(range(props.start_frame, props.end_frame, props.interval + 1)) if props.interval > 0 else set()

        deleted_frames = set()
        affected_objects = set()
        affected_bones = set()
        affected_keyframes = set()

        for frame in all_frames:
            if not self._frame_should_be_processed(frame, props.interval, key_frames, props.inverse_interval):
                continue

            touched_any = False

            for obj in objects:
                touched_obj, bones, frame_keyframes = self._delete_on_object(
                    context, obj, frame, paths
                )
                if touched_obj:
                    touched_any = True
                    affected_objects.add(obj.name)
                    affected_keyframes.update(frame_keyframes)
                    for b in bones:
                        affected_bones.add(f"{obj.name}:{b}")

            if touched_any:
                deleted_frames.add(frame)

        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        if deleted_frames:
            self.report(
                {'INFO'},
                f"Deleted {len(affected_keyframes)} keyframes on {len(affected_objects)} object(s)"
            )
            print("
=== KEYFRAME DELETION REPORT ===")
            print(f"Deleted frames: {sorted(deleted_frames)}")
            print(f"Affected objects: {sorted(affected_objects)}")
            if affected_bones:
                print(f"Affected bones: {sorted(affected_bones)}")
        else:
            self.report({'INFO'}, "No keyframes deleted")

        return {'FINISHED'}

    def _frame_should_be_processed(self, frame, interval, key_frames, inverse):
        if interval == 0:
            return not inverse
        if inverse:
            return frame in key_frames
        return frame not in key_frames

    def _delete_on_object(self, context, obj, frame, paths):
        touched = False
        touched_bones = set()
        frame_keyframes = set()

        # Object transforms
        for path in paths:
            try:
                result = obj.keyframe_delete(data_path=path, frame=frame)
                if result:
                    touched = True
                    frame_keyframes.add(frame)
            except Exception:
                pass

        # Pose bones – strictly selected bones on active armature
        if obj.type == 'ARMATURE' and obj.animation_data and obj.pose:
            original_mode = obj.mode
            armature_active = False

            try:
                if original_mode != 'POSE':
                    context.view_layer.objects.active = obj
                    bpy.ops.object.mode_set(mode='POSE')
                    armature_active = True

                pose_bones = get_selected_pose_bones_for_object(context, obj)

                if not pose_bones:
                    print(f"[Keyframe Tools] No selected pose bones on {obj.name}, bones delete skipped")
                else:
                    for pbone in pose_bones:
                        bone_keyframes = self._delete_on_bone(pbone, frame, paths)
                        if bone_keyframes:
                            touched = True
                            touched_bones.add(pbone.name)
                            frame_keyframes.update(bone_keyframes)

            except Exception:
                pass
            finally:
                if armature_active:
                    try:
                        bpy.ops.object.mode_set(mode=original_mode)
                    except:
                        pass

        return touched, touched_bones, frame_keyframes

    def _delete_on_bone(self, pbone, frame, paths):
        touched_keyframes = set()
        for path in paths:
            try:
                result = pbone.keyframe_delete(data_path=path, frame=frame)
                if result:
                    touched_keyframes.add(frame)
            except Exception:
                pass
        return touched_keyframes


class BakeKeyframeOperator(Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_description = "Bake keyframes on interval frames for objects and bones"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.scene is not None

    def execute(self, context):
        props = context.scene.del_keyframe_props

        if props.start_frame >= props.end_frame:
            self.report({'WARNING'}, "Start frame must be less than end frame")
            return {'CANCELLED'}

        scene = context.scene
        original_frame = scene.frame_current
        original_active = context.view_layer.objects.active

        objects = list(context.selected_objects)
        if not objects:
            self.report({'WARNING'}, "No objects selected")
            return {'CANCELLED'}

        all_frames = range(props.start_frame, props.end_frame)
        key_frames = set(range(props.start_frame, props.end_frame, props.interval + 1)) if props.interval > 0 else set()

        bake_frames = [
            f for f in all_frames
            if self._frame_should_be_baked(f, props.interval, key_frames, props.inverse_interval)
        ]
        if not bake_frames:
            self.report({'INFO'}, "No frames to bake")
            return {'CANCELLED'}

        baked_objects = set()
        baked_bones = set()
        affected_keyframes = set()

        for obj in objects:
            if not obj.animation_data:
                continue

            original_mode = obj.mode if hasattr(obj, 'mode') else 'OBJECT'
            armature_active = False
            baked_this_obj = False

            try:
                context.view_layer.objects.active = obj

                if obj.type == 'ARMATURE':
                    if obj.mode != 'POSE':
                        bpy.ops.object.mode_set(mode='POSE')
                        armature_active = True
                else:
                    if obj.mode != 'OBJECT':
                        bpy.ops.object.mode_set(mode='OBJECT')

                for frame in bake_frames:
                    scene.frame_set(frame)
                    frame_baked = False

                    # Object transforms
                    if props.pos:
                        try:
                            obj.keyframe_insert(data_path="location")
                            frame_baked = True
                        except:
                            pass
                    if props.rot:
                        try:
                            obj.keyframe_insert(data_path="rotation_euler")
                            frame_baked = True
                        except:
                            pass
                        try:
                            obj.keyframe_insert(data_path="rotation_quaternion")
                            frame_baked = True
                        except:
                            pass
                    if props.scl:
                        try:
                            obj.keyframe_insert(data_path="scale")
                            frame_baked = True
                        except:
                            pass

                    # Pose bones – strictly selected bones on active armature
                    if obj.type == 'ARMATURE' and obj.pose:
                        pose_bones = get_selected_pose_bones_for_object(context, obj)

                        if not pose_bones:
                            print(f"[Keyframe Tools] No selected pose bones on {obj.name}, bones bake skipped")
                        else:
                            for pbone in pose_bones:
                                bone_frame_baked = False
                                if props.pos:
                                    try:
                                        pbone.keyframe_insert(data_path="location")
                                        bone_frame_baked = True
                                    except:
                                        pass
                                if props.rot:
                                    try:
                                        pbone.keyframe_insert(data_path="rotation_euler")
                                        bone_frame_baked = True
                                    except:
                                        pass
                                    try:
                                        pbone.keyframe_insert(data_path="rotation_quaternion")
                                        bone_frame_baked = True
                                    except:
                                        pass
                                if props.scl:
                                    try:
                                        pbone.keyframe_insert(data_path="scale")
                                        bone_frame_baked = True
                                    except:
                                        pass

                                if bone_frame_baked:
                                    baked_bones.add(f"{obj.name}:{pbone.name}")
                                    frame_baked = True

                    if frame_baked:
                        affected_keyframes.add(frame)
                        baked_this_obj = True

                if baked_this_obj:
                    baked_objects.add(obj.name)

            except Exception as e:
                print(f"Bake failed on {obj.name}: {e}")
            finally:
                try:
                    if obj.type == 'ARMATURE' and armature_active and obj.mode != original_mode:
                        bpy.ops.object.mode_set(mode=original_mode)
                except:
                    pass

        scene.frame_set(original_frame)
        context.view_layer.objects.active = original_active

        if baked_objects:
            self.report(
                {'INFO'},
                f"Baked {len(affected_keyframes)} keyframes on {len(baked_objects)} objects"
            )
            print("
=== KEYFRAME BAKE REPORT ===")
            print(f"Baked frames: {sorted(bake_frames)}")
            print(f"Baked objects: {sorted(baked_objects)}")
            if baked_bones:
                print(f"Baked bones: {sorted(list(baked_bones))}")
        else:
            self.report({'INFO'}, "No objects baked")

        return {'FINISHED'}

    def _frame_should_be_baked(self, frame, interval, key_frames, inverse):
        if interval == 0:
            return not inverse
        if inverse:
            return frame in key_frames
        return frame not in key_frames


class KeyframeIntervalPanel(Panel):
    bl_label = "Keyframe Interval Tools"
    bl_idname = "VIEW3D_PT_keyframe_interval_tools"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Item'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props

        layout.label(text="Frame Range")
        row = layout.row(align=True)
        row.prop(props, "start_frame", text="")
        row.prop(props, "end_frame", text="")
        row.operator("object.update_keyframe_preview", text="", icon="VIEWZOOM")

        layout.label(text="Interval (0 = all)")
        row = layout.row(align=True)
        row.prop(props, "interval")
        row.prop(props, "inverse_interval")

        layout.label(text="Channels")
        row = layout.row()
        row.prop(props, "all_channels", toggle=True)

        sub = layout.row(align=True)
        sub.enabled = not props.all_channels
        sub.prop(props, "pos")
        sub.prop(props, "rot")
        sub.prop(props, "scl")

        layout.separator()
        box = layout.box()
        box.label(text="Live Preview:", icon="PREVIEW_RANGE")
        box.label(text=f"Keyframes: {props.preview_keyframes}")
        box.label(text=f"Total: {props.preview_count}")

        layout.separator()
        col = layout.column(align=True)
        col.operator("object.delete_keyframe_by_interval", icon="KEY_HLT")
        col.operator("object.bake_keyframe_by_interval", icon="REC")


classes = (
    DelKeyProperties,
    LivePreviewUpdateOperator,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    KeyframeIntervalPanel,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DelKeyProperties)


def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props


if __name__ == "__main__":
    register()
