bl_info = {
    "name": "Keyframe Tools Interval",
    "author": "Venkatesh Sanku",
    "version": (2, 6, 2),
    "blender": (5, 0, 0),
    "location": "View3D > Sidebar > Item",
    "description": "Delete or bake keyframes by interval (objects + any rigs) with live preview",
    "category": "Animation",
}

import bpy


# ------------------------------------------------------------------------
# Properties
# ------------------------------------------------------------------------

class DelKeyProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=0, min=0
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=250, min=1
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=0, min=0, max=100
    )
    pos: bpy.props.BoolProperty(
        name="Position", default=True
    )
    rot: bpy.props.BoolProperty(
        name="Rotation", default=True
    )
    scl: bpy.props.BoolProperty(
        name="Scale", default=True
    )
    all_channels: bpy.props.BoolProperty(
        name="All",
        description="Select all position, rotation, scale channels",
        default=True
    )
    inverse_interval: bpy.props.BoolProperty(
        name="Inverse",
        description="Invert interval (process only kept frames)",
        default=False
    )
    selected_only: bpy.props.BoolProperty(
        name="Selected Only",
        description="Affect only selected objects / selected pose bones",
        default=True
    )

    # Live preview
    preview_keyframes: bpy.props.StringProperty(
        name="Preview Keyframes", default=""
    )
    preview_count: bpy.props.IntProperty(
        name="Preview Count", default=0
    )

    def update_all_channels(self, context):
        # Called manually from draw, avoids decorator issues
        if self.all_channels:
            self.pos = True
            self.rot = True
            self.scl = True


# ------------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------------

def get_all_pose_bones(context, obj, selected_only):
    """Return pose bones for any rig (Rigify, Auto-Rig Pro, custom)."""
    if obj.type != 'ARMATURE' or not getattr(obj, "pose", None):
        return []
    if selected_only and context.object == obj and context.selected_pose_bones:
        return [pb for pb in context.selected_pose_bones if pb.id_data == obj]
    return list(obj.pose.bones)


def compute_frames(props):
    """Return list of frames that will be processed from current settings."""
    if props.start_frame >= props.end_frame:
        return []

    start = props.start_frame
    end = props.end_frame
    interval = props.interval

    all_frames = range(start, end)
    if interval > 0:
        key_frames = set(range(start, end, interval + 1))
    else:
        key_frames = set()

    frames = []
    for f in all_frames:
        if interval == 0:
            cond = not props.inverse_interval
        else:
            cond = (f in key_frames) if props.inverse_interval else (f not in key_frames)
        if cond:
            frames.append(f)
    return frames


def update_live_preview(scene, props):
    frames = compute_frames(props)
    if not frames:
        props.preview_keyframes = "Invalid or empty"
        props.preview_count = 0
        return
    props.preview_keyframes = ", ".join(map(str, frames[:15])) + ("..." if len(frames) > 15 else "")
    props.preview_count = len(frames)


# ------------------------------------------------------------------------
# Operators
# ------------------------------------------------------------------------

class LivePreviewUpdateOperator(bpy.types.Operator):
    bl_idname = "object.update_keyframe_preview"
    bl_label = "Update Preview"
    bl_description = "Update live preview of affected keyframes"

    def execute(self, context):
        props = context.scene.del_keyframe_props
        update_live_preview(context.scene, props)
        return {'FINISHED'}


class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_description = "Delete keyframes by interval on objects/bones"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scene = context.scene
        props = scene.del_keyframe_props

        if props.start_frame >= props.end_frame:
            self.report({'WARNING'}, "Start frame must be less than end frame")
            return {'CANCELLED'}

        # Sync all checkbox
        props.update_all_channels(context)

        # Channel paths
        paths = []
        if props.pos:
            paths.append("location")
        if props.rot:
            paths.extend(["rotation_euler", "rotation_quaternion"])
        if props.scl:
            paths.append("scale")
        if not paths:
            self.report({'WARNING'}, "No channels selected")
            return {'CANCELLED'}

        # Targets
        if props.selected_only:
            objects = [
                o for o in context.selected_objects
                if o.animation_data or (o.type == 'ARMATURE' and getattr(o, "pose", None))
            ]
        else:
            objects = [
                o for o in scene.objects
                if o.animation_data or (o.type == 'ARMATURE' and getattr(o, "pose", None))
            ]
        if not objects:
            self.report({'WARNING'}, "No animated objects/rigs found")
            return {'CANCELLED'}

        frames = compute_frames(props)
        if not frames:
            self.report({'INFO'}, "No frames to process")
            return {'CANCELLED'}

        deleted_frames = set()
        affected_objects = set()
        affected_bones = set()
        affected_keys = 0

        for f in frames:
            for obj in objects:
                touched, bones, count = self._delete_on_object(obj, f, paths, context, props.selected_only)
                if touched:
                    deleted_frames.add(f)
                    affected_objects.add(obj.name)
                    affected_bones.update(f"{obj.name}:{b}" for b in bones)
                    affected_keys += count

        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        if deleted_frames:
            self.report({'INFO'}, f"Deleted {affected_keys} keyframes on {len(affected_objects)} object(s)")
            print("
=== KEYFRAME DELETION REPORT ===")
            print("Frames:", sorted(deleted_frames))
            print("Objects:", sorted(affected_objects))
            if affected_bones:
                print("Bones (sample):", sorted(list(affected_bones))[:20])
        else:
            self.report({'INFO'}, "No keyframes deleted")

        return {'FINISHED'}

    def _delete_on_object(self, obj, frame, paths, context, selected_only):
        touched = False
        bones_touched = set()
        count = 0

        # Object transforms
        if obj.animation_data:
            for path in paths:
                try:
                    if obj.keyframe_delete(data_path=path, frame=frame):
                        touched = True
                        count += 1
                except Exception:
                    pass

        # Pose bones
        if obj.type == 'ARMATURE' and getattr(obj, "pose", None):
            for pbone in get_all_pose_bones(context, obj, selected_only):
                for path in paths:
                    try:
                        if pbone.keyframe_delete(data_path=path, frame=frame):
                            touched = True
                            bones_touched.add(pbone.name)
                            count += 1
                    except Exception:
                        pass

        return touched, bones_touched, count


class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_description = "Bake keyframes on interval frames for objects and rigs"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scene = context.scene
        props = scene.del_keyframe_props

        if props.start_frame >= props.end_frame:
            self.report({'WARNING'}, "Start frame must be less than end frame")
            return {'CANCELLED'}

        # Sync all checkbox
        props.update_all_channels(context)

        # Targets
        if props.selected_only:
            objects = [
                o for o in context.selected_objects
                if o.animation_data or (o.type == 'ARMATURE' and getattr(o, "pose", None))
            ]
        else:
            objects = [
                o for o in scene.objects
                if o.animation_data or (o.type == 'ARMATURE' and getattr(o, "pose", None))
            ]
        if not objects:
            self.report({'WARNING'}, "No animated objects/rigs found to bake")
            return {'CANCELLED'}

        frames = compute_frames(props)
        if not frames:
            self.report({'INFO'}, "No frames to bake")
            return {'CANCELLED'}

        # Channel paths
        paths = []
        if props.pos:
            paths.append("location")
        if props.rot:
            paths.extend(["rotation_euler", "rotation_quaternion"])
        if props.scl:
            paths.append("scale")
        if not paths:
            self.report({'WARNING'}, "No channels selected")
            return {'CANCELLED'}

        original_frame = scene.frame_current
        baked_objects = set()
        baked_keys = 0

        for obj in objects:
            for f in frames:
                scene.frame_set(f)
                context.view_layer.update()

                if obj.type == 'ARMATURE' and getattr(obj, "pose", None):
                    for pbone in get_all_pose_bones(context, obj, props.selected_only):
                        for path in paths:
                            try:
                                pbone.keyframe_insert(data_path=path, frame=f)
                                baked_keys += 1
                            except Exception:
                                pass
                else:
                    for path in paths:
                        try:
                            obj.keyframe_insert(data_path=path, frame=f)
                            baked_keys += 1
                        except Exception:
                            pass

            baked_objects.add(obj.name)

        scene.frame_set(original_frame)

        if baked_objects and baked_keys > 0:
            self.report({'INFO'}, f"Baked {baked_keys} keyframes on {len(baked_objects)} object(s)")
            print("
=== BAKE SUCCESS ===")
            print("Frames:", frames[:20], "..." if len(frames) > 20 else "")
            print("Objects:", sorted(baked_objects))
        else:
            self.report({'INFO'}, "Nothing baked")

        return {'FINISHED'}


# ------------------------------------------------------------------------
# UI Panel
# ------------------------------------------------------------------------

class KeyframeIntervalPanel(bpy.types.Panel):
    bl_label = "Keyframe Interval Tools"
    bl_idname = "VIEW3D_PT_keyframe_interval_tools"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Item'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props

        # Sync all-channels state to children
        props.update_all_channels(context)

        layout.label(text="Frame Range")
        row = layout.row(align=True)
        row.prop(props, "start_frame", text="")
        row.prop(props, "end_frame", text="")
        row.operator("object.update_keyframe_preview", text="", icon="VIEWZOOM")

        layout.label(text="Interval (0 = all)")
        row = layout.row()
        row.prop(props, "interval")
        row.prop(props, "inverse_interval")

        layout.label(text="Channels")
        row = layout.row(align=True)
        row.prop(props, "all_channels", toggle=True)
        sub = layout.row(align=True)
        sub.enabled = not props.all_channels
        sub.prop(props, "pos", toggle=True)
        sub.prop(props, "rot", toggle=True)
        sub.prop(props, "scl", toggle=True)

        layout.prop(props, "selected_only")

        layout.separator()
        box = layout.box()
        box.label(text="Live Preview:", icon="PREVIEW_RANGE")
        box.label(text=f"Keyframes: {props.preview_keyframes}")
        box.label(text=f"Total: {props.preview_count}")

        layout.separator()
        col = layout.column(align=True)
        col.operator("object.delete_keyframe_by_interval", icon="KEY_HLT")
        col.operator("object.bake_keyframe_by_interval", icon="REC")


# ------------------------------------------------------------------------
# Registration
# ------------------------------------------------------------------------

classes = (
    DelKeyProperties,
    LivePreviewUpdateOperator,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    KeyframeIntervalPanel,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DelKeyProperties)


def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props


if __name__ == "__main__":
    register()
    if bpy.context.scene:
        update_live_preview(bpy.context.scene, bpy.context.scene.del_keyframe_props)
