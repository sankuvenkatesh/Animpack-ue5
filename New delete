bl_info = {
    "name": "Keyframe Tools Interval",
    "author": "Venkatesh Sanku",
    "version": (2, 1, 0),
    "blender": (5, 0, 0),
    "location": "View3D > Sidebar > Item",
    "description": "Delete or bake keyframes by interval for selected objects/bones",
    "category": "Animation",
}

import bpy


class DelKeyProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=1, min=1
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=250, min=1
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=0, min=0, max=100
    )
    pos: bpy.props.BoolProperty(
        name="Position", default=True
    )
    rot: bpy.props.BoolProperty(
        name="Rotation", default=True
    )
    scl: bpy.props.BoolProperty(
        name="Scale", default=True
    )


class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_description = "Delete keyframes by interval on selected objects/bones"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.active_object is not None

    def execute(self, context):
        props = context.scene.del_keyframe_props

        if props.start_frame >= props.end_frame:
            self.report({'WARNING'}, "Start frame must be less than end frame")
            return {'CANCELLED'}

        start = props.start_frame
        end = props.end_frame

        paths = []
        if props.pos:
            paths.append("location")
        if props.rot:
            paths.extend(["rotation_euler", "rotation_quaternion"])
        if props.scl:
            paths.append("scale")

        if not paths:
            self.report({'WARNING'}, "No channels selected")
            return {'CANCELLED'}

        deleted_frames = set()
        all_frames = range(start, end)

        if props.interval > 0:
            keep_frames = set(range(start, end, props.interval + 1))
        else:
            keep_frames = set()

        selected_objects = list(context.selected_objects)
        if not selected_objects:
            self.report({'WARNING'}, "No objects selected")
            return {'CANCELLED'}

        for frame in all_frames:
            if props.interval > 0 and frame in keep_frames:
                continue

            touched_any = False

            for obj in selected_objects:
                if self._delete_on_object(obj, frame, paths, context):
                    touched_any = True

            if touched_any:
                deleted_frames.add(frame)

        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        if deleted_frames:
            frames_sorted = sorted(deleted_frames)
            self.report({'INFO'}, f"Deleted {len(frames_sorted)} frames")
            print("Deleted frames:", frames_sorted)
        else:
            self.report({'INFO'}, "No keyframes deleted in range")

        return {'FINISHED'}

    def _delete_on_object(self, obj, frame, paths, context):
        touched = False

        for path in paths:
            try:
                result = obj.keyframe_delete(data_path=path, frame=frame)
                if result:
                    touched = True
            except Exception:
                pass

        if obj.type == 'ARMATURE':
            if obj.mode == 'POSE':
                pose_bones = []
                if context.selected_pose_bones:
                    pose_bones = list(context.selected_pose_bones)
                else:
                    pose_bones = list(obj.pose.bones)

                for pbone in pose_bones:
                    if self._delete_on_id(pbone, frame, paths):
                        touched = True

        return touched

    def _delete_on_id(self, id_data, frame, paths):
        touched = False
        for path in paths:
            try:
                result = id_data.keyframe_delete(data_path=path, frame=frame)
                if result:
                    touched = True
            except Exception:
                pass
        return touched


class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_description = "Bake keyframes in range on selected objects"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.active_object is not None

    def execute(self, context):
        props = context.scene.del_keyframe_props

        if props.start_frame >= props.end_frame:
            self.report({'WARNING'}, "Start frame must be less than end frame")
            return {'CANCELLED'}

        start = props.start_frame
        end = props.end_frame

        scene = context.scene
        original_frame = scene.frame_current

        selected_objects = list(context.selected_objects)
        if not selected_objects:
            self.report({'WARNING'}, "No objects selected")
            return {'CANCELLED'}

        for obj in selected_objects:
            prev_selection = [o for o in context.selected_objects]
            prev_active = context.view_layer.objects.active

            for o in context.view_layer.objects:
                o.select_set(False)
            obj.select_set(True)
            context.view_layer.objects.active = obj

            try:
                bpy.ops.nla.bake(
                    frame_start=start,
                    frame_end=end - 1,
                    only_selected=True,
                    visual_keying=True,
                    clear_constraints=False,
                    clear_parents=False,
                    use_current_action=True,
                    bake_types={'OBJECT'},
                )
            except Exception as e:
                print(f"Bake failed on {obj.name}: {e}")

            for o in context.view_layer.objects:
                o.select_set(False)
            for o in prev_selection:
                o.select_set(True)
            context.view_layer.objects.active = prev_active

        scene.frame_current = original_frame

        self.report({'INFO'}, f"Baked keyframes from {start} to {end - 1} on {len(selected_objects)} object(s)")
        print(f"Baked frames: {list(range(start, end))}")
        return {'FINISHED'}


class KeyframeIntervalPanel(bpy.types.Panel):
    bl_label = "Keyframe Interval Tools"
    bl_idname = "VIEW3D_PT_keyframe_interval_tools"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Item'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props

        layout.label(text="Frame Range")
        row = layout.row(align=True)
        row.prop(props, "start_frame")
        row.prop(props, "end_frame")

        layout.label(text="Interval (0 = all)")
        row = layout.row()
        row.prop(props, "interval")

        layout.label(text="Channels")
        row = layout.row(align=True)
        row.prop(props, "pos")
        row.prop(props, "rot")
        row.prop(props, "scl")

        layout.separator()
        col = layout.column(align=True)
        col.operator("object.delete_keyframe_by_interval", icon="KEY_HLT")
        col.operator("object.bake_keyframe_by_interval", icon="REC")


classes = (
    DelKeyProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    KeyframeIntervalPanel,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DelKeyProperties)


def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props


if __name__ == "__main__":
    register()
