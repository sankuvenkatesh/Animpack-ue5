bl_info = {
    "name": "Delete/Bake Keyframe by Interval Extended",
 # ##### BEGIN GPL LICENSE BLOCK #####
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

bl_info = {
    "name": "Delete/Bake Keyframe by Interval",
    "author": "CaptainHansode, updated for 5.0",
    "version": (2, 0, 0),
    "blender": (5, 0, 0),
    "location": "View3D > Sidebar > Item",
    "description": "Delete keyframes by interval and optionally bake on kept frames for selected objects/bones",
    "category": "Animation",
}

import bpy


class SJDelKeyProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=1, min=1
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=250, min=1
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=1, min=1, max=100
    )
    pos: bpy.props.BoolProperty(
        name="Position", default=True
    )
    rot: bpy.props.BoolProperty(
        name="Rotation", default=True
    )
    scl: bpy.props.BoolProperty(
        name="Scale", default=True
    )
    bake: bpy.props.BoolProperty(
        name="Bake Keyframes (kept frames)",
        description="Bake selected transforms on kept frames in range",
        default=False
    )


class SJDeleteKeyframeFunction(bpy.types.Operator):
    bl_idname = "object.sj_delete_keyframe_by_interval"
    bl_label = "Delete/Bake Keyframes"
    bl_description = "Delete keyframes by interval on selected objects/bones, optionally bake on kept frames"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.active_object is not None

    def execute(self, context):
        props = context.scene.sj_del_keyframe_props

        if props.start_frame >= props.end_frame or props.interval < 1:
            self.report({'WARNING'}, "Invalid frame range or interval")
            return {'CANCELLED'}

        start = props.start_frame
        end = props.end_frame

        # Frames to KEEP
        keep_frames = set(range(start, end, props.interval + 1))

        # Channels to operate on
        paths = []
        if props.pos:
            paths.append("location")
        if props.rot:
            paths.extend(["rotation_euler", "rotation_quaternion"])
        if props.scl:
            paths.append("scale")

        if not paths:
            self.report({'WARNING'}, "No channels selected")
            return {'CANCELLED'}

        # First optionally bake, then delete
        if props.bake:
            self._bake_kept_frames(context, start, end, paths, keep_frames)

        # Delete on selected objects
        for obj in context.selected_objects:
            self._delete_keys_on_id(obj, start, end, paths, keep_frames)

        # Delete on selected pose bones if in pose mode
        ob = context.object
        if ob and ob.mode == 'POSE':
            for pbone in context.selected_pose_bones:
                self._delete_keys_on_id(pbone, start, end, paths, keep_frames)

        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
        self.report({'INFO'}, "Processed keyframes by interval")
        return {'FINISHED'}

    def _delete_keys_on_id(self, id_data, start, end, paths, keep_frames):
        for frame in range(start, end):
            if frame in keep_frames:
                continue
            for path in paths:
                try:
                    id_data.keyframe_delete(data_path=path, frame=frame)
                except Exception:
                    pass

    def _bake_kept_frames(self, context, start, end, paths, keep_frames):
        scene = context.scene
        original_frame = scene.frame_current

        # Determine flags for bake from paths
        bake_loc = "location" in paths
        bake_rot = ("rotation_euler" in paths) or ("rotation_quaternion" in paths)
        bake_scale = "scale" in paths

        # Restrict bake to kept frames only using frame step
        # Step is 1 but we only keep frames in keep_frames; to avoid complex
        # custom stepping, we will iterate objects and call bake per object with full range,
        # then rely on delete step to clean unwanted frames outside keep_frames.
        for obj in list(context.selected_objects):
            # Ensure only this object is selected for the bake operator
            prev_selection = [o for o in context.selected_objects]
            prev_active = context.view_layer.objects.active

            for o in context.view_layer.objects:
                o.select_set(False)
            obj.select_set(True)
            context.view_layer.objects.active = obj

            bpy.ops.nla.bake(
                frame_start=start,
                frame_end=end - 1,
                only_selected=True,
                visual_keying=True,
                clear_constraints=False,
                clear_parents=False,
                use_current_action=True,
                bake_types={
                    'OBJECT'  # object transform; pose will be covered via bones if in pose mode
                },
            )

            # Restore selection
            for o in prev_selection:
                o.select_set(True)
            context.view_layer.objects.active = prev_active

        scene.frame_current = original_frame


class SJDeleteKeyframeByInterval(bpy.types.Panel):
    bl_label = "SJ Delete/Bake Keyframe Interval"
    bl_idname = "VIEW3D_PT_sj_delete_keyframe_interval"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Item'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.sj_del_keyframe_props

        layout.label(text="Frame Range")
        row = layout.row(align=True)
        row.prop(props, "start_frame")
        row.prop(props, "end_frame")

        layout.label(text="Interval (keep every Nth)")
        row = layout.row()
        row.prop(props, "interval")

        layout.label(text="Channels")
        row = layout.row(align=True)
        row.prop(props, "pos")
        row.prop(props, "rot")
        row.prop(props, "scl")

        layout.prop(props, "bake")

        layout.separator()
        row = layout.row()
        row.scale_y = 1.6
        row.operator("object.sj_delete_keyframe_by_interval")


classes = (
    SJDelKeyProperties,
    SJDeleteKeyframeFunction,
    SJDeleteKeyframeByInterval,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.sj_del_keyframe_props = bpy.props.PointerProperty(type=SJDelKeyProperties)


def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.sj_del_keyframe_props


if __name__ == "__main__":
    register()   "author": "Venkatesh Sanku",
    "version": (5, 0, 1),
    "blender": (5, 0, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete/bake keyframes by interval (fast F-Curve method, no custom props)",
    "category": "Animation",
}

import bpy


# ------------------------------------------------------------------------
# Properties
# ------------------------------------------------------------------------

class DeleteKeyframeProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=0, min=0,
        update=lambda self, context: self.update_preview()
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=100, min=0,
        update=lambda self, context: self.update_preview()
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=1, min=1, max=100,
        update=lambda self, context: self.update_preview()
    )
    invert: bpy.props.BoolProperty(
        name="Invert",
        default=False,
        description="OFF: delete every nth frame. ON: Delete all other frames instead",
        update=lambda self, context: self.update_preview()
    )
    all_types: bpy.props.BoolProperty(
        name="ALL Properties", default=True
    )
    only_selected: bpy.props.BoolProperty(
        name="Only Selected", default=False,
        update=lambda self, context: self.update_preview()
    )
    pos: bpy.props.BoolProperty(name="Location", default=True)
    rot: bpy.props.BoolProperty(name="Rotation", default=True)
    scl: bpy.props.BoolProperty(name="Scale", default=True)
    preview_count: bpy.props.IntProperty(default=0, options={'HIDDEN'})

    def update_preview(self):
        frames = calculate_frames(self)
        self.preview_count = len(frames)


# ------------------------------------------------------------------------
# Core helpers
# ------------------------------------------------------------------------

def calculate_frames(props):
    start, end, interval, invert = props.start_frame, props.end_frame, props.interval, props.invert

    if end < start or interval < 1:
        return []

    all_frames = list(range(start, end + 1))
    interval_frames = [all_frames[i] for i in range(len(all_frames)) if i % interval == 0]

    if invert:
        result = [f for f in all_frames if f not in interval_frames]
    else:
        result = interval_frames

    return result


def bone_fcurves_for_target(arm_obj, pbone, props):
    """Get fcurves affecting this pose bone (location/rot/scale)."""
    if arm_obj is None or arm_obj.animation_data is None or arm_obj.animation_data.action is None:
        return []

    action = arm_obj.animation_data.action
    name = pbone.name
    prefix = f'pose.bones["{name}"]'
    fcurves = []

    want_loc = props.all_types or props.pos
    want_rot = props.all_types or props.rot
    want_scl = props.all_types or props.scl

    for fc in action.fcurves:
        dp = fc.data_path
        if not dp.startswith(prefix + "."):
            continue

        tail = dp[len(prefix) + 1:]  # after 'pose.bones["Name"].'

        if want_loc and tail == "location":
            fcurves.append(fc)
        elif want_rot and tail in {"rotation_euler", "rotation_quaternion"}:
            fcurves.append(fc)
        elif want_scl and tail == "scale":
            fcurves.append(fc)

    return fcurves


def object_fcurves_for_target(obj, props):
    """Get fcurves affecting this object (location/rot/scale)."""
    if obj.animation_data is None or obj.animation_data.action is None:
        return []

    action = obj.animation_data.action
    fcurves = []

    want_loc = props.all_types or props.pos
    want_rot = props.all_types or props.rot
    want_scl = props.all_types or props.scl

    for fc in action.fcurves:
        dp = fc.data_path

        if want_loc and dp == "location":
            fcurves.append(fc)
        elif want_rot and dp in {"rotation_euler", "rotation_quaternion"}:
            fcurves.append(fc)
        elif want_scl and dp == "scale":
            fcurves.append(fc)

    return fcurves


def delete_keyframes_fc_posebone(arm_obj, pbone, frames_s, props):
    deleted = 0
    fcurves = bone_fcurves_for_target(arm_obj, pbone, props)
    if not fcurves:
        return 0

    for fc in fcurves:
        kps = fc.keyframe_points
        to_remove = [i for i, k in enumerate(kps) if int(round(k.co[0])) in frames_s]
        for i in reversed(to_remove):
            try:
                kps.remove(kps[i], fast=True)
                deleted += 1
            except AttributeError:
                # older Blender versions may not support fast kwarg
                kps.remove(kps[i])
                deleted += 1
    return deleted


def delete_keyframes_fc_object(obj, frames_s, props):
    deleted = 0
    fcurves = object_fcurves_for_target(obj, props)
    if not fcurves:
        return 0

    for fc in fcurves:
        kps = fc.keyframe_points
        to_remove = [i for i, k in enumerate(kps) if int(round(k.co[0])) in frames_s]
        for i in reversed(to_remove):
            try:
                kps.remove(kps[i], fast=True)
                deleted += 1
            except AttributeError:
                kps.remove(kps[i])
                deleted += 1
    return deleted


def bake_keyframes_fc_posebone(arm_obj, pbone, frames_l, props, context):
    baked = 0
    scene = context.scene
    orig = scene.frame_current

    fcurves = bone_fcurves_for_target(arm_obj, pbone, props)
    if not fcurves:
        return 0

    for f in frames_l:
        scene.frame_set(f)
        context.view_layer.update()
        for fc in fcurves:
            val = fc.evaluate(f)
            try:
                fc.keyframe_points.insert(f, val, options={'FAST'})
            except TypeError:
                # some versions expect options as a set or no options
                fc.keyframe_points.insert(f, val)
            baked += 1

    scene.frame_set(orig)
    context.view_layer.update()
    return baked


def bake_keyframes_fc_object(obj, frames_l, props, context):
    baked = 0
    scene = context.scene
    orig = scene.frame_current

    fcurves = object_fcurves_for_target(obj, props)
    if not fcurves:
        return 0

    for f in frames_l:
        scene.frame_set(f)
        context.view_layer.update()
        for fc in fcurves:
            val = fc.evaluate(f)
            try:
                fc.keyframe_points.insert(f, val, options={'FAST'})
            except TypeError:
                fc.keyframe_points.insert(f, val)
            baked += 1

    scene.frame_set(orig)
    context.view_layer.update()
    return baked


def get_targets(context, only_selected):
    # protect against weird contexts (like register/unregister)
    if not hasattr(context, "mode"):
        return []

    if context.mode == 'POSE':
        arm = context.object
        if arm and arm.type == 'ARMATURE':
            return list(context.selected_pose_bones) if only_selected else list(arm.pose.bones)
        return []
    else:
        if only_selected:
            return list(getattr(context, "selected_objects", []))
        else:
            return list(context.scene.objects)


# ------------------------------------------------------------------------
# Operators
# ------------------------------------------------------------------------

class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)
        if not frames:
            self.report({'WARNING'}, "No frames to process")
            return {'CANCELLED'}

        frames_s = set(frames)
        targets = get_targets(context, props.only_selected)
        if not targets:
            self.report({'WARNING'}, "No targets")
            return {'CANCELLED'}

        total_deleted = 0
        used_targets = 0

        if context.mode == 'POSE':
            arm_obj = context.object
            for pbone in targets:
                d = delete_keyframes_fc_posebone(arm_obj, pbone, frames_s, props)
                total_deleted += d
                if d:
                    used_targets += 1
        else:
            for obj in targets:
                d = delete_keyframes_fc_object(obj, frames_s, props)
                total_deleted += d
                if d:
                    used_targets += 1

        for area in context.screen.areas:
            if area.type in {'VIEW_3D', 'GRAPH_EDITOR', 'DOPESHEET_EDITOR', 'TIMELINE'}:
                area.tag_redraw()

        self.report({'INFO'}, f"Deleted {total_deleted} keyframes on {used_targets}/{len(targets)} targets")
        return {'FINISHED'}


class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)
        if not frames:
            self.report({'WARNING'}, "No frames to process")
            return {'CANCELLED'}

        targets = get_targets(context, props.only_selected)
        if not targets:
            self.report({'WARNING'}, "No targets")
            return {'CANCELLED'}

        total_baked = 0
        used_targets = 0

        if context.mode == 'POSE':
            arm_obj = context.object
            for pbone in targets:
                b = bake_keyframes_fc_posebone(arm_obj, pbone, frames, props, context)
                total_baked += b
                if b:
                    used_targets += 1
        else:
            for obj in targets:
                b = bake_keyframes_fc_object(obj, frames, props, context)
                total_baked += b
                if b:
                    used_targets += 1

        self.report({'INFO'}, f"Baked {total_baked} keyframes on {used_targets}/{len(targets)} targets")
        return {'FINISHED'}


# ------------------------------------------------------------------------
# UI Panel
# ------------------------------------------------------------------------

class DeleteBakeKeyframePanel(bpy.types.Panel):
    bl_label = "‚ú® Fast Interval Keyframe Manager"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)

        banner = layout.row()
        banner.alignment = 'CENTER'
        banner.label(text="üöÄ F-Curve Keyframe Manager", icon='ANIM')

        layout.separator()

        row = layout.row(align=True)
        row.prop(props, "start_frame", text="From")
        row.prop(props, "end_frame", text="To")
        row.prop(props, "interval", text="Every")

        invert_row = layout.row()
        invert_btn = invert_row.operator(
            "wm.context_toggle",
            text="Invert" if not props.invert else "Interval",
            depress=props.invert
        )
        invert_btn.data_path = "scene.del_keyframe_props.invert"

        split = layout.split(factor=0.4)
        col1 = split.column()
        col2 = split.column()

        col1.label(text="üéØ Targets")
        col1.prop(props, "only_selected", toggle=True, icon='RESTRICT_SELECT_OFF')

        col2.label(text="‚öôÔ∏è Properties")
        col2.prop(props, "all_types", toggle=True)
        if not props.all_types:
            box = col2.box()
            box.prop(props, "pos", toggle=True, icon='ORIENTATION_GLOBAL')
            box.prop(props, "rot", toggle=True, icon='DRIVER_ROTATIONAL_DIFFERENCE')
            box.prop(props, "scl", toggle=True, icon='FULLSCREEN_ENTER')

        layout.separator()

        preview_box = layout.box()
        preview_row = preview_box.row()
        preview_row.label(text=f"Frames: {len(frames)}", icon='TIME')
        frames_text = frames[:10]
        if len(frames) > 10:
            frames_text.append('...')
        preview_box.label(text=f"[{', '.join(map(str, frames_text))}]")

        layout.separator(factor=1.5)

        row = layout.row()
        row.scale_y = 1.4
        row.operator("object.delete_keyframe_by_interval", text="üóëÔ∏è DELETE KEYS", icon='TRASH')

        row = layout.row()
        row.scale_y = 1.4
        row.operator("object.bake_keyframe_by_interval", text="üî• BAKE KEYS", icon='KEY_HLT')


# ------------------------------------------------------------------------
# Registration
# ------------------------------------------------------------------------

classes = (
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    DeleteBakeKeyframePanel,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DeleteKeyframeProperties)


def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props


if __name__ == "__main__":
    register()
