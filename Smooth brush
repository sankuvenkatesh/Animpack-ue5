bl_info = {
    "name": "FCurve Smooth Brush Pro",
    "author": "Venkatesh sanku",
    "version": (2, 1, 2),
    "blender": (5, 0, 0),
    "location": "Graph Editor > Sidebar > Tool",
    "description": "Stable FCurve smoothing brush for Blender 5.x",
    "category": "Animation",
}

import bpy
import gpu
import time
import numpy as np
from mathutils import Vector
from gpu_extras.batch import batch_for_shader
from bpy.props import (
    FloatProperty,
    IntProperty,
    BoolProperty,
    EnumProperty,
    PointerProperty,
)

# --------------------------------------------------
# Filters
# --------------------------------------------------

def gaussian_weights(radius):
    sigma = max(radius / 2.0, 0.001)
    w = [np.exp(-(i*i)/(2*sigma*sigma)) for i in range(-radius, radius+1)]
    s = sum(w)
    return [x/s for x in w]

def butterworth(values, cutoff=0.35):
    out = [values[0]]
    for i in range(1, len(values)):
        out.append(out[-1] + cutoff * (values[i] - out[-1]))
    return out

def channel_allowed(fc, mode):
    p = fc.data_path.lower()
    if mode == 'ALL': return True
    if mode == 'LOC': return "location" in p
    if mode == 'ROT': return "rotation" in p
    if mode == 'SCALE': return "scale" in p
    if mode == 'CUSTOM': return "[" in p
    return False

# --------------------------------------------------
# Draw helpers
# --------------------------------------------------

def draw_cursor(self, context):
    if not context.area:
        return

    p = context.scene.fcurve_brush
    r = p.brush_size
    cx, cy = self.mx, self.my

    shader = gpu.shader.from_builtin('UNIFORM_COLOR')
    shader.bind()

    verts = [
        (cx + np.cos(a)*r, cy + np.sin(a)*r)
        for a in np.linspace(0, 2*np.pi, 32, endpoint=False)
    ]

    batch = batch_for_shader(shader, 'LINE_LOOP', {"pos": verts})
    shader.uniform_float("color", (1, 1, 1, 0.9))
    batch.draw(shader)

# --------------------------------------------------
# Properties
# --------------------------------------------------

class FCurveBrushProps(bpy.types.PropertyGroup):
    brush_size: FloatProperty(default=50, min=1, max=600)
    strength: FloatProperty(default=0.6, min=0, max=1)

    axis: EnumProperty(
        items=[('Y',"Value",""), ('X',"Time",""), ('BOTH',"Both","")],
        default='Y'
    )

    mode: EnumProperty(
        items=[
            ('SMOOTH',"Smooth",""),
            ('GAUSSIAN',"Gaussian",""),
            ('BUTTER',"Butterworth",""),
            ('NOISE',"Noise",""),
            ('FLATTEN',"Flatten",""),
            ('SHARPEN',"Sharpen",""),
            ('RELAX',"Relax",""),
        ],
        default='SMOOTH'
    )

    filter_radius: IntProperty(default=3, min=1, max=10)
    channel_filter: EnumProperty(
        items=[('ALL',"All",""), ('LOC',"Loc",""),
               ('ROT',"Rot",""), ('SCALE',"Scale",""),
               ('CUSTOM',"Custom","")],
        default='ALL'
    )

    pressure_enabled: BoolProperty(default=True)
    sample_rate: IntProperty(default=1, min=1, max=10)
    active: BoolProperty(default=False)

# --------------------------------------------------
# Operator (NO __init__)
# --------------------------------------------------

class GRAPH_OT_fcurve_brush(bpy.types.Operator):
    bl_idname = "graph.fcurve_brush"
    bl_label = "FCurve Brush Pro"
    bl_options = {'REGISTER'}

    def cleanup(self):
        if self.h_cursor:
            bpy.types.SpaceGraphEditor.draw_handler_remove(self.h_cursor, 'WINDOW')
        self.h_cursor = None

    def modal(self, context, event):
        self.mx = event.mouse_region_x
        self.my = event.mouse_region_y
        self.mouse = Vector((self.mx, self.my))

        if event.type == 'ESC':
            self.cleanup()
            context.scene.fcurve_brush.active = False
            context.window.cursor_set('DEFAULT')
            return {'CANCELLED'}

        if event.type == 'LEFTMOUSE':
            if event.value == 'PRESS':
                bpy.ops.ed.undo_push(message="FCurve Brush Stroke")
                self.painting = True
            else:
                self.painting = False

        if event.type == 'MOUSEMOVE':
            if (
                context.scene.fcurve_brush.pressure_enabled
                and event.pressure is not None
                and event.pressure > 0
            ):
                self.pressure = event.pressure
            else:
                self.pressure = 1.0

            if self.painting and time.time() - self.last_time > 0.03:
                self.apply(context)
                self.last_time = time.time()

            context.area.tag_redraw()

        return {'RUNNING_MODAL'}

    def apply(self, context):
        p = context.scene.fcurve_brush
        view = context.region.view2d
        strength = p.strength * self.pressure

        for fc in context.selected_editable_fcurves:
            if not channel_allowed(fc, p.channel_filter):
                continue

            keys = list(fc.keyframe_points)[::p.sample_rate]

            for i, k in enumerate(keys):
                coord = view.view_to_region(k.co[0], k.co[1], clip=False)
                if coord is None or len(coord) < 2:
                    continue

                sx, sy = coord[0], coord[1]
                dx = sx - self.mouse.x
                dy = sy - self.mouse.y
                dist = (dx*dx + dy*dy) ** 0.5

                if dist > p.brush_size:
                    continue

                f = (1 - dist/p.brush_size) * strength

                # ---- Y axis ----
                if p.axis in {'Y','BOTH'}:
                    if p.mode == 'SMOOTH' and 0 < i < len(keys)-1:
                        avg = (keys[i-1].co[1] + keys[i+1].co[1]) * 0.5
                        k.co[1] += (avg - k.co[1]) * f

                    elif p.mode in {'GAUSSIAN','BUTTER'}:
                        r = p.filter_radius
                        if i < r or i >= len(keys)-r:
                            continue
                        vals = [x.co[1] for x in keys[i-r:i+r+1]]
                        target = (
                            sum(v*w for v,w in zip(vals, gaussian_weights(r)))
                            if p.mode == 'GAUSSIAN'
                            else butterworth(vals)[r]
                        )
                        k.co[1] += (target - k.co[1]) * f

                # ---- X axis ----
                if p.axis in {'X','BOTH'} and p.mode == 'RELAX' and 0 < i < len(keys)-1:
                    avgx = (keys[i-1].co[0] + keys[i+1].co[0]) * 0.5
                    k.co[0] += (avgx - k.co[0]) * f

            fc.update()

    def invoke(self, context, event):
        if context.area.type != 'GRAPH_EDITOR':
            return {'CANCELLED'}

        # SAFE INIT HERE
        self.mouse = Vector((0, 0))
        self.mx = self.my = 0
        self.painting = False
        self.pressure = 1.0
        self.last_time = 0.0
        self.h_cursor = None

        context.scene.fcurve_brush.active = True

        self.h_cursor = bpy.types.SpaceGraphEditor.draw_handler_add(
            draw_cursor, (self, context), 'WINDOW', 'POST_PIXEL'
        )

        context.window.cursor_set('NONE')
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}

# --------------------------------------------------
# UI
# --------------------------------------------------

class GRAPH_PT_fcurve_brush(bpy.types.Panel):
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = 'Tool'
    bl_label = 'FCurve Brush Pro'

    def draw(self, context):
        p = context.scene.fcurve_brush
        l = self.layout

        if not p.active:
            l.operator("graph.fcurve_brush", icon='BRUSH_DATA')
        else:
            l.label(text="Brush Active", icon='RADIOBUT_ON')

        l.prop(p, "mode")
        l.prop(p, "axis")
        l.prop(p, "channel_filter")
        l.prop(p, "brush_size")
        l.prop(p, "strength")
        if p.mode in {'GAUSSIAN','BUTTER'}:
            l.prop(p, "filter_radius")
        l.prop(p, "pressure_enabled")
        l.prop(p, "sample_rate")

# --------------------------------------------------
# Register
# --------------------------------------------------

classes = (
    FCurveBrushProps,
    GRAPH_OT_fcurve_brush,
    GRAPH_PT_fcurve_brush,
)

def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.Scene.fcurve_brush = PointerProperty(type=FCurveBrushProps)

def unregister():
    for c in reversed(classes):
        bpy.utils.unregister_class(c)
    del bpy.types.Scene.fcurve_brush

if __name__ == "__main__":
    register()
