bl_info = {
    "name": "FCurve Smooth Brush Pro",
    "author": "Venkatesh sanku",
    "version": (2, 1, 1),
    "blender": (5, 0, 0),
    "location": "Graph Editor > Sidebar > Tool",
    "description": "Error-free professional FCurve smoothing brush for Blender 5.x",
    "category": "Animation",
}

import bpy
import gpu
import time
import numpy as np
from mathutils import Vector
from gpu_extras.batch import batch_for_shader
from bpy.props import *

# --------------------------------------------------
# Filters
# --------------------------------------------------

def gaussian_weights(radius):
    sigma = max(radius / 2.0, 0.001)
    w = [np.exp(-(i*i)/(2*sigma*sigma)) for i in range(-radius, radius+1)]
    s = sum(w)
    return [x/s for x in w]

def butterworth(values, cutoff=0.35):
    out = [values[0]]
    for i in range(1, len(values)):
        out.append(out[-1] + cutoff * (values[i] - out[-1]))
    return out

def channel_allowed(fc, mode):
    p = fc.data_path.lower()
    if mode == 'ALL': return True
    if mode == 'LOC': return "location" in p
    if mode == 'ROT': return "rotation" in p
    if mode == 'SCALE': return "scale" in p
    if mode == 'CUSTOM': return "[" in p
    return False

# --------------------------------------------------
# Draw
# --------------------------------------------------

def draw_cursor(self, context):
    if not self or not context.area:
        return

    p = context.scene.fcurve_brush
    r = p.brush_size
    cx, cy = self.mx, self.my

    shader = gpu.shader.from_builtin('UNIFORM_COLOR')
    shader.bind()

    verts = [
        (cx + np.cos(a)*r, cy + np.sin(a)*r)
        for a in np.linspace(0, 2*np.pi, 32, endpoint=False)
    ]

    batch = batch_for_shader(shader, 'LINE_LOOP', {"pos": verts})
    shader.uniform_float("color", (1,1,1,0.9))
    batch.draw(shader)

def draw_fill(self, context):
    if not self.painting:
        return

    p = context.scene.fcurve_brush
    r = p.brush_size
    cx, cy = self.mouse.x, self.mouse.y

    shader = gpu.shader.from_builtin('UNIFORM_COLOR')
    shader.bind()

    verts = [(cx, cy)]
    idx = []

    for i in range(32):
        a = 2*np.pi*i/32
        verts.append((cx + np.cos(a)*r, cy + np.sin(a)*r))
        idx += [0, i+1, 1 if i==31 else i+2]

    batch = batch_for_shader(shader, 'TRIS', {"pos": verts}, indices=idx)
    shader.uniform_float("color", (0.3, 0.6, 1.0, 0.12))
    batch.draw(shader)

# --------------------------------------------------
# Properties
# --------------------------------------------------

class FCurveBrushProps(bpy.types.PropertyGroup):
    brush_size: FloatProperty(default=50, min=1, max=600)
    strength: FloatProperty(default=0.6, min=0, max=1)

    axis: EnumProperty(
        items=[('Y',"Value",""),('X',"Time",""),('BOTH',"Both","")],
        default='Y'
    )

    mode: EnumProperty(
        items=[
            ('SMOOTH',"Smooth",""),
            ('GAUSSIAN',"Gaussian",""),
            ('BUTTER',"Butterworth",""),
            ('NOISE',"Noise",""),
            ('FLATTEN',"Flatten",""),
            ('SHARPEN',"Sharpen",""),
            ('RELAX',"Relax",""),
        ],
        default='SMOOTH'
    )

    filter_radius: IntProperty(default=3, min=1, max=10)
    channel_filter: EnumProperty(
        items=[('ALL',"All",""),('LOC',"Loc",""),('ROT',"Rot",""),
               ('SCALE',"Scale",""),('CUSTOM',"Custom","")],
        default='ALL'
    )

    pressure_enabled: BoolProperty(default=True)
    sample_rate: IntProperty(default=1, min=1, max=10)
    active: BoolProperty(default=False)

# --------------------------------------------------
# Operator
# --------------------------------------------------

class GRAPH_OT_fcurve_brush(bpy.types.Operator):
    bl_idname = "graph.fcurve_brush"
    bl_label = "FCurve Brush Pro"
    bl_options = {'REGISTER'}

    def __init__(self):
        self.mouse = Vector((0,0))
        self.mx = self.my = 0
        self.painting = False
        self.pressure = 1.0
        self.last_time = 0
        self.h1 = self.h2 = None

    def cleanup(self):
        for h in (self.h1, self.h2):
            if h:
                bpy.types.SpaceGraphEditor.draw_handler_remove(h, 'WINDOW')
        self.h1 = self.h2 = None

    def modal(self, context, event):
        self.mx, self.my = event.mouse_region_x, event.mouse_region_y
        self.mouse = Vector((self.mx, self.my))

        if event.type == 'ESC':
            self.cleanup()
            context.scene.fcurve_brush.active = False
            context.window.cursor_set('DEFAULT')
            return {'CANCELLED'}

        if event.type == 'LEFTMOUSE':
            if event.value == 'PRESS':
                bpy.ops.ed.undo_push(message="FCurve Brush Stroke")
                self.painting = True
            else:
                self.painting = False

        if event.type == 'MOUSEMOVE':
            self.pressure = event.pressure if (
                context.scene.fcurve_brush.pressure_enabled and
                event.pressure is not None and event.pressure > 0
            ) else 1.0

            if self.painting and time.time()-self.last_time > 0.03:
                self.apply(context)
                self.last_time = time.time()

            context.area.tag_redraw()

        return {'RUNNING_MODAL'}

    def apply(self, context):
        p = context.scene.fcurve_brush
        view = context.region.view2d
        strength = p.strength * self.pressure

        for fc in context.selected_editable_fcurves:
            if not channel_allowed(fc, p.channel_filter):
                continue

            keys = list(fc.keyframe_points)[::p.sample_rate]

            for i, k in enumerate(keys):
                pos = view.view_to_region(k.co[0], k.co[1])
                if not pos:
                    continue

                sx, sy = pos
                dist = ((sx-self.mouse.x)**2 + (sy-self.mouse.y)**2)**0.5
                if dist > p.brush_size:
                    continue

                f = (1 - dist/p.brush_size) * strength

                # Y-axis processing
                if p.axis in {'Y','BOTH'}:
                    if p.mode in {'GAUSSIAN','BUTTER'}:
                        r = p.filter_radius
                        if i<r or i>=len(keys)-r:
                            continue
                        vals = [x.co[1] for x in keys[i-r:i+r+1]]
                        tgt = (sum(v*w for v,w in zip(vals,gaussian_weights(r)))
                               if p.mode=='GAUSSIAN'
                               else butterworth(vals)[r])
                        k.co[1] += (tgt - k.co[1]) * f

                # X-axis relax
                if p.axis in {'X','BOTH'} and p.mode=='RELAX' and 0<i<len(keys)-1:
                    k.co[0] += ((keys[i-1].co[0]+keys[i+1].co[0])/2 - k.co[0]) * f

            fc.update()

    def invoke(self, context, event):
        if context.area.type != 'GRAPH_EDITOR':
            return {'CANCELLED'}

        context.scene.fcurve_brush.active = True
        self.h1 = bpy.types.SpaceGraphEditor.draw_handler_add(
            draw_fill, (self, context), 'WINDOW', 'POST_PIXEL')
        self.h2 = bpy.types.SpaceGraphEditor.draw_handler_add(
            draw_cursor, (self, context), 'WINDOW', 'POST_PIXEL')

        context.window.cursor_set('NONE')
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}

# --------------------------------------------------
# UI
# --------------------------------------------------

class GRAPH_PT_fcurve_brush(bpy.types.Panel):
    bl_space_type='GRAPH_EDITOR'
    bl_region_type='UI'
    bl_category='Tool'
    bl_label='FCurve Brush Pro'

    def draw(self, context):
        p = context.scene.fcurve_brush
        l = self.layout

        if not p.active:
            l.operator("graph.fcurve_brush", icon='BRUSH_DATA')
        else:
            l.label(text="Brush Active", icon='RADIOBUT_ON')

        l.prop(p,"mode")
        l.prop(p,"axis")
        l.prop(p,"channel_filter")
        l.prop(p,"brush_size")
        l.prop(p,"strength")
        if p.mode in {'GAUSSIAN','BUTTER'}:
            l.prop(p,"filter_radius")
        l.prop(p,"pressure_enabled")
        l.prop(p,"sample_rate")

# --------------------------------------------------
# Register
# --------------------------------------------------

classes = (FCurveBrushProps, GRAPH_OT_fcurve_brush, GRAPH_PT_fcurve_brush)

def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.Scene.fcurve_brush = PointerProperty(type=FCurveBrushProps)

def unregister():
    for c in reversed(classes):
        bpy.utils.unregister_class(c)
    del bpy.types.Scene.fcurve_brush

if __name__ == "__main__":
    register()
