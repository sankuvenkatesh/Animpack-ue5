bl_info = {
    "name": "FCurve Smooth Brush Pro",
    "author": "Venkatesh sanku",
    "version": (2, 2, 0),
    "blender": (5, 0, 0),
    "location": "Graph Editor > Sidebar > Tool",
    "description": "Stable FCurve smoothing brush with ON/OFF toggle (Blender 5.x)",
    "category": "Animation",
}

import bpy
import gpu
import time
import numpy as np
from mathutils import Vector
from gpu_extras.batch import batch_for_shader
from bpy.props import (
    FloatProperty,
    IntProperty,
    BoolProperty,
    EnumProperty,
    PointerProperty,
)

# --------------------------------------------------
# Filters
# --------------------------------------------------

def gaussian_weights(radius):
    sigma = max(radius / 2.0, 0.001)
    w = [np.exp(-(i*i)/(2*sigma*sigma)) for i in range(-radius, radius+1)]
    s = sum(w)
    return [x/s for x in w]

def butterworth(values, cutoff=0.35):
    out = [values[0]]
    for i in range(1, len(values)):
        out.append(out[-1] + cutoff * (values[i] - out[-1]))
    return out

def channel_allowed(fc, mode):
    p = fc.data_path.lower()
    if mode == 'ALL': return True
    if mode == 'LOC': return "location" in p
    if mode == 'ROT': return "rotation" in p
    if mode == 'SCALE': return "scale" in p
    if mode == 'CUSTOM': return "[" in p
    return False

# --------------------------------------------------
# Draw cursor
# --------------------------------------------------

def draw_cursor(self, context):
    props = context.scene.fcurve_brush
    if not props.enabled:
        return

    r = props.brush_size
    cx, cy = self.mx, self.my

    shader = gpu.shader.from_builtin('UNIFORM_COLOR')
    shader.bind()

    verts = [
        (cx + np.cos(a)*r, cy + np.sin(a)*r)
        for a in np.linspace(0, 2*np.pi, 32, endpoint=False)
    ]

    batch = batch_for_shader(shader, 'LINE_LOOP', {"pos": verts})
    shader.uniform_float("color", (1, 1, 1, 0.9))
    batch.draw(shader)

# --------------------------------------------------
# Properties
# --------------------------------------------------

class FCurveBrushProps(bpy.types.PropertyGroup):

    enabled: BoolProperty(
        name="Brush Enabled",
        description="Enable / Disable brush without exiting",
        default=True
    )

    brush_size: FloatProperty(default=50, min=1, max=600)
    strength: FloatProperty(default=0.6, min=0, max=1)

    axis: EnumProperty(
        items=[('Y',"Value",""), ('X',"Time",""), ('BOTH',"Both","")],
        default='Y'
    )

    mode: EnumProperty(
        items=[
            ('SMOOTH',"Smooth",""),
            ('GAUSSIAN',"Gaussian",""),
            ('BUTTER',"Butterworth",""),
            ('NOISE',"Noise",""),
            ('FLATTEN',"Flatten",""),
            ('SHARPEN',"Sharpen",""),
            ('RELAX',"Relax",""),
        ],
        default='SMOOTH'
    )

    filter_radius: IntProperty(default=3, min=1, max=10)

    channel_filter: EnumProperty(
        items=[('ALL',"All",""), ('LOC',"Loc",""),
               ('ROT',"Rot",""), ('SCALE',"Scale",""),
               ('CUSTOM',"Custom","")],
        default='ALL'
    )

    pressure_enabled: BoolProperty(default=True)
    sample_rate: IntProperty(default=1, min=1, max=10)
    active: BoolProperty(default=False)

# --------------------------------------------------
# Operator
# --------------------------------------------------

class GRAPH_OT_fcurve_brush(bpy.types.Operator):
    bl_idname = "graph.fcurve_brush"
    bl_label = "FCurve Brush Pro"
    bl_options = {'REGISTER'}

    def cleanup(self):
        if self.h_cursor:
            bpy.types.SpaceGraphEditor.draw_handler_remove(self.h_cursor, 'WINDOW')
        self.h_cursor = None

    def modal(self, context, event):
        props = context.scene.fcurve_brush

        self.mx = event.mouse_region_x
        self.my = event.mouse_region_y
        self.mouse = Vector((self.mx, self.my))

        if event.type == 'ESC':
            self.cleanup()
            props.active = False
            context.window.cursor_set('DEFAULT')
            return {'CANCELLED'}

        if event.type == 'LEFTMOUSE':
            if event.value == 'PRESS':
                bpy.ops.ed.undo_push(message="FCurve Brush Stroke")
                self.painting = True
            else:
                self.painting = False

        if event.type == 'MOUSEMOVE':
            self.pressure = (
                event.pressure
                if props.pressure_enabled
                and event.pressure is not None
                and event.pressure > 0
                else 1.0
            )

            if (
                props.enabled
                and self.painting
                and time.time() - self.last_time > 0.03
            ):
                self.apply(context)
                self.last_time = time.time()

            context.area.tag_redraw()

        return {'RUNNING_MODAL'}

    def apply(self, context):
        props = context.scene.fcurve_brush
        view = context.region.view2d
        strength = props.strength * self.pressure

        for fc in context.selected_editable_fcurves:
            if not channel_allowed(fc, props.channel_filter):
                continue

            keys = list(fc.keyframe_points)[::props.sample_rate]

            for i, k in enumerate(keys):
                coord = view.view_to_region(k.co[0], k.co[1], clip=False)
                if coord is None or len(coord) < 2:
                    continue

                sx, sy = coord[0], coord[1]
                dx = sx - self.mouse.x
                dy = sy - self.mouse.y
                dist = (dx*dx + dy*dy) ** 0.5

                if dist > props.brush_size:
                    continue

                f = (1 - dist/props.brush_size) * strength

                # ---- Y AXIS ----
                if props.axis in {'Y','BOTH'}:
                    if props.mode == 'SMOOTH' and 0 < i < len(keys)-1:
                        avg = (keys[i-1].co[1] + keys[i+1].co[1]) * 0.5
                        k.co[1] += (avg - k.co[1]) * f

                    elif props.mode in {'GAUSSIAN','BUTTER'}:
                        r = props.filter_radius
                        if i < r or i >= len(keys)-r:
                            continue
                        vals = [x.co[1] for x in keys[i-r:i+r+1]]
                        target = (
                            sum(v*w for v,w in zip(vals, gaussian_weights(r)))
                            if props.mode == 'GAUSSIAN'
                            else butterworth(vals)[r]
                        )
                        k.co[1] += (target - k.co[1]) * f

                # ---- X AXIS ----
                if props.axis in {'X','BOTH'} and props.mode == 'RELAX' and 0 < i < len(keys)-1:
                    avgx = (keys[i-1].co[0] + keys[i+1].co[0]) * 0.5
                    k.co[0] += (avgx - k.co[0]) * f

            fc.update()

    def invoke(self, context, event):
        if context.area.type != 'GRAPH_EDITOR':
            return {'CANCELLED'}

        # SAFE INIT
        self.mouse = Vector((0, 0))
        self.mx = self.my = 0
        self.painting = False
        self.pressure = 1.0
        self.last_time = 0.0
        self.h_cursor = None

        context.scene.fcurve_brush.active = True

        self.h_cursor = bpy.types.SpaceGraphEditor.draw_handler_add(
            draw_cursor, (self, context), 'WINDOW', 'POST_PIXEL'
        )

        context.window.cursor_set('NONE')
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}

# --------------------------------------------------
# UI Panel
# --------------------------------------------------

class GRAPH_PT_fcurve_brush(bpy.types.Panel):
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = 'Tool'
    bl_label = 'FCurve Brush Pro'

    def draw(self, context):
        p = context.scene.fcurve_brush
        l = self.layout

        row = l.row()
        row.prop(
            p,
            "enabled",
            toggle=True,
            icon='HIDE_OFF' if p.enabled else 'HIDE_ON'
        )

        if not p.active:
            l.operator("graph.fcurve_brush", icon='BRUSH_DATA')
        else:
            l.label(text="Brush Active", icon='RADIOBUT_ON')

        l.prop(p, "mode")
        l.prop(p, "axis")
        l.prop(p, "channel_filter")
        l.prop(p, "brush_size")
        l.prop(p, "strength")

        if p.mode in {'GAUSSIAN','BUTTER'}:
            l.prop(p, "filter_radius")

        l.prop(p, "pressure_enabled")
        l.prop(p, "sample_rate")

# --------------------------------------------------
# Register
# --------------------------------------------------

classes = (
    FCurveBrushProps,
    GRAPH_OT_fcurve_brush,
    GRAPH_PT_fcurve_brush,
)

def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.Scene.fcurve_brush = PointerProperty(type=FCurveBrushProps)

def unregister():
    for c in reversed(classes):
        bpy.utils.unregister_class(c)
    del bpy.types.Scene.fcurve_brush

if __name__ == "__main__":
    register()
