bl_info = {
    "name": "Rotation Continuity (Euler and Quaternion, Partial Selection, Preserve Handles)",
    "author": "Adapted by Perplexity (2025)",
    "version": (1, 4),
    "blender": (2, 80, 0),
    "location": "Graph Editor > Sidebar > Rotation Continuity Tab",
    "description": "Unwraps or smooths selected rotation channels in Euler or Quaternion modes for continuity, preserving handle types and positions.",
    "category": "Animation"
}

import bpy
import math
from mathutils import Euler, Quaternion

# ---------- Utility Functions ----------

def nearest_equivalent_euler(a1, a2):
    twopi = 2 * math.pi
    while a2 - a1 > math.pi:
        a2 -= twopi
    while a2 - a1 < -math.pi:
        a2 += twopi
    return a2

def get_selected_rotation_fcurves(context, mode_code):
    obj = context.active_object
    if not obj or not obj.animation_data or not obj.animation_data.action:
        return None, "No animated object with keyframes selected."
    suffix = "rotation_euler" if mode_code == "EULER" else "rotation_quaternion"
    expected_count = 3 if mode_code == "EULER" else 4
    all_fcurves = obj.animation_data.action.fcurves

    # Get only selected fcurves that match suffix
    selected_fcurves = [fc for fc in all_fcurves if fc.select and fc.data_path.endswith(suffix)]
    if not selected_fcurves:
        return None, f"No selected {suffix} f-curves found."
    # Sort by array_index for predictable order
    selected_fcurves.sort(key=lambda fc: fc.array_index)

    # For quaternion mode: ideally all 4 channels selected for reliable continuity
    if mode_code == "QUATERNION" and len(selected_fcurves) != expected_count:
        return None, "Select all 4 quaternion channels (W, X, Y, Z) for continuity filtering."

    return selected_fcurves, None

def get_fcurve_keyframe_map(fcurve):
    return {int(round(kp.co[0])): kp for kp in fcurve.keyframe_points}

def collect_keyframes_with_handles(curves):
    # Collect all unique frames that have keyframes in selected curves
    axis_keyframes = [get_fcurve_keyframe_map(fc) for fc in curves]
    frames = sorted({f for mapping in axis_keyframes for f in mapping})
    keyframe_info = []
    for f in frames:
        kps = [mapping.get(f) for mapping in axis_keyframes]
        if all(kps):  # Only consider frames where all selected curves have keyframes
            value = [kp.co[1] for kp in kps]
            handles = [{
                'handle_left_type': kp.handle_left_type,
                'handle_right_type': kp.handle_right_type,
                'handle_left': kp.handle_left.copy(),
                'handle_right': kp.handle_right.copy(),
            } for kp in kps]
            keyframe_info.append({
                'frame': f,
                'value': value,
                'handles': handles,
            })
    return keyframe_info

def unwrap_keyframe_values_euler(keyframes):
    out = []
    prev = None
    for info in keyframes:
        e = info['value']
        if prev is None:
            fixed = list(e)
        else:
            fixed = [nearest_equivalent_euler(prev[i], e[i]) for i in range(len(e))]
        out.append({
            'frame': info['frame'],
            'value': fixed,
            'handles': info['handles'],
        })
        prev = fixed
    return out

def unwrap_keyframe_values_quaternion(keyframes):
    out = []
    prev = None
    for info in keyframes:
        q = Quaternion(info['value'])
        if prev is not None:
            if prev.dot(q) < 0.0:
                q = -q
        out.append({
            'frame': info['frame'],
            'value': [q.w, q.x, q.y, q.z],
            'handles': info['handles'],
        })
        prev = Quaternion(q)
    return out

def preserve_and_update_fcurve_points(curves, keyframe_infos):
    for axis, fc in enumerate(curves):
        frame_map = get_fcurve_keyframe_map(fc)
        for info in keyframe_infos:
            f = info['frame']
            v = info['value'][axis]
            kph = info['handles'][axis]
            kp = frame_map.get(f)
            if kp:
                kp.co[1] = v
                kp.handle_left_type = kph['handle_left_type']
                kp.handle_right_type = kph['handle_right_type']
                kp.handle_left = kph['handle_left']
                kp.handle_right = kph['handle_right']
        fc.update()

# ---------- Main Operator ----------

class ROTATION_OT_preserve_continuity_partial(bpy.types.Operator):
    """Unwraps selected rotation channels for continuity. Supports any number of selected channels in Euler or Quaternion mode. Preserves handles."""
    bl_idname = "graph.rotation_continuity_partial"
    bl_label = "Preserve Rotation Continuity (Partial Selection)"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        obj = context.active_object
        if not obj:
            self.report({'ERROR'}, "No active object.")
            return {'CANCELLED'}

        mode = obj.rotation_mode
        if mode == "QUATERNION":
            mode_code = "QUATERNION"
        elif mode in {"XYZ", "XZY", "YXZ", "YZX", "ZXY", "ZYX"}:
            mode_code = "EULER"
        else:
            self.report({'ERROR'}, f"Unsupported rotation mode: {mode}")
            return {'CANCELLED'}

        selected_fcurves, err = get_selected_rotation_fcurves(context, mode_code)
        if selected_fcurves is None:
            self.report({'ERROR'}, err)
            return {'CANCELLED'}

        keyframes = collect_keyframes_with_handles(selected_fcurves)
        if not keyframes:
            self.report({'ERROR'}, "No matching keyframes found on all selected channels.")
            return {'CANCELLED'}

        if mode_code == "EULER":
            unwrapped = unwrap_keyframe_values_euler(keyframes)
        else:
            unwrapped = unwrap_keyframe_values_quaternion(keyframes)

        preserve_and_update_fcurve_points(selected_fcurves, unwrapped)

        self.report({'INFO'}, f"{mode_code} continuity applied on {len(selected_fcurves)} selected channel(s).")
        return {'FINISHED'}

# ---------- Optional: Set Euler Operator ----------

class ROTATION_OT_set_euler_mode(bpy.types.Operator):
    """Set active object's rotation mode to Euler XYZ."""
    bl_idname = "object.set_euler_mode"
    bl_label = "Set Euler XYZ Mode"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        obj = context.active_object
        if obj and obj.rotation_mode != 'XYZ':
            obj.rotation_mode = 'XYZ'
        self.report({'INFO'}, "Object set to Euler XYZ rotation mode.")
        return {'FINISHED'}

# ---------- Panel ----------

class ROTATION_PT_continuity_panel(bpy.types.Panel):
    bl_label = "Rotation Continuity"
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = "Rotation"

    def draw(self, context):
        layout = self.layout
        col = layout.column(align=True)
        col.label(text="Preserve/correct multi-rotations (Euler or Quaternion):")
        col.operator("graph.rotation_continuity_partial", icon='CON_ROTLIKE')
        col.separator()
        col.label(text="Quick Rotation Mode Switch:")
        row = col.row(align=True)
        row.operator("object.set_euler_mode", icon='DRIVER_TRANSFORM')
        col.label(text="Handles/tangents are always preserved.")

# ---------- Registration ----------

classes = [
    ROTATION_OT_preserve_continuity_partial,
    ROTATION_OT_set_euler_mode,
    ROTATION_PT_continuity_panel,
]

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)
if __name__ == "__main__":
    register()
