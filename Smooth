import bpy

def smooth_fcurve(fcurve, iterations, strength, smoothness, preserve_ends=True):
    """
    Smooth the given F-Curve by iteratively averaging keyframe points values.
    """
    keyframes = fcurve.keyframe_points
    n = len(keyframes)
    if n < 3:
        return  # Need at least 3 points to smooth meaningfully

    values = [kp.co[1] for kp in keyframes]

    strength_factor = strength ** 3
    smoothness_factor = smoothness ** 2

    for _ in range(iterations):
        new_values = values[:]
        for i in range(1, n - 1):
            if preserve_ends and (i == 0 or i == n - 1):
                continue

            left = values[i - 1]
            center = values[i]
            right = values[i + 1]
            weighted_average = (left + center + right) / 3

            weight = strength_factor * (1.0 - smoothness_factor)
            new_values[i] = center * (1 - weight) + weighted_average * weight

        values = new_values

    for i, kp in enumerate(keyframes):
        kp.co[1] = values[i]

    fcurve.update()

class CurveSmoothProperties(bpy.types.PropertyGroup):
    iterations: bpy.props.IntProperty(
        name="Iterations",
        description="Number of smoothing iterations",
        default=5, min=1, max=50
    )
    strength: bpy.props.FloatProperty(
        name="Strength",
        description="Smoothing intensity",
        default=0.5, min=0.0, max=1.0
    )
    smoothness: bpy.props.FloatProperty(
        name="Smoothness",
        description="Sensitivity falloff of smoothing",
        default=0.5, min=0.0, max=1.0
    )
    preserve_ends: bpy.props.BoolProperty(
        name="Preserve Ends",
        description="Prevent smoothing of first and last keyframes",
        default=True
    )

class CurveSmoothOperator(bpy.types.Operator):
    """Smooth Selected F-Curves in Graph Editor"""
    bl_idname = "graph.smooth_fcurves"
    bl_label = "Smooth F-Curves"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        settings = context.scene.curve_smooth_settings
        fcurves = context.selected_editable_fcurves
        if not fcurves:
            self.report({'WARNING'}, "No editable F-Curves selected")
            return {'CANCELLED'}

        for fcurve in fcurves:
            smooth_fcurve(
                fcurve,
                settings.iterations,
                settings.strength,
                settings.smoothness,
                settings.preserve_ends,
            )
        self.report({'INFO'}, f"Smoothed {len(fcurves)} F-Curve(s)")
        return {'FINISHED'}

class CurveSmoothPanel(bpy.types.Panel):
    """Panel in the Graph Editor for Curve Smoothing"""
    bl_label = "Curve Smooth Filter"
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = "Smooth Tools"

    def draw(self, context):
        layout = self.layout
        settings = context.scene.curve_smooth_settings

        layout.label(text="Adjust smoothing parameters and apply:")
        layout.prop(settings, "iterations")
        layout.prop(settings, "strength")
        layout.prop(settings, "smoothness")
        layout.prop(settings, "preserve_ends")
        layout.operator("graph.smooth_fcurves", text="Apply Smooth")

def register():
    bpy.utils.register_class(CurveSmoothProperties)
    bpy.types.Scene.curve_smooth_settings = bpy.props.PointerProperty(type=CurveSmoothProperties)
    bpy.utils.register_class(CurveSmoothOperator)
    bpy.utils.register_class(CurveSmoothPanel)

def unregister():
    bpy.utils.unregister_class(CurveSmoothPanel)
    bpy.utils.unregister_class(CurveSmoothOperator)
    del bpy.types.Scene.curve_smooth_settings
    bpy.utils.unregister_class(CurveSmoothProperties)

if __name__ == "__main__":
    register()
