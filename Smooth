bl_info = {
    "name": "Smart Curve Filters",
    "blender": (3, 0, 0),  # Adjust for your Blender version
    "category": "Animation",
    "description": "Smart animation curve filters (smooth, intensity, interpolation) using quaternion math.",
}

import bpy
from mathutils import Quaternion

class CurveFilterSettings(bpy.types.PropertyGroup):
    smooth_steps: bpy.props.IntProperty(
        name="Smooth Steps", default=3, min=1, max=10,
        description="Number of smoothing iterations"
    )
    intensity: bpy.props.FloatProperty(
        name="Intensity", default=1.0, min=0.0, max=1.0,
        description="Blend between original and smoothed"
    )
    interpolate: bpy.props.FloatProperty(
        name="Interpolation", default=0.5, min=0.0, max=1.0,
        description="Interpolation (future expansion)"
    )

class CURVE_OT_apply_filters(bpy.types.Operator):
    bl_idname = "curve.apply_filters"
    bl_label = "Apply Smart Curve Filters"

    def execute(self, context):
        settings = context.scene.curve_filter_settings
        obj = context.object
        if not obj or not obj.animation_data:
            self.report({"ERROR"}, "Active object has no animation data")
            return {'CANCELLED'}

        fcurves = obj.animation_data.action.fcurves
        rot_fcurves = [f for f in fcurves if f.data_path.endswith("rotation_quaternion")]
        if len(rot_fcurves) < 4:
            self.report({"ERROR"}, "Need 4 quaternion rotation fcurves")
            return {'CANCELLED'}
        
        # Gather all unique frame numbers and corresponding quaternions
        keyframes = {}
        for fcurve in rot_fcurves:
            idx = fcurve.array_index
            for kp in fcurve.keyframe_points:
                frame = kp.co.x
                val = kp.co.y
                if frame not in keyframes:
                    keyframes[frame] = [0, 0, 0, 0]
                keyframes[frame][idx] = val

        frames_sorted = sorted(keyframes)
        quat_keys = [Quaternion(keyframes[f]) for f in frames_sorted]

        # Smoothing function (moving average for quaternions)
        def smooth_quaternions(quats, steps):
            smoothed = quats[:]
            for _ in range(steps):
                new = smoothed[:]
                for i in range(1, len(smoothed) - 1):
                    left = smoothed[i - 1]
                    mid = smoothed[i]
                    right = smoothed[i + 1]
                    avg = left.slerp(mid, 0.5).slerp(right, 0.5)
                    new[i] = avg
                smoothed = new
            return smoothed

        smoothed_quats = smooth_quaternions(quat_keys, settings.smooth_steps)
        # Blend original & smoothed by intensity
        blended_quats = [
            orig.slerp(smooth, settings.intensity)
            for orig, smooth in zip(quat_keys, smoothed_quats)
        ]

        # Write back to fcurves
        for i, fcurve in enumerate(rot_fcurves):
            fcurve.keyframe_points.clear()
        for frame, quat in zip(frames_sorted, blended_quats):
            for i, fcurve in enumerate(rot_fcurves):
                fcurve.keyframe_points.insert(frame, quat[i])

        self.report({"INFO"}, "Smart curve filters applied!")
        return {'FINISHED'}

class CURVE_PT_filter_panel(bpy.types.Panel):
    bl_label = "Smart Curve Filters"
    bl_idname = "CURVE_PT_filter_panel"
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = 'Filters'

    def draw(self, context):
        layout = self.layout
        s = context.scene.curve_filter_settings
        layout.prop(s, "smooth_steps")
        layout.prop(s, "intensity")
        layout.prop(s, "interpolate")
        layout.operator("curve.apply_filters", icon='MOD_SMOOTH')

classes = [CurveFilterSettings, CURVE_OT_apply_filters, CURVE_PT_filter_panel]

def register():
    for cls in classes: bpy.utils.register_class(cls)
    bpy.types.Scene.curve_filter_settings = bpy.props.PointerProperty(type=CurveFilterSettings)

def unregister():
    for cls in reversed(classes): bpy.utils.unregister_class(cls)
    del bpy.types.Scene.curve_filter_settings

if __name__ == "__main__":
    register()
