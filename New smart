bl_info = {
    "name": "Smart Curve Tools",
    "author": "Venkatesh Sanku (merged by AI assistant)",
    "version": (1, 8),
    "blender": (5, 0, 0),
    "location": "Graph Editor > Sidebar > Smart Curve Tools Tab",
    "description": "Smart Euler Filter + Advanced F-Curve Smoothing for Blender 5.0",
    "category": "Animation",
}

import bpy
import math
from mathutils import Euler, Quaternion

# ----- Utility Functions -----

def clamp(value, minv, maxv):
    return min(max(value, minv), maxv)

def get_graph_fcurves(context):
    """Get F-Curves from Graph Editor context - Blender 5.0"""
    fcurves = []
    
    # Method 1: Selected editable fcurves (Graph Editor selection)
    try:
        selected_fcurves = getattr(context, "selected_editable_fcurves", [])
        if selected_fcurves:
            fcurves.extend(selected_fcurves)
    except:
        pass
    
    # Method 2: Graph Editor space data
    try:
        if context.space_data and context.space_data.type == 'GRAPH_EDITOR':
            if context.space_data.edit_object and context.space_data.edit_object.animation_data:
                if context.space_data.edit_object.animation_data.action:
                    fcurves.extend(context.space_data.edit_object.animation_data.action.fcurves)
    except:
        pass
    
    # Method 3: Active object
    try:
        obj = context.active_object
        if obj and obj.animation_data and obj.animation_data.action:
            fcurves.extend(obj.animation_data.action.fcurves)
    except:
        pass
    
    return list(set(fcurves))  # Remove duplicates

def auto_fix_bad_keyframes(fcurve):
    try:
        keyframes = fcurve.keyframe_points
        for i, kp in enumerate(keyframes):
            if not math.isfinite(kp.co[1]):
                # Simple fix - set to 0
                kp.co[1] = 0.0
    except:
        pass

def set_bezier_and_auto_clamp_handles(fcurve):
    try:
        for kp in fcurve.keyframe_points:
            kp.interpolation = 'BEZIER'
            kp.handle_left_type = 'AUTO_CLAMPED'
            kp.handle_right_type = 'AUTO_CLAMPED'
        fcurve.update()
    except:
        pass

# ORIGINAL ADVANCED SMOOTHING - FULLY RESTORED
def smooth_keyframes(fcurve, iterations, strength, sensitivity, preserve_ends=True, all_keyframes=False):
    try:
        keyframes = fcurve.keyframe_points
        n = len(keyframes)
        if n < 3:
            return {'moved': 0, 'max_delta': 0}
        if all_keyframes:
            indices = list(range(n))
        else:
            indices = [i for i, kp in enumerate(keyframes) if kp.select_control_point]
            if len(indices) < 3:
                return {'moved': 0, 'max_delta': 0}
        values = [kp.co[1] for kp in keyframes]
        stats = {'moved': 0, 'max_delta': 0}
        strength_factor = strength ** 3
        smooth_factor = 1.0 - sensitivity
        for _ in range(iterations):
            new_values = values[:]
            for idx_pos in range(1, len(indices) - 1):
                i = indices[idx_pos]
                if preserve_ends and (idx_pos == 0 or idx_pos == len(indices) - 1):
                    continue
                left_i = indices[idx_pos-1]
                right_i = indices[idx_pos+1]
                left = values[left_i]
                center = values[i]
                right = values[right_i]
                average = (left + center + right) / 3
                diff = abs(center - average)
                base = abs(center) if center != 0 else 1.0
                weight_unclamped = strength_factor * (1 - smooth_factor + smooth_factor * (diff / base))
                weight = clamp(weight_unclamped, 0.0, 1.0)
                new_val = center * (1 - weight) + average * weight
                if not math.isfinite(new_val):
                    new_val = center
                delta = new_val - center
                new_values[i] = new_val
                if abs(delta) > 0:
                    stats['moved'] += 1
                    stats['max_delta'] = max(stats['max_delta'], abs(delta))
            values = new_values
        for i in indices:
            keyframes[i].co[1] = values[i]
        auto_fix_bad_keyframes(fcurve)
        fcurve.update()
        return stats
    except:
        return {'moved': 0, 'max_delta': 0}

# ----- Euler Filter -----

def nearest_equivalent_euler(a1, a2):
    twopi = 2 * math.pi
    while a2 - a1 > math.pi:
        a2 -= twopi
    while a2 - a1 < -math.pi:
        a2 += twopi
    return a2

def get_rotation_curves(fcurves):
    """Find rotation curves (Euler or Quaternion)"""
    rotation_curves = []
    
    # Euler rotation
    euler_curves = [fc for fc in fcurves if 'rotation_euler' in fc.data_path]
    if len(euler_curves) >= 3:
        rotation_curves = sorted(euler_curves, key=lambda fc: getattr(fc, 'array_index', 0))
    
    # Quaternion rotation  
    quat_curves = [fc for fc in fcurves if 'rotation_quaternion' in fc.data_path]
    if len(quat_curves) >= 4:
        rotation_curves = sorted(quat_curves, key=lambda fc: getattr(fc, 'array_index', 0))
    
    return rotation_curves

def apply_euler_filter(fcurves):
    """Apply Euler/Quaternion continuity filter"""
    try:
        rotation_curves = get_rotation_curves(fcurves)
        if not rotation_curves:
            return False
            
        # Get all frames from all curves
        frame_map = {}
        for fc in rotation_curves:
            for kp in fc.keyframe_points:
                frame = int(round(kp.co[0]))
                if frame not in frame_map:
                    frame_map[frame] = [None] * len(rotation_curves)
                frame_map[frame][rotation_curves.index(fc)] = kp.co[1]
        
        frames = sorted(frame_map.keys())
        if len(frames) < 2:
            return False
            
        # Unwrap Euler/Quat
        prev_values = None
        for frame in frames:
            values = frame_map[frame]
            if prev_values is None:
                fixed = values[:]
            else:
                fixed = []
                for i, val in enumerate(values):
                    if val is not None and prev_values[i] is not None:
                        fixed.append(nearest_equivalent_euler(prev_values[i], val))
                    else:
                        fixed.append(val)
            
            # Update keyframes
            for i, fc in enumerate(rotation_curves):
                kp = next((k for k in fc.keyframe_points if int(round(k.co[0])) == frame), None)
                if kp and fixed[i] is not None:
                    kp.co[1] = fixed[i]
            
            prev_values = fixed[:]
        
        for fc in rotation_curves:
            fc.update()
        return True
    except:
        return False

# ----- Operators -----

class ROTATION_OT_smart_euler_filter(bpy.types.Operator):
    bl_idname = "graph.smart_euler_filter"
    bl_label = "Smart Euler Filter"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        fcurves = get_graph_fcurves(context)
        if not fcurves:
            self.report({'ERROR'}, "No F-Curves found. Select curves in Graph Editor.")
            return {'CANCELLED'}
            
        if apply_euler_filter(fcurves):
            self.report({'INFO'}, f"Euler filter applied!")
            return {'FINISHED'}
        else:
            self.report({'WARNING'}, "No rotation curves found")
            return {'CANCELLED'}

class CurveSmoothProperties(bpy.types.PropertyGroup):
    iterations: bpy.props.IntProperty(
        name="Iterations",
        description="Number of smoothing iterations",
        default=5, min=1, max=50
    )
    strength: bpy.props.FloatProperty(
        name="Strength",
        description="Smoothing intensity (0-1)",
        default=0.5, min=0.0, max=1.0
    )
    sensitivity: bpy.props.FloatProperty(
        name="Sensitivity",
        description="Smoothing sensitivity falloff (Reversed effect, 0-1)",
        default=0.5, min=0.0, max=1.0
    )
    preserve_ends: bpy.props.BoolProperty(
        name="Preserve Ends",
        description="Do not smooth the first and last selected keyframes",
        default=True
    )

class SMOOTH_OT_selected(bpy.types.Operator):
    bl_idname = "graph.smooth_selected_keyframes"
    bl_label = "Smooth Selected Keyframes"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        if not hasattr(context.scene, 'curve_smooth_settings'):
            self.report({'ERROR'}, "Settings not initialized")
            return {'CANCELLED'}
            
        settings = context.scene.curve_smooth_settings
        curves = getattr(context, "selected_editable_fcurves", [])
        
        if not curves:
            self.report({'WARNING'}, "Select F-Curves first")
            return {'CANCELLED'}
            
        smoothed_count = 0
        total_keys = 0
        biggest_move = 0
        
        for fcurve in curves:
            stats = smooth_keyframes(
                fcurve, settings.iterations, settings.strength, 
                settings.sensitivity, settings.preserve_ends, False
            )
            if stats['moved'] > 0:
                set_bezier_and_auto_clamp_handles(fcurve)
                smoothed_count += 1
                total_keys += stats['moved']
                biggest_move = max(biggest_move, stats['max_delta'])

        if smoothed_count == 0:
            self.report({'WARNING'}, "Not enough selected keyframes")
            return {'CANCELLED'}

        self.report({'INFO'}, f"Smoothed {total_keys} keyframes in {smoothed_count} F-Curve(s)")
        return {'FINISHED'}

class SMOOTH_OT_all(bpy.types.Operator):
    bl_idname = "graph.smooth_all_keyframes"
    bl_label = "Batch Smooth All F-Curves"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        if not hasattr(context.scene, 'curve_smooth_settings'):
            self.report({'ERROR'}, "Settings not initialized")
            return {'CANCELLED'}
            
        settings = context.scene.curve_smooth_settings
        fcurves = get_graph_fcurves(context)
        
        if not fcurves:
            self.report({'WARNING'}, "No F-Curves found")
            return {'CANCELLED'}
            
        smoothed_count = 0
        total_keys = 0
        biggest_move = 0
        
        for fcurve in fcurves:
            stats = smooth_keyframes(
                fcurve, settings.iterations, settings.strength, 
                settings.sensitivity, settings.preserve_ends, True
            )
            if stats['moved'] > 0:
                set_bezier_and_auto_clamp_handles(fcurve)
                smoothed_count += 1
                total_keys += stats['moved']
                biggest_move = max(biggest_move, stats['max_delta'])

        if smoothed_count == 0:
            self.report({'WARNING'}, "No F-Curves with enough keyframes")
            return {'CANCELLED'}

        self.report({'INFO'}, f"Batch smoothed {total_keys} keyframes in {smoothed_count} F-Curve(s)")
        return {'FINISHED'}

class SMOOTH_OT_reset(bpy.types.Operator):
    bl_idname = "graph.reset_curve_smooth_values"
    bl_label = "Reset Curve Smooth Values"
    bl_options = {'REGISTER'}
    
    def execute(self, context):
        if hasattr(context.scene, 'curve_smooth_settings'):
            settings = context.scene.curve_smooth_settings
            settings.iterations = 5
            settings.strength = 0.5
            settings.sensitivity = 0.5
            settings.preserve_ends = True
            self.report({'INFO'}, "Reset to defaults")
            return {'FINISHED'}
        return {'CANCELLED'}

class SMARTCURVETOOLS_PT_panel(bpy.types.Panel):
    bl_label = "Smart Curve Tools"
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = "Smart Curve Tools"

    def draw(self, context):
        layout = self.layout
        
        # Status
        fcurves = get_graph_fcurves(context)
        layout.label(text=f"F-Curves: {len(fcurves)} âœ“" if fcurves else "No F-Curves X")
        
        layout.separator()
        
        # Smart Euler Filter
        layout.label(text="Smart Euler Filter:")
        layout.operator("graph.smart_euler_filter", icon='CON_ROTLIKE')
        
        layout.separator()
        
        # Curve Smoothing Parameters
        if hasattr(context.scene, 'curve_smooth_settings'):
            settings = context.scene.curve_smooth_settings
            layout.label(text="Curve Smoothing Parameters:")
            layout.prop(settings, "iterations")
            layout.prop(settings, "strength")
            layout.prop(settings, "sensitivity")
            layout.prop(settings, "preserve_ends")
            
            # Operators
            col = layout.column(align=True)
            col.operator("graph.smooth_selected_keyframes", text="Smooth Selected Keyframes", icon='SMOOTH')
            col.operator("graph.smooth_all_keyframes", text="Batch Smooth All F-Curves", icon='MOD_SMOOTH')
            layout.operator("graph.reset_curve_smooth_values", text="Reset Smooth Values", icon='FILE_REFRESH')
        else:
            layout.label(text="Reload addon", icon='ERROR')

# ----- Register -----

classes = [
    ROTATION_OT_smart_euler_filter,
    CurveSmoothProperties,
    SMOOTH_OT_selected,
    SMOOTH_OT_all,
    SMOOTH_OT_reset,
    SMARTCURVETOOLS_PT_panel,
]

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.curve_smooth_settings = bpy.props.PointerProperty(type=CurveSmoothProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    try:
        del bpy.types.Scene.curve_smooth_settings
    except:
        pass

if __name__ == "__main__":
    register()
