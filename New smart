bl_info = {
    "name": "Smart Curve Tools",
    "author": "Venkatesh Sanku (merged by AI assistant)",
    "version": (1, 7),
    "blender": (5, 0, 0),
    "location": "Graph Editor > Sidebar > Smart Curve Tools Tab",
    "description": "Smart Euler Filter + Advanced F-Curve Smoothing for Blender 5.0",
    "category": "Animation",
}

import bpy
import math
from mathutils import Euler, Quaternion

# ----- Utility Functions -----

def clamp(value, minv, maxv):
    return min(max(value, minv), maxv)

def get_graph_fcurves(context):
    """Get F-Curves from Graph Editor context - Blender 5.0"""
    fcurves = []
    
    # Method 1: Selected editable fcurves (Graph Editor selection)
    try:
        selected_fcurves = getattr(context, "selected_editable_fcurves", [])
        if selected_fcurves:
            fcurves.extend(selected_fcurves)
    except:
        pass
    
    # Method 2: Graph Editor space data
    try:
        if context.space_data and context.space_data.type == 'GRAPH_EDITOR':
            if context.space_data.edit_object and context.space_data.edit_object.animation_data:
                if context.space_data.edit_object.animation_data.action:
                    fcurves.extend(context.space_data.edit_object.animation_data.action.fcurves)
    except:
        pass
    
    # Method 3: Active object
    try:
        obj = context.active_object
        if obj and obj.animation_data and obj.animation_data.action:
            fcurves.extend(obj.animation_data.action.fcurves)
    except:
        pass
    
    return list(set(fcurves))  # Remove duplicates

def auto_fix_bad_keyframes(fcurve):
    try:
        keyframes = fcurve.keyframe_points
        for i, kp in enumerate(keyframes):
            if not math.isfinite(kp.co[1]):
                # Simple fix - set to 0
                kp.co[1] = 0.0
    except:
        pass

def set_bezier_and_auto_clamp_handles(fcurve):
    try:
        for kp in fcurve.keyframe_points:
            kp.interpolation = 'BEZIER'
            kp.handle_left_type = 'AUTO_CLAMPED'
            kp.handle_right_type = 'AUTO_CLAMPED'
        fcurve.update()
    except:
        pass

def smooth_keyframes(fcurve, iterations, strength, sensitivity, preserve_ends=True, all_keyframes=False):
    try:
        keyframes = fcurve.keyframe_points
        if len(keyframes) < 3:
            return {'moved': 0, 'max_delta': 0}
            
        if all_keyframes:
            indices = list(range(len(keyframes)))
        else:
            indices = [i for i, kp in enumerate(keyframes) if kp.select_control_point]
            if len(indices) < 3:
                return {'moved': 0, 'max_delta': 0}
                
        values = [kp.co[1] for kp in keyframes]
        stats = {'moved': 0, 'max_delta': 0}
        
        for _ in range(iterations):
            new_values = values[:]
            for idx_pos in range(1, len(indices) - 1):
                i = indices[idx_pos]
                left_i, right_i = indices[idx_pos-1], indices[idx_pos+1]
                average = (values[left_i] + values[i] + values[right_i]) / 3
                weight = clamp(strength, 0.0, 1.0)
                new_val = values[i] * (1 - weight) + average * weight
                delta = abs(new_val - values[i])
                new_values[i] = new_val
                if delta > 0:
                    stats['moved'] += 1
                    stats['max_delta'] = max(stats['max_delta'], delta)
            values = new_values
            
        for i in indices:
            keyframes[i].co[1] = values[i]
        fcurve.update()
        return stats
    except:
        return {'moved': 0, 'max_delta': 0}

# ----- Euler Filter -----

def nearest_equivalent_euler(a1, a2):
    twopi = 2 * math.pi
    while a2 - a1 > math.pi:
        a2 -= twopi
    while a2 - a1 < -math.pi:
        a2 += twopi
    return a2

def get_rotation_curves(fcurves):
    """Find rotation curves (Euler or Quaternion)"""
    rotation_curves = []
    
    # Euler rotation
    euler_curves = [fc for fc in fcurves if 'rotation_euler' in fc.data_path]
    if len(euler_curves) >= 3:
        rotation_curves = sorted(euler_curves, key=lambda fc: getattr(fc, 'array_index', 0))
    
    # Quaternion rotation  
    quat_curves = [fc for fc in fcurves if 'rotation_quaternion' in fc.data_path]
    if len(quat_curves) >= 4:
        rotation_curves = sorted(quat_curves, key=lambda fc: getattr(fc, 'array_index', 0))
    
    return rotation_curves

def apply_euler_filter(fcurves):
    """Apply Euler/Quaternion continuity filter"""
    try:
        rotation_curves = get_rotation_curves(fcurves)
        if not rotation_curves:
            return False
            
        # Get all frames from all curves
        frame_map = {}
        for fc in rotation_curves:
            for kp in fc.keyframe_points:
                frame = int(round(kp.co[0]))
                if frame not in frame_map:
                    frame_map[frame] = [None] * len(rotation_curves)
                frame_map[frame][rotation_curves.index(fc)] = kp.co[1]
        
        frames = sorted(frame_map.keys())
        if len(frames) < 2:
            return False
            
        # Unwrap Euler/Quat
        prev_values = None
        for frame in frames:
            values = frame_map[frame]
            if prev_values is None:
                fixed = values[:]
            else:
                fixed = []
                for i, val in enumerate(values):
                    if val is not None and prev_values[i] is not None:
                        fixed.append(nearest_equivalent_euler(prev_values[i], val))
                    else:
                        fixed.append(val)
            
            # Update keyframes
            for i, fc in enumerate(rotation_curves):
                kp = next((k for k in fc.keyframe_points if int(round(k.co[0])) == frame), None)
                if kp and fixed[i] is not None:
                    kp.co[1] = fixed[i]
            
            prev_values = fixed[:]
        
        for fc in rotation_curves:
            fc.update()
        return True
    except:
        return False

# ----- Operators -----

class ROTATION_OT_smart_euler_filter(bpy.types.Operator):
    bl_idname = "graph.smart_euler_filter"
    bl_label = "Smart Euler Filter"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        fcurves = get_graph_fcurves(context)
        if not fcurves:
            self.report({'ERROR'}, "No F-Curves found. Select curves in Graph Editor.")
            return {'CANCELLED'}
            
        if apply_euler_filter(fcurves):
            self.report({'INFO'}, f"Euler filter applied to {len(fcurves)} curves!")
            return {'FINISHED'}
        else:
            self.report({'WARNING'}, "No rotation curves found")
            return {'CANCELLED'}

class CurveSmoothProperties(bpy.types.PropertyGroup):
    iterations: bpy.props.IntProperty(default=5, min=1, max=50, name="Iterations")
    strength: bpy.props.FloatProperty(default=0.5, min=0.0, max=1.0, name="Strength")
    preserve_ends: bpy.props.BoolProperty(default=True, name="Preserve Ends")

class SMOOTH_OT_selected(bpy.types.Operator):
    bl_idname = "graph.smooth_selected"
    bl_label = "Smooth Selected"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        settings = context.scene.curve_smooth_settings
        curves = getattr(context, "selected_editable_fcurves", [])
        
        if not curves:
            self.report({'WARNING'}, "Select F-Curves first")
            return {'CANCELLED'}
            
        total_keys = 0
        for fcurve in curves:
            stats = smooth_keyframes(fcurve, settings.iterations, settings.strength, 
                                   0.5, settings.preserve_ends, False)
            total_keys += stats['moved']
            
        self.report({'INFO'}, f"Smoothed {total_keys} keyframes")
        return {'FINISHED'}

class SMOOTH_OT_all(bpy.types.Operator):
    bl_idname = "graph.smooth_all"
    bl_label = "Smooth All Curves"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        settings = context.scene.curve_smooth_settings
        fcurves = get_graph_fcurves(context)
        
        if not fcurves:
            self.report({'WARNING'}, "No F-Curves found")
            return {'CANCELLED'}
            
        total_keys = 0
        for fcurve in fcurves:
            stats = smooth_keyframes(fcurve, settings.iterations, settings.strength, 
                                   0.5, settings.preserve_ends, True)
            total_keys += stats['moved']
            
        self.report({'INFO'}, f"Smoothed {total_keys} keyframes in {len(fcurves)} curves")
        return {'FINISHED'}

class SMOOTH_OT_reset(bpy.types.Operator):
    bl_idname = "graph.smooth_reset"
    bl_label = "Reset"
    bl_options = {'REGISTER'}
    
    def execute(self, context):
        settings = context.scene.curve_smooth_settings
        settings.iterations = 5
        settings.strength = 0.5
        settings.preserve_ends = True
        self.report({'INFO'}, "Reset settings")
        return {'FINISHED'}

class SMARTCURVETOOLS_PT_panel(bpy.types.Panel):
    bl_label = "Smart Curve Tools"
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = "Smart Curve Tools"

    def draw(self, context):
        layout = self.layout
        
        # Status
        fcurves = get_graph_fcurves(context)
        layout.label(text=f"F-Curves: {len(fcurves)} âœ“" if fcurves else "No F-Curves X")
        
        layout.separator()
        
        # Euler Filter
        layout.operator("graph.smart_euler_filter", icon='CON_ROTLIKE')
        
        layout.separator()
        
        # Smoothing settings
        if hasattr(context.scene, 'curve_smooth_settings'):
            settings = context.scene.curve_smooth_settings
            layout.prop(settings, "iterations")
            layout.prop(settings, "strength")
            layout.prop(settings, "preserve_ends")
            
            col = layout.column(align=True)
            col.operator("graph.smooth_selected", text="Smooth Selected", icon='SMOOTH')
            col.operator("graph.smooth_all", text="Smooth All", icon='MOD_SMOOTH')
            layout.operator("graph.smooth_reset", text="Reset", icon='FILE_REFRESH')
        else:
            layout.label(text="Reload addon", icon='ERROR')

# ----- Register -----

classes = [
    ROTATION_OT_smart_euler_filter,
    CurveSmoothProperties,
    SMOOTH_OT_selected,
    SMOOTH_OT_all,
    SMOOTH_OT_reset,
    SMARTCURVETOOLS_PT_panel,
]

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.curve_smooth_settings = bpy.props.PointerProperty(type=CurveSmoothProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    try:
        del bpy.types.Scene.curve_smooth_settings
    except:
        pass

if __name__ == "__main__":
    register()
