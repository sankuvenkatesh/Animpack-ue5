bl_info = {
    "name": "Euler Filter",
    "author": "Venkatesh",
    "version": (0, 2, 0),
    "blender": (3, 0, 0),
    "location": "Graph Editor > Search > Euler Filter",
    "description": "Filter Euler rotations to remove gimbal lock artifacts",
    "warning": "",
    "doc_url": "",
    "category": "Venky Anim Toolz"
}

import bpy
from math import pi
from mathutils import Euler
import itertools

# --- MATH HELPERS ---

def r(a):
    """Radians to degrees conversion."""
    return a / (2 * pi) * 360.0

def degrees(a):
    """Degrees to radians conversion."""
    return a / 360.0 * 2 * pi

def wrap_angle(a):
    return (a + pi) % (2 * pi) - pi

def euler_distance(e1, e2):
    return abs(e1[0] - e2[0]) + abs(e1[1] - e2[1]) + abs(e1[2] - e2[2])

def euler_axis_index(axis):
    if axis == 'X': return 0
    if axis == 'Y': return 1
    if axis == 'Z': return 2
    return None

def flip_euler(euler, rotation_mode):
    ret = euler.copy()
    inner_axis, middle_axis, outer_axis = rotation_mode[0], rotation_mode[1], rotation_mode[2]
    ret[euler_axis_index(inner_axis)] += pi
    ret[euler_axis_index(outer_axis)] += pi
    ret[euler_axis_index(middle_axis)] *= -1
    ret[euler_axis_index(middle_axis)] += pi
    return ret

def naive_flip_diff(a1, a2):
    while abs(a1 - a2) > pi:
        if a1 < a2:
            a2 -= 2 * pi
        else:
            a2 += 2 * pi
    return a2

def euler_filter(kfs, rotation_mode):
    if len(kfs) <= 1:
        return kfs
    prev = kfs[0]["rotation_euler"]
    ret = [{"key": kfs[0]["key"], "rotation_euler": prev.copy()}]
    for i in range(1, len(kfs)):
        e = kfs[i]["rotation_euler"].copy()
        e[0] = naive_flip_diff(prev[0], e[0])
        e[1] = naive_flip_diff(prev[1], e[1])
        e[2] = naive_flip_diff(prev[2], e[2])
        fe = flip_euler(e, rotation_mode)
        fe[0] = naive_flip_diff(prev[0], fe[0])
        fe[1] = naive_flip_diff(prev[1], fe[1])
        fe[2] = naive_flip_diff(prev[2], fe[2])
        de = euler_distance(prev, e)
        dfe = euler_distance(prev, fe)
        if dfe < de:
            e = fe
        prev = e
        ret.append({"key": kfs[i]["key"], "rotation_euler": e})
    return ret

# --- BLENDER ANIMATION HELPERS ---

def get_fcu_keyframe_numbers(fcu):
    return sorted([p.co[0] for p in fcu.keyframe_points])

def get_selected_fcu_keyframe_numbers(fcu):
    return sorted([p.co[0] for p in fcu.keyframe_points if p.select_control_point])

def split_data_path(data_path):
    return data_path.rsplit(".", 1)

def get_bone_from_fcurve(obj, fcurve):
    bone_path, _ = split_data_path(fcurve.data_path)
    try:
        return obj.path_resolve(bone_path)
    except (AttributeError, ValueError):
        return obj

def get_selected_rotation_fcurves(context):
    obj = context.active_object
    if not obj:
        return None, "No object selected"
    if not obj.animation_data:
        return None, "Object has no animation data"
    if not obj.animation_data.action:
        return None, "Object has no action"
    fcurves = obj.animation_data.action.fcurves

    selected_fcurves = []
    selected_bone = None

    for fc in fcurves:
        if not fc.select:
            continue
        bone, prop = split_data_path(fc.data_path)
        if prop != "rotation_euler":
            continue
        if selected_bone is None:
            selected_bone = bone
        if bone != selected_bone:
            return None, "Only select the rotation of a single object/bone"
        selected_fcurves.append(fc)

    if len(selected_fcurves) != 3:
        return None, "Select exactly XYZ rotation curves"
    selected_fcurves = sorted(selected_fcurves, key=lambda fcu: fcu.array_index)
    for i in range(3):
        if selected_fcurves[i].array_index != i:
            return None, "XYZ rotation curves must cover all three axes"

    return selected_fcurves, None

def get_selected_rotation_keyframes(context):
    fcurves, error = get_selected_rotation_fcurves(context)
    if not fcurves or len(fcurves) != 3:
        return None, None, error
    kf_lists = [get_selected_fcu_keyframe_numbers(fcu) for fcu in fcurves]
    if not (kf_lists[0] == kf_lists[1] == kf_lists[2]):
        return None, None, "All 3 rotation angles must be keyed at the same frames"
    keyframes = kf_lists[0]
    res = []
    for keyframe in keyframes:
        euler = Euler([fcurves[i].evaluate(keyframe) for i in range(3)], 'XYZ')
        res.append({"key": keyframe, "rotation_euler": euler.copy()})
    return res, fcurves, None

# --- ADDON OPERATOR ---

class GRAPH_OT_EulerFilter(bpy.types.Operator):
    bl_idname = "graph.euler_filter"
    bl_label = "Euler Filter"
    bl_description = "Filter selected Euler rotation keyframes to avoid gimbal flip"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        if context and context.active_object:
            fcus, _ = get_selected_rotation_fcurves(context)
            return (fcus is not None)
        return False

    def execute(self, context):
        kfs, fcus, error = get_selected_rotation_keyframes(context)
        if not kfs:
            self.report({'ERROR'}, error)
            return {'CANCELLED'}

        bone_or_obj = get_bone_from_fcurve(context.active_object, fcus[0])
        rotation_mode = getattr(bone_or_obj, "rotation_mode", "XYZ")
        efs = euler_filter(kfs, rotation_mode)

        for i in range(3):
            fcu = fcus[i]
            for eff in efs:
                fcu.keyframe_points.insert(frame=eff["key"], value=eff["rotation_euler"][i], options={'REPLACE'})
        # Redraw the editor
        for area in context.screen.areas:
            if area.type == 'GRAPH_EDITOR':
                area.tag_redraw()

        self.report({'INFO'}, "Euler filtering applied")
        return {'FINISHED'}

# --- PANEL INTEGRATION (Graph Editor Sidebar) ---

class GRAPH_PT_EulerFilterPanel(bpy.types.Panel):
    bl_label = "Euler Filter"
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = "Tool"

    def draw(self, context):
        col = self.layout.column()
        col.operator(GRAPH_OT_EulerFilter.bl_idname, text="Run Euler Filter", icon='MOD_SMOOTH')

# --- REGISTRATION ---

classes = (
    GRAPH_OT_EulerFilter,
    GRAPH_PT_EulerFilterPanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

if __name__ == "__main__":
    register()
