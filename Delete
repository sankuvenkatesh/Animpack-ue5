bl_info = {
    "name": "Delete/Bake Keyframe by Interval Extended",
    "author": "Venkatesh Sanku",
    "version": (4, 6, 0),
    "blender": (5, 0, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete/bake keyframes by interval - POSE BONES FIXED",
    "category": "Animation",
}

import bpy

class DeleteKeyframeProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=0, min=0,
        update=lambda self, context: self.update_preview()
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=100, min=0,
        update=lambda self, context: self.update_preview()
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=1, min=1, max=100,
        update=lambda self, context: self.update_preview()
    )
    invert: bpy.props.BoolProperty(
        name="Invert",
        default=False,
        description="OFF: delete every nth frame. ON: Delete all other frames instead",
        update=lambda self, context: self.update_preview()
    )
    all_types: bpy.props.BoolProperty(
        name="ALL Properties", default=True,
        update=lambda self, context: self._update_all_types()
    )
    only_selected: bpy.props.BoolProperty(
        name="Only Selected", default=False,
        update=lambda self, context: self.update_preview()
    )
    pos: bpy.props.BoolProperty(name="Location", default=True)
    rot: bpy.props.BoolProperty(name="Rotation", default=True)
    scl: bpy.props.BoolProperty(name="Scale", default=True)
    custom: bpy.props.BoolProperty(name="Custom Props", default=True)
    preview_count: bpy.props.IntProperty(default=0, options={'HIDDEN'})

    def update_preview(self):
        frames = calculate_frames(self)
        self.preview_count = len(frames)

    def _update_all_types(self):
        if self.all_types:
            self.pos = self.rot = self.scl = self.custom = True

def calculate_frames(props):
    """‚úÖ VERIFIED: Frame logic works correctly"""
    start, end, interval, invert = props.start_frame, props.end_frame, props.interval, props.invert
    
    if end < start or interval < 1:
        return []
    
    all_frames = list(range(start, end + 1))
    interval_frames = [all_frames[i] for i in range(len(all_frames)) if i % interval == 0]
    
    if invert:
        result = [f for f in all_frames if f not in interval_frames]
    else:
        result = interval_frames
    
    return result

def get_targets(context, only_selected):
    if context.mode == 'POSE':
        arm = context.object
        if arm and arm.type == 'ARMATURE':
            return list(context.selected_pose_bones) if only_selected else list(arm.pose.bones)
    return list(context.selected_objects) if only_selected else list(context.scene.objects)

def delete_pose_bone_exact(pbone, frames, props):
    """‚úÖ FIXED: Deletes ALL frames on pose bones - not just first frame"""
    deleted = 0
    scene = bpy.context.scene
    
    print(f"üîç Processing POSE bone '{pbone.name}' - {len(frames)} frames: {frames[:5]}{'...' if len(frames)>5 else ''}")
    
    for frame_idx, frame in enumerate(frames):
        scene.frame_set(frame)
        bpy.context.view_layer.update()
        
        frame_deleted = 0
        
        if props.pos or props.all_types:
            for i in range(3):
                try:
                    pbone.keyframe_delete(data_path="location", frame=frame, index=i)
                    deleted += 1
                    frame_deleted += 1
                except RuntimeError:
                    pass
        
        if props.rot or props.all_types:
            if pbone.rotation_mode == 'QUATERNION':
                for i in range(4):
                    try:
                        pbone.keyframe_delete(data_path="rotation_quaternion", frame=frame, index=i)
                        deleted += 1
                        frame_deleted += 1
                    except RuntimeError:
                        pass
            else:
                for i in range(3):
                    try:
                        pbone.keyframe_delete(data_path="rotation_euler", frame=frame, index=i)
                        deleted += 1
                        frame_deleted += 1
                    except RuntimeError:
                        pass
        
        if props.scl or props.all_types:
            for i in range(3):
                try:
                    pbone.keyframe_delete(data_path="scale", frame=frame, index=i)
                    deleted += 1
                    frame_deleted += 1
                except RuntimeError:
                    pass
        
        if frame_deleted > 0:
            print(f"  Frame {frame}: {frame_deleted} keys deleted")
    
    print(f"‚úÖ POSE '{pbone.name}': TOTAL {deleted} keys from {len(frames)} frames")
    return deleted

def delete_object_exact(obj, frames, props):
    """‚úÖ Object deletion (works correctly)"""
    deleted = 0
    for frame in frames:
        if props.pos or props.all_types:
            for i in range(3):
                try:
                    obj.keyframe_delete(data_path="location", frame=frame, index=i)
                    deleted += 1
                except RuntimeError:
                    pass
        
        if props.rot or props.all_types:
            if obj.rotation_mode == 'QUATERNION':
                for i in range(4):
                    try:
                        obj.keyframe_delete(data_path="rotation_quaternion", frame=frame, index=i)
                        deleted += 1
                    except RuntimeError:
                        pass
            else:
                for i in range(3):
                    try:
                        obj.keyframe_delete(data_path="rotation_euler", frame=frame, index=i)
                        deleted += 1
                    except RuntimeError:
                        pass
        
        if props.scl or props.all_types:
            for i in range(3):
                try:
                    obj.keyframe_delete(data_path="scale", frame=frame, index=i)
                    deleted += 1
                except RuntimeError:
                    pass
    
    return deleted

class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)
        targets = get_targets(context, props.only_selected)

        if not frames:
            self.report({'WARNING'}, "No frames to delete!")
            return {'CANCELLED'}
        if not targets:
            self.report({'WARNING'}, f"No targets! ({'Select bones' if context.mode=='POSE' else 'Select objects'})")
            return {'CANCELLED'}

        scene = context.scene
        original_frame = scene.frame_current
        total_deleted = 0
        
        print(f"
üöÄ DELETE MODE: {context.mode}")
        print(f"üìä Targets: {len(targets)} | Frames to delete: {len(frames)}")
        print(f"üîÑ Invert: {'ON' if props.invert else 'OFF'} | Frames: {frames[:10]}{'...' if len(frames)>10 else ''}")

        for target in targets:
            try:
                if context.mode == 'POSE':
                    deleted = delete_pose_bone_exact(target, frames, props)
                else:
                    deleted = delete_object_exact(target, frames, props)
                total_deleted += deleted
            except Exception as e:
                print(f"‚ùå Error {getattr(target, 'name', 'unknown')}: {e}")

        scene.frame_set(original_frame)
        context.view_layer.update()
        
        for area in context.screen.areas:
            if area.type in {'VIEW_3D', 'GRAPH_EDITOR', 'DOPESHEET_EDITOR', 'TIMELINE'}:
                area.tag_redraw()

        self.report({'INFO'}, f"Deleted {total_deleted} keyframes from {len(targets)} targets")
        return {'FINISHED'}

class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)
        targets = get_targets(context, props.only_selected)

        if not frames or not targets:
            self.report({'WARNING'}, "No frames or targets to bake!")
            return {'CANCELLED'}

        scene = context.scene
        original_frame = scene.frame_current
        baked_count = 0

        for target in targets:
            for f in frames:
                scene.frame_set(f)
                context.view_layer.update()
                try:
                    if props.pos or props.all_types:
                        target.keyframe_insert(data_path="location")
                        baked_count += 1
                    if props.rot or props.all_types:
                        rot_path = "rotation_quaternion" if target.rotation_mode == 'QUATERNION' else "rotation_euler"
                        target.keyframe_insert(data_path=rot_path)
                        baked_count += 1
                    if props.scl or props.all_types:
                        target.keyframe_insert(data_path="scale")
                        baked_count += 1
                except:
                    pass

        scene.frame_set(original_frame)
        context.view_layer.update()
        self.report({'INFO'}, f"Baked {baked_count} keyframes")
        return {'FINISHED'}

class DeleteBakeKeyframePanel(bpy.types.Panel):
    bl_label = "Keyframe Interval Tools"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props
        
        # Header with mode indicator
        mode_icon = 'OUTLINER_OB_ARMATURE' if context.mode == 'POSE' else 'OBJECT_DATA'
        mode_text = "Pose Mode" if context.mode == 'POSE' else "Object Mode"
        
        header = layout.box()
        header.label(text=f"Mode: {mode_text}", icon=mode_icon)
        
        # Frame Range Section
        layout.label(text="Frame Range", icon='TIME')
        box = layout.box()
        col = box.column(align=True)
        col.prop(props, "start_frame")
        col.prop(props, "end_frame")
        col.separator(factor=0.5)
        col.prop(props, "interval")
        
        # Invert toggle with visual prominence
        invert_box = layout.box()
        row = invert_box.row(align=True)
        row.prop(props, "invert", toggle=True, icon='ARROW_LEFTRIGHT')
        
        # Target Selection Section
        layout.separator()
        layout.label(text="Target Selection", icon='RESTRICT_SELECT_OFF')
        target_box = layout.box()
        target_box.prop(props, "only_selected", toggle=True)
        
        # Properties Section
        layout.separator()
        layout.label(text="Transform Properties", icon='DRIVER_TRANSFORM')
        prop_box = layout.box()
        prop_box.prop(props, "all_types", toggle=True, icon='CHECKBOX_HLT' if props.all_types else 'CHECKBOX_DEHLT')
        
        # Individual property toggles (disabled when all_types is on)
        col = prop_box.column(align=True)
        col.enabled = not props.all_types
        row = col.row(align=True)
        row.prop(props, "pos", toggle=True, icon='ORIENTATION_GLOBAL')
        row.prop(props, "rot", toggle=True, icon='DRIVER_ROTATIONAL_DIFFERENCE')
        row = col.row(align=True)
        row.prop(props, "scl", toggle=True, icon='FULLSCREEN_ENTER')
        row.prop(props, "custom", toggle=True, icon='PROPERTIES')
        
        # Preview Section
        layout.separator()
        frames = calculate_frames(props)
        invert_text = "Non-Interval Frames" if props.invert else "Interval Frames"
        
        preview_box = layout.box()
        preview_col = preview_box.column(align=True)
        preview_col.label(text="Preview", icon='VIEWZOOM')
        
        info_row = preview_col.row(align=True)
        info_row.alignment = 'CENTER'
        info_row.label(text=f"{invert_text}: {len(frames)} frames")
        
        # Action Buttons
        layout.separator(factor=1.5)
        col = layout.column(align=True)
        col.scale_y = 1.4
        
        # Delete button (warning colors)
        delete_row = col.row(align=True)
        delete_op = delete_row.operator("object.delete_keyframe_by_interval", icon='TRASH', text="Delete Keyframes")
        
        # Bake button 
        bake_row = col.row(align=True)
        bake_op = bake_row.operator("object.bake_keyframe_by_interval", icon='KEYTYPE_JITTER_VEC', text="Bake Keyframes")

classes = (
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    DeleteBakeKeyframePanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DeleteKeyframeProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props

if __name__ == "__main__":
    register()
