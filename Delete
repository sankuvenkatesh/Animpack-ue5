bl_info = {
    "name": "Delete/Bake Keyframe by Interval Extended",
    "author": "Venkatesh Sanku",
    "version": (1, 8, 0),
    "blender": (5, 0, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete/bake keyframes by interval - BLENDER 5.0 POSE BONE FIXED",
    "category": "Animation",
}

import bpy

class DeleteKeyframeProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=0, min=0,
        description="First frame to consider",
        update=lambda self, context: self.update_preview()
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=100, min=0,
        description="Last frame (inclusive)",
        update=lambda self, context: self.update_preview()
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=1, min=1, max=100,
        description="Every nth frame for delete/bake",
        update=lambda self, context: self.update_preview()
    )
    invert: bpy.props.BoolProperty(
        name="Invert", default=False,
        description="Invert: delete/bake at interval instead of skipping",
        update=lambda self, context: self.update_preview()
    )

    all_types: bpy.props.BoolProperty(
        name="ALL (Full Key)", default=True,
        description="Key/delete Location, Rotation, Scale, Custom, and all other keyable properties",
        update=lambda self, context: self._update_all_types()
    )

    only_selected: bpy.props.BoolProperty(
        name="Only Selected Bones/Objects", default=False,
        description="Affect ONLY currently selected bones/objects (ignore others)"
    )

    pos: bpy.props.BoolProperty(
        name="Location", default=True,
        description="Affect Location"
    )
    rot: bpy.props.BoolProperty(
        name="Rotation", default=True,
        description="Affect Rotation"
    )
    scl: bpy.props.BoolProperty(
        name="Scale", default=True,
        description="Affect Scale"
    )
    custom: bpy.props.BoolProperty(
        name="Custom Properties", default=True,
        description="Custom Property keyframes"
    )
    preview_count: bpy.props.IntProperty(
        name="Frames to be affected", default=0, options={'HIDDEN'}
    )

    def update_preview(self):
        frames = calculate_frames(self)
        self.preview_count = len(frames)

    def _update_all_types(self):
        if self.all_types:
            self.pos = True
            self.rot = True
            self.scl = True
            self.custom = True

def calculate_frames(props):
    start, end, interval, invert = props.start_frame, props.end_frame, props.interval, props.invert
    if end < start or interval < 1:
        return []
    all_frames = list(range(start, end + 1))
    select_frames = [f for idx, f in enumerate(all_frames) if (idx % interval) == 0]
    if invert:
        return select_frames
    return [f for f in all_frames if f not in select_frames]

def get_selected_objects_or_bones(context):
    if context.mode == 'POSE':
        arm = context.object
        if arm and arm.type == 'ARMATURE':
            return context.selected_pose_bones
    return context.selected_objects

# ------------- POSE BONE DELETION (DIRECT F-CURVE METHOD) -------------
def delete_keyframes_pose_bone_safe(armature, bone_name, frames, props):
    """Delete pose bone keyframes by directly targeting F-Curves - BLENDER 5.0 SAFE."""
    if not armature.animation_data or not armature.animation_data.action:
        print(f"[DEBUG] No action for bone '{bone_name}'")
        return 0
    
    action = armature.animation_data.action
    frames_set = set(frames)
    deleted = 0
    
    # Bone F-Curve marker: pose.bones["BoneName"].property
    bone_marker = f'pose.bones["{bone_name}"]'
    print(f"[DEBUG] Targeting bone '{bone_name}' F-Curves with marker: {bone_marker}")
    
    # Filter relevant F-Curves based on props
    relevant_fc = []
    for fc in action.fcurves:
        if bone_marker not in fc.data_path:
            continue
        
        # Check property type
        data_path_lower = fc.data_path.lower()
        if (props.all_types or 
            (props.pos and 'location' in data_path_lower) or
            (props.rot and 'rotation' in data_path_lower) or
            (props.scl and 'scale' in data_path_lower) or
            (props.custom and 'custom' in data_path_lower)):
            relevant_fc.append(fc)
    
    print(f"[DEBUG] Found {len(relevant_fc)} relevant F-Curves for bone '{bone_name}'")
    
    # SAFE deletion: collect indices first, then remove in reverse order
    for fc in relevant_fc:
        to_remove_indices = []
        for i, kp in enumerate(fc.keyframe_points):
            if round(kp.co[0]) in frames_set:
                to_remove_indices.append(i)
        
        # Remove in reverse order to avoid index shifting issues
        for i in reversed(to_remove_indices):
            try:
                del fc.keyframe_points[i]
                deleted += 1
            except Exception as e:
                print(f"[DEBUG] Failed to delete keyframe at index {i}: {e}")
    
    if deleted > 0:
        action.update()
        print(f"[DEBUG] ‚úÖ Deleted {deleted} keyframes from bone '{bone_name}'")
    else:
        print(f"[DEBUG] ‚ö†Ô∏è No keyframes found for bone '{bone_name}' on target frames")
    
    return deleted

# ------------- OBJECT DELETION (STANDARD METHOD) -------------
def delete_keyframes_object_safe(obj, frames, props):
    """Delete keyframes from object using keyframe_delete API."""
    if not obj.animation_data or not obj.animation_data.action:
        print(f"[DEBUG] No action for object '{obj.name}'")
        return 0
    
    deleted = 0
    frames_set = set(frames)
    print(f"[DEBUG] Processing object '{obj.name}', frames: {sorted(list(frames_set)[:5])}...")
    
    # Build data paths based on props
    data_paths = []
    if props.all_types or props.pos:
        data_paths.append("location")
    if props.all_types or props.rot:
        data_paths.extend(["rotation_euler", "rotation_quaternion"])
    if props.all_types or props.scl:
        data_paths.append("scale")
    
    # Delete keyframes safely
    for f in frames_set:
        for data_path in data_paths:
            try:
                obj.keyframe_delete(data_path=data_path, frame=f)
                deleted += 1
            except RuntimeError:
                pass  # No keyframe exists, safe to ignore
    
    if deleted > 0:
        obj.animation_data.action.update()
        print(f"[DEBUG] ‚úÖ Deleted {deleted} keyframes from object '{obj.name}'")
    else:
        print(f"[DEBUG] ‚ö†Ô∏è No keyframes found for object '{obj.name}'")
    
    return deleted

# ------------- OPERATORS -------------

class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)
        targets = get_selected_objects_or_bones(context) if props.only_selected else context.selected_objects

        if not frames:
            self.report({'WARNING'}, "No frames to process!")
            return {'CANCELLED'}
        
        if not targets:
            self.report({'WARNING'}, "No targets selected!")
            return {'CANCELLED'}

        scene = context.scene
        original_frame = scene.frame_current
        deleted_count = 0

        print(f"
[DELETE] ========================================")
        print(f"[DELETE] Starting deletion on {len(frames)} frames for {len(targets)} targets")
        print(f"[DELETE] Mode: {context.mode}")
        print(f"[DELETE] Frames: {sorted(frames[:10])}...")

        for target in targets:
            try:
                # POSE BONE: Use direct F-Curve method
                if context.mode == 'POSE' and hasattr(target, 'id_data') and target.id_data.type == 'ARMATURE':
                    armature = target.id_data
                    bone_name = target.name
                    deleted = delete_keyframes_pose_bone_safe(armature, bone_name, frames, props)
                    deleted_count += deleted
                
                # OBJECT: Use keyframe_delete method
                else:
                    deleted = delete_keyframes_object_safe(target, frames, props)
                    deleted_count += deleted
                
            except Exception as e:
                print(f"[DELETE] ‚ùå Error processing target {getattr(target, 'name', 'unknown')}: {e}")
                import traceback
                traceback.print_exc()
                continue

        # Restore frame and update
        scene.frame_set(original_frame)
        context.view_layer.update()
        
        for area in context.screen.areas:
            if area.type in {'VIEW_3D', 'GRAPH_EDITOR', 'DOPESHEET_EDITOR', 'TIMELINE'}:
                area.tag_redraw()

        mode_text = "pose bones" if context.mode == 'POSE' else "objects"
        print(f"[DELETE] ========================================")
        print(f"[DELETE] ‚úÖ TOTAL DELETED: {deleted_count}
")
        self.report({'INFO'}, f"Deleted {deleted_count} keyframes from {len(frames)} frames ({len(targets)} {mode_text})")
        return {'FINISHED'}

class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)
        targets = get_selected_objects_or_bones(context) if props.only_selected else context.selected_objects

        if not frames:
            self.report({'WARNING'}, "No frames to process!")
            return {'CANCELLED'}
        
        if not targets:
            self.report({'WARNING'}, "No targets selected!")
            return {'CANCELLED'}

        scene = context.scene
        original_frame = scene.frame_current
        baked_count = 0

        print(f"
[BAKE] Starting bake on {len(frames)} frames for {len(targets)} targets")

        for target in targets:
            for f in frames:
                scene.frame_set(f)
                context.view_layer.update()
                try:
                    if props.all_types or props.pos:
                        target.keyframe_insert(data_path="location")
                    if props.all_types or props.rot:
                        rot_mode = getattr(target, 'rotation_mode', 'QUATERNION')
                        if rot_mode == 'QUATERNION':
                            target.keyframe_insert(data_path="rotation_quaternion")
                        else:
                            target.keyframe_insert(data_path="rotation_euler")
                    if props.all_types or props.scl:
                        target.keyframe_insert(data_path="scale")
                    baked_count += 1
                except Exception as e:
                    print(f"[BAKE] Error on {target.name} at frame {f}: {e}")
                    pass

        scene.frame_set(original_frame)
        context.view_layer.update()
        
        for area in context.screen.areas:
            if area.type in {'VIEW_3D', 'GRAPH_EDITOR', 'DOPESHEET_EDITOR', 'TIMELINE'}:
                area.tag_redraw()

        self.report({'INFO'}, f"Baked {baked_count} keyframes on {len(frames)} frames")
        print(f"[BAKE] ‚úÖ TOTAL BAKED: {baked_count}")
        return {'FINISHED'}

class DeleteBakeKeyframePanel(bpy.types.Panel):
    bl_label = "üîß Delete/Bake Keyframe By Interval"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props

        col = layout.column(align=True)
        box = col.box()
        box.prop(props, "start_frame")
        box.prop(props, "end_frame")
        box.prop(props, "interval")
        box.prop(props, "invert")

        box = col.box()
        box.label(text="üéØ Target Selection")
        box.prop(props, "only_selected")
        box.prop(props, "all_types")

        box = col.box()
        box.label(text="‚öôÔ∏è Property Types")
        row1 = box.row(align=True)
        row1.enabled = not props.all_types
        row1.prop(props, "pos")
        row1.prop(props, "rot")

        row2 = box.row(align=True)
        row2.enabled = not props.all_types
        row2.prop(props, "scl")
        row2.prop(props, "custom")

        preview_box = col.box()
        preview_box.scale_y = 1.2
        frames_preview = calculate_frames(props)
        preview_box.label(text=f"üìä Preview: {len(frames_preview)} frames", icon='INFO')

        row = col.row(align=True)
        row.scale_y = 1.5
        row.operator("object.delete_keyframe_by_interval", icon='TRASH', text="üóëÔ∏è Delete")
        row.operator("object.bake_keyframe_by_interval", icon='KEY_HLT', text="üî• Bake")

classes = (
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    DeleteBakeKeyframePanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DeleteKeyframeProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props

if __name__ == "__main__":
    register()
