# -*- coding: utf-8 -*-

bl_info = {
    "name": "Delete Keyframe by Interval",
    "author": "Venkatesh Sanku",
    "version": (1, 1, 2),
    "blender": (2, 80, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete keyframes by interval with selectable types, invert selection, and preview.",
    "category": "Animation",
}

import bpy
from bpy.props import (
    IntProperty, BoolProperty, EnumProperty, PointerProperty
)
from bpy.types import (
    Panel, Operator, PropertyGroup
)

def _enum_has(flag_set, name):
    try:
        return name in flag_set
    except Exception:
        return False

def _update_preview(self, context):
    props = context.scene.delete_keyframe_props
    start = props.start_frame
    end = props.end_frame
    interval = max(1, props.interval)
    invert = props.invert_selection
    if end < start:
        props.preview_count = 0
        return
    count = 0
    for f in range(start, end + 1):
        is_interval = ((f - start) % (interval + 1)) == 0
        if invert != is_interval:
            count += 1
    props.preview_count = count

def is_custom_prop_fcurve(fcurve):
    dp = fcurve.data_path
    return dp.startswith('["') and dp.endswith('"]')

def delete_on_object_at_frame(obj, f, delete_types):
    count = 0
    all_on = _enum_has(delete_types, 'ALL')
    if all_on or _enum_has(delete_types, 'LOC'):
        if obj.keyframe_delete(data_path="location", frame=f):
            count += 1
    if all_on or _enum_has(delete_types, 'ROT'):
        if obj.keyframe_delete(data_path="rotation_euler", frame=f):
            count += 1
        if obj.keyframe_delete(data_path="rotation_quaternion", frame=f):
            count += 1
    if all_on or _enum_has(delete_types, 'SCL'):
        if obj.keyframe_delete(data_path="scale", frame=f):
            count += 1
    if all_on or _enum_has(delete_types, 'CUSTOM'):
        ad = obj.animation_data
        if ad and ad.action:
            for fc in list(ad.action.fcurves):
                if is_custom_prop_fcurve(fc):
                    for kp in list(fc.keyframe_points):
                        if int(round(kp.co[0])) == f:
                            fc.keyframe_points.remove(kp)
                            count += 1
    return count

def delete_on_pbone_at_frame(pbone, f, delete_types):
    count = 0
    all_on = _enum_has(delete_types, 'ALL')
    if all_on or _enum_has(delete_types, 'LOC'):
        if pbone.keyframe_delete(data_path="location", frame=f):
            count += 1
    if all_on or _enum_has(delete_types, 'ROT'):
        if pbone.keyframe_delete(data_path="rotation_euler", frame=f):
            count += 1
        if pbone.keyframe_delete(data_path="rotation_quaternion", frame=f):
            count += 1
    if all_on or _enum_has(delete_types, 'SCL'):
        if pbone.keyframe_delete(data_path="scale", frame=f):
            count += 1
    return count

class DeleteKeyframeProperties(PropertyGroup):
    start_frame: IntProperty(
        name="Start",
        description="First frame in range",
        default=0, min=0,
        update=_update_preview,
    )
    end_frame: IntProperty(
        name="End",
        description="Last frame in range (inclusive)",
        default=100, min=0,
        update=_update_preview,
    )
    interval: IntProperty(
        name="Interval",
        description="Every N+1 frames are kept/deleted depending on invert",
        default=1, min=1, max=500,
        update=_update_preview,
    )
    delete_types: EnumProperty(
        name="Delete Types",
        description="Keyframe data types to delete",
        items=[
            ('LOC', "Location", "Delete location keyframes"),
            ('ROT', "Rotation", "Delete rotation keyframes"),
            ('SCL', "Scale", "Delete scale keyframes"),
            ('CUSTOM', "Custom Properties", "Delete custom property keyframes"),
            ('ALL', "All", "Delete all types"),
        ],
        options={'ENUM_FLAG'},
        default={'ALL'},
    )
    invert_selection: BoolProperty(
        name="Invert",
        description="Delete frames at interval instead of other frames",
        default=False,
        update=_update_preview,
    )
    affect_pose_bones: BoolProperty(
        name="Pose Bones",
        description="Also delete for selected bones in Pose Mode",
        default=True,
    )
    preview_count: IntProperty(
        name="Frames to delete",
        default=0,
        options={'HIDDEN'},
    )

class DeleteKeyframeOperator(Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Execute Deletion"
    bl_description = "Delete keyframes by interval using current settings"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.delete_keyframe_props

        start = props.start_frame
        end = props.end_frame
        if end < start:
            self.report({'ERROR'}, "End must be >= Start")
            return {'CANCELLED'}

        interval = max(1, props.interval)
        invert = props.invert_selection

        frames_to_delete = []
        for f in range(start, end + 1):
            is_interval = ((f - start) % (interval + 1)) == 0
            if invert != is_interval:
                frames_to_delete.append(f)

        targets = list(context.scene.objects)  # always all objects

        if not targets:
            self.report({'WARNING'}, "No objects to process")
            return {'CANCELLED'}

        total_deleted = 0
        for f in frames_to_delete:
            for obj in targets:
                total_deleted += delete_on_object_at_frame(obj, f, props.delete_types)
                if props.affect_pose_bones and obj.type == 'ARMATURE' and obj.mode == 'POSE':
                    for pbone in context.selected_pose_bones:
                        total_deleted += delete_on_pbone_at_frame(pbone, f, props.delete_types)

        props.preview_count = len(frames_to_delete)
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
        self.report({'INFO'}, f"Deleted {len(frames_to_delete)} frames, {total_deleted} keyframe edits")
        return {'FINISHED'}

class DeleteKeyframePanel(Panel):
    bl_label = "Delete Keyframe By Interval"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.delete_keyframe_props

        box = layout.box()
        box.label(text="Frame Range")
        row = box.row(align=True)
        row.prop(props, "start_frame")
        row.prop(props, "end_frame")
        box.prop(props, "interval")

        box.separator()
        box.label(text="Delete Types")
        # Draw exactly once, no manual loop to avoid duplication
        box.prop(props, "delete_types", text="", expand=True)

        box.separator()
        row = box.row(align=True)
        row.prop(props, "invert_selection")
        row.prop(props, "affect_pose_bones")

        layout.separator()
        layout.label(text=f"Preview frames to delete: {props.preview_count}")

        layout.operator("object.delete_keyframe_by_interval", icon='TRASH')

classes = (
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    DeleteKeyframePanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.delete_keyframe_props = PointerProperty(type=DeleteKeyframeProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.delete_keyframe_props

if __name__ == "__main__":
    register()
