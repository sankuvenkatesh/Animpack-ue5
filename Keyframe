bl_info = {
    "name": "Delete/Bake Keyframe by Interval Extended",
    "author": "Venkatesh Sanku",
    "version": (1, 6, 2),
    "blender": (4, 2, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete/bake keyframes by interval with selected-only mode and live UI preview.",
    "category": "Animation",
}

import bpy

class DeleteKeyframeProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=0, min=0,
        description="First frame to consider",
        update=lambda self, context: self.update_preview()
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=100, min=0,
        description="Last frame (inclusive)",
        update=lambda self, context: self.update_preview()
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=1, min=1, max=100,
        description="Every nth frame for delete/bake",
        update=lambda self, context: self.update_preview()
    )
    invert: bpy.props.BoolProperty(
        name="Invert", default=False,
        description="Invert: delete/bake at interval instead of skipping",
        update=lambda self, context: self.update_preview()
    )

    all_types: bpy.props.BoolProperty(
        name="ALL (Full Key)", default=True,
        description="Key/delete Location, Rotation, Scale, Custom, and all other keyable properties",
        update=lambda self, context: self._update_all_types()
    )

    only_selected: bpy.props.BoolProperty(
        name="Only Selected Bones/Objects", default=False,
        description="Affect ONLY currently selected bones/objects (ignore others)"
    )

    pos: bpy.props.BoolProperty(
        name="Location", default=True,
        description="Affect Location"
    )
    rot: bpy.props.BoolProperty(
        name="Rotation", default=True,
        description="Affect Rotation"
    )
    scl: bpy.props.BoolProperty(
        name="Scale", default=True,
        description="Affect Scale"
    )
    custom: bpy.props.BoolProperty(
        name="Custom Properties", default=True,
        description="Affect Custom Property keyframes"
    )
    preview_count: bpy.props.IntProperty(
        name="Frames to be affected", default=0, options={'HIDDEN'}
    )

    def update_preview(self):
        """Live update preview count when frame settings change"""
        frames = calculate_frames(self)
        self.preview_count = len(frames)

    def _update_all_types(self):
        if self.all_types:
            self.pos = True
            self.rot = True
            self.scl = True
            self.custom = True

def calculate_frames(props):
    start, end, interval, invert = props.start_frame, props.end_frame, props.interval, props.invert
    if end < start or interval < 1:
        return []
    all_frames = list(range(start, end + 1))
    select_frames = [f for idx, f in enumerate(all_frames) if (idx % interval) == 0]
    if invert:
        return select_frames
    return [f for f in all_frames if f not in select_frames]

def affect_types(props):
    return dict(
        all=props.all_types,
        only_selected=props.only_selected,
        pos=props.pos,
        rot=props.rot,
        scl=props.scl,
        custom=props.custom,
    )

def get_selected_objects_or_bones(context):
    """Return selected objects or selected pose bones based on context"""
    if context.mode == 'POSE':
        armature = context.object
        if armature and armature.type == 'ARMATURE':
            return context.selected_pose_bones
    return context.selected_objects

def get_animation_data(obj_or_bone):
    """Safe animation data retrieval for Blender 5.0"""
    if hasattr(obj_or_bone, 'id_data'):
        return obj_or_bone.id_data.animation_data
    return getattr(obj_or_bone, 'animation_data', None)

def delete_all_keyframes_at_frame(obj_or_bone, frame):
    """Delete ALL keyframes at specific frame - FIXED for Blender 5.0"""
    ad = get_animation_data(obj_or_bone)
    if not ad or not ad.action:
        return 0
    
    deleted = 0
    action = ad.action
    
    # Safe fcurves access
    if not hasattr(action, 'fcurves'):
        return 0
    
    for fc in action.fcurves:
        for kp in list(fc.keyframe_points):
            if abs(kp.co[0] - frame) < 0.5:
                fc.keyframe_points.remove(kp)
                deleted += 1
    
    return deleted

def safe_keyframe_delete(target, data_path, frame):
    """Safe keyframe delete for Blender 5.0"""
    try:
        target.keyframe_delete(data_path=data_path, frame=frame, index=-1)
        return True
    except:
        return False

class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_options = {'REGISTER', 'UNDO'}
    bl_description = "Delete keyframes at specified frames for selected objects and bones."

    def execute(self, context):
        props = context.scene.del_keyframe_props
        types = affect_types(props)
        frames = calculate_frames(props)
        targets = get_selected_objects_or_bones(context) if types["only_selected"] else context.selected_objects
        deleted_count = 0

        for target in targets:
            ad = get_animation_data(target)
            
            if ad and ad.action and hasattr(ad.action, 'fcurves'):
                for f in frames:
                    if types["all"]:
                        deleted_count += delete_all_keyframes_at_frame(target, f)
                    else:
                        if types["pos"] and safe_keyframe_delete(target, "location", f):
                            deleted_count += 1
                        if types["rot"]:
                            if safe_keyframe_delete(target, "rotation_euler", f):
                                deleted_count += 1
                            if safe_keyframe_delete(target, "rotation_quaternion", f):
                                deleted_count += 1
                        if types["scl"] and safe_keyframe_delete(target, "scale", f):
                            deleted_count += 1
                        if types["custom"]:
                            for fc in ad.action.fcurves:
                                if fc.data_path.startswith('["') and fc.data_path.endswith('"]'):
                                    for kp in list(fc.keyframe_points):
                                        if abs(kp.co[0] - f) < 0.5:
                                            fc.keyframe_points.remove(kp)
                                            deleted_count += 1

        # Multiple viewport updates for Blender 5.0
        for _ in range(3):
            bpy.context.view_layer.update()
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
        
        mode_text = "pose bones" if context.mode == 'POSE' else "objects"
        self.report({'INFO'}, f"Deleted {deleted_count} keyframes on {len(frames)} frames for {len(targets)} {mode_text}")
        return {'FINISHED'}

class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_options = {'REGISTER', 'UNDO'}
    bl_description = "Bake keyframes at specified frames for selected objects and bones."

    def execute(self, context):
        props = context.scene.del_keyframe_props
        types = affect_types(props)
        frames = calculate_frames(props)
        targets = get_selected_objects_or_bones(context) if types["only_selected"] else context.selected_objects

        scene = context.scene
        original_frame = scene.frame_current
        baked_count = 0

        for target in targets:
            for f in frames:
                scene.frame_set(f)
                bpy.context.view_layer.update()
                
                if types["all"]:
                    if types["pos"]:
                        safe_keyframe_insert(target, "location", f)
                    if types["rot"]:
                        rot_mode = getattr(target, 'rotation_mode', 'QUATERNION')
                        if rot_mode == 'QUATERNION':
                            safe_keyframe_insert(target, "rotation_quaternion", f)
                        else:
                            safe_keyframe_insert(target, "rotation_euler", f)
                    if types["scl"]:
                        safe_keyframe_insert(target, "scale", f)
                    try:
                        for prop_name in target.keys():
                            if not prop_name.startswith('_') and isinstance(target[prop_name], (int, float)):
                                safe_keyframe_insert(target, f'["{prop_name}"]', f)
                    except:
                        pass
                else:
                    if types["pos"]:
                        safe_keyframe_insert(target, "location", f)
                    if types["rot"]:
                        rot_mode = getattr(target, 'rotation_mode', 'QUATERNION')
                        if rot_mode == 'QUATERNION':
                            safe_keyframe_insert(target, "rotation_quaternion", f)
                        else:
                            safe_keyframe_insert(target, "rotation_euler", f)
                    if types["scl"]:
                        safe_keyframe_insert(target, "scale", f)
                    if types["custom"]:
                        try:
                            for prop_name in target.keys():
                                if not prop_name.startswith('_') and isinstance(target[prop_name], (int, float)):
                                    safe_keyframe_insert(target, f'["{prop_name}"]', f)
                        except:
                            pass
                baked_count += 1

        scene.frame_set(original_frame)
        bpy.context.view_layer.update()
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
        
        mode_text = "pose bones" if context.mode == 'POSE' else "objects"
        self.report({'INFO'}, f"Baked {len(frames)} keyframes for {len(targets)} {mode_text}")
        return {'FINISHED'}

def safe_keyframe_insert(target, data_path, frame):
    """Safe keyframe insert for Blender 5.0"""
    try:
        target.keyframe_insert(data_path=data_path, frame=frame, index=-1)
        return True
    except:
        return False

class DeleteBakeKeyframePanel(bpy.types.Panel):
    bl_label = "ðŸ”§ Delete/Bake Keyframe By Interval"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props

        col = layout.column(align=True)
        box = col.box()
        box.prop(props, "start_frame")
        box.prop(props, "end_frame")
        box.prop(props, "interval")
        box.prop(props, "invert")

        box = col.box()
        box.label(text="ðŸŽ¯ Target Selection", icon='OBJECT_DATA')
        box.prop(props, "only_selected")
        box.prop(props, "all_types")

        box = col.box()
        box.label(text="âš™ï¸ Property Types", icon='DRIVER')
        row1 = box.row(align=True)
        row1.enabled = not props.all_types
        row1.prop(props, "pos")
        row1.prop(props, "rot")
        
        row2 = box.row(align=True)
        row2.enabled = not props.all_types
        row2.prop(props, "scl")
        row2.prop(props, "custom")

        preview_box = col.box()
        preview_box.scale_y = 1.2
        frames_preview = calculate_frames(props)
        preview_box.label(text=f"ðŸ“Š Preview: {len(frames_preview)} frames will be affected", icon='INFO')

        row = col.row(align=True)
        row.scale_y = 1.5
        row.operator("object.delete_keyframe_by_interval", icon='TRASH', text="ðŸ—‘ï¸ Delete")
        row.operator("object.bake_keyframe_by_interval", icon='KEY_HLT', text="ðŸ”¥ Bake")

classes = (
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    DeleteBakeKeyframePanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DeleteKeyframeProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props

if __name__ == "__main__":
    register()
