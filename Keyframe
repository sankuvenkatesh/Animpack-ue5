bl_info = {
    "name": "Delete/Bake Keyframe by Interval Extended (Full Animation Cleanup)",
    "author": "Venkatesh Sanku",
    "version": (1, 7, 2),
    "blender": (4, 2, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete keyframes by interval with FULL fcurve cleanup - NO rest pose snapping.",
    "category": "Animation",
}

import bpy

class DeleteKeyframeProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(name="Start Frame", default=0, min=0, update=lambda self, context: self.update_preview())
    end_frame: bpy.props.IntProperty(name="End Frame", default=100, min=0, update=lambda self, context: self.update_preview())
    interval: bpy.props.IntProperty(name="Interval", default=1, min=1, update=lambda self, context: self.update_preview())
    invert: bpy.props.BoolProperty(name="Invert", default=False, update=lambda self, context: self.update_preview())
    only_selected: bpy.props.BoolProperty(name="Only Selected", default=False)
    all_types: bpy.props.BoolProperty(name="ALL Properties", default=True, update=lambda self, context: self._update_all())
    preview_count: bpy.props.IntProperty(default=0, options={'HIDDEN'})

    def update_preview(self):
        self.preview_count = len(calculate_frames(self))

    def _update_all(self):
        if self.all_types:
            pass  # Simplified for fcurve approach

def calculate_frames(props):
    if props.end_frame < props.start_frame or props.interval < 1:
        return []
    all_frames = list(range(props.start_frame, props.end_frame + 1))
    selected = [f for i, f in enumerate(all_frames) if (i % props.interval) == 0]
    return selected if props.invert else [f for f in all_frames if f not in selected]

def get_pose_bone_targets(context):
    """Get selected pose bones - FIXED for only_selected"""
    if (context.mode == 'POSE' and 
        context.object and 
        context.object.type == 'ARMATURE'):
        armature = context.object
        props = context.scene.del_keyframe_props
        if props.only_selected:
            # Only selected pose bones
            selected_bones = [pb for pb in armature.pose.bones if pb.bone.select]
            return selected_bones if selected_bones else []
        else:
            # All pose bones in the armature
            return list(armature.pose.bones)
    return []

def get_object_targets(context):
    """Get selected objects - FIXED for only_selected"""
    props = context.scene.del_keyframe_props
    if props.only_selected:
        objs = [obj for obj in context.selected_objects if hasattr(obj, 'animation_data') and obj.animation_data]
        return objs if objs else []
    else:
        # All objects with animation data in the scene
        objs = [obj for obj in context.scene.objects 
                if hasattr(obj, 'animation_data') and obj.animation_data]
        return objs if objs else []

def delete_keyframes_fcure_range(obj, start_frame, end_frame, frames_to_delete):
    """
    FULL CLEANUP: Delete keyframes by frame interval using F-Curves
    Removes actual keyframe points from animation curves
    """
    if not hasattr(obj, 'animation_data') or not obj.animation_data or not obj.animation_data.action:
        return 0
    
    action = obj.animation_data.action
    deleted_count = 0
    
    # Animation properties to target
    anim_properties = [
        "location",
        "rotation_euler", 
        "rotation_quaternion",
        "scale"
    ]
    
    for fcurve in action.fcurves:
        # Only target relevant fcurves
        if any(prop in fcurve.data_path for prop in anim_properties):
            keyframe_points = fcurve.keyframe_points
            
            # Delete keyframes at specific frames
            for frame in frames_to_delete:
                for i, kp in enumerate(keyframe_points):
                    if abs(kp.co.x - frame) < 0.1:  # Frame tolerance
                        keyframe_points.remove(kp)
                        deleted_count += 1
                        break
    
    return deleted_count

def delete_keyframes_pose_bone_fcure(pose_bone, start_frame, end_frame, frames_to_delete):
    """Delete keyframes for pose bone using armature's fcurves"""
    armature = pose_bone.id_data
    return delete_keyframes_fcure_range(armature, start_frame, end_frame, frames_to_delete)

class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes (Full Cleanup)"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames_to_delete = calculate_frames(props)
        
        if not frames_to_delete:
            self.report({'WARNING'}, "No frames selected for deletion")
            return {'CANCELLED'}
        
        total_deleted = 0
        
        # Get targets FIRST - FIXED selection handling
        pose_bones = get_pose_bone_targets(context)
        objects = get_object_targets(context)
        
        # FIXED: Robust validation for only_selected
        if props.only_selected:
            if not pose_bones and not objects:
                self.report({'WARNING'}, "No selected objects or pose bones with animation data found")
                return {'CANCELLED'}
        else:
            if not pose_bones and not objects:
                self.report({'WARNING'}, "No objects or pose bones with animation data found")
                return {'CANCELLED'}
        
        # Process pose bones if any
        if pose_bones:
            print(f"ðŸ¦´ Processing {len(pose_bones)} pose bones...")
            for pb in pose_bones:
                deleted = delete_keyframes_pose_bone_fcure(pb, props.start_frame, props.end_frame, frames_to_delete)
                total_deleted += deleted
                print(f"  Bone '{pb.name}': deleted {deleted} keyframes")
        
        # Process objects if any
        if objects:
            print(f"ðŸ“¦ Processing {len(objects)} objects...")
            for obj in objects:
                deleted = delete_keyframes_fcure_range(obj, props.start_frame, props.end_frame, frames_to_delete)
                total_deleted += deleted
                print(f"  Object '{obj.name}': deleted {deleted} keyframes")
        
        # CRITICAL: Full refresh after deletion
        context.view_layer.update()
        if context.mode == 'POSE':
            bpy.ops.pose.transforms_clear()
        bpy.context.view_layer.depsgraph.update()
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
        
        targets_count = len(pose_bones) + len(objects)
        mode = "pose bones" if pose_bones else "objects"
        if pose_bones and objects:
            mode = "pose bones & objects"
        self.report({'INFO'}, f"âœ… Deleted {total_deleted} keyframes from {targets_count} {mode}")
        return {'FINISHED'}

class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames_to_bake = calculate_frames(props)
        
        if not frames_to_bake:
            self.report({'WARNING'}, "No frames selected for baking")
            return {'CANCELLED'}
        
        scene = context.scene
        original_frame = scene.frame_current
        baked_count = 0
        
        # FIXED: Get targets with proper validation
        pose_bones = get_pose_bone_targets(context)
        objects = get_object_targets(context)
        
        # FIXED: Robust validation for only_selected
        if props.only_selected:
            if not pose_bones and not objects:
                self.report({'WARNING'}, "No selected objects or pose bones found for baking")
                return {'CANCELLED'}
        else:
            if not pose_bones and not objects:
                self.report({'WARNING'}, "No objects or pose bones with animation data found for baking")
                return {'CANCELLED'}
        
        for frame in frames_to_bake:
            scene.frame_set(frame)
            context.view_layer.update()
            
            # Bake pose bones
            for pb in pose_bones:
                armature = pb.id_data
                armature.pose.bones[pb.name].keyframe_insert(data_path="location", frame=frame)
                armature.pose.bones[pb.name].keyframe_insert(data_path="rotation_quaternion", frame=frame)
                armature.pose.bones[pb.name].keyframe_insert(data_path="scale", frame=frame)
                baked_count += 3
            
            # Bake objects
            for obj in objects:
                obj.keyframe_insert(data_path="location", frame=frame)
                obj.keyframe_insert(data_path="rotation_quaternion", frame=frame)
                obj.keyframe_insert(data_path="scale", frame=frame)
                baked_count += 3
        
        scene.frame_set(original_frame)
        context.view_layer.update()
        context.view_layer.depsgraph.update()
        
        self.report({'INFO'}, f"âœ… Baked {baked_count} keyframes")
        return {'FINISHED'}

class DeleteBakeKeyframePanel(bpy.types.Panel):
    bl_label = "ðŸ—‘ï¸ Delete/Bake Keyframes"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props
        
        # Frame range
        col = layout.column(align=True)
        col.prop(props, "start_frame")
        col.prop(props, "end_frame")
        col.prop(props, "interval")
        col.prop(props, "invert")
        
        # Selection mode
        layout.separator()
        layout.prop(props, "only_selected")
        layout.label(text=f"Preview: {props.preview_count} frames")
        
        # Status info
        pose_bones = get_pose_bone_targets(context)
        objects = get_object_targets(context)
        if props.only_selected:
            layout.label(text=f"Targets: {len(pose_bones)} bones, {len(objects)} objects")
        else:
            layout.label(text=f"Total: {len(pose_bones)} bones, {len(objects)} objects")
        
        # Buttons
        row = layout.row(align=True)
        row.scale_y = 1.4
        row.operator("object.delete_keyframe_by_interval", icon='TRASH')
        row.operator("object.bake_keyframe_by_interval", icon='KEY_HLT')

classes = (
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    DeleteBakeKeyframePanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DeleteKeyframeProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props

if __name__ == "__main__":
    register()
