bl_info = {
    "name": "Delete/Bake Keyframe by Interval Extended (Pose Mode Optimized)",
    "author": "Venkatesh Sanku",
    "version": (1, 7, 0),
    "blender": (4, 2, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete/bake keyframes by interval with selected-only mode and live UI preview, optimized for pose mode.",
    "category": "Animation",
}

import bpy

class DeleteKeyframeProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=0, min=0,
        description="First frame to consider",
        update=lambda self, context: self.update_preview()
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=100, min=0,
        description="Last frame (inclusive)",
        update=lambda self, context: self.update_preview()
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=1, min=1,
        description="Every nth frame for delete/bake",
        update=lambda self, context: self.update_preview()
    )
    invert: bpy.props.BoolProperty(
        name="Invert", default=False,
        description="Invert: delete/bake at interval instead of skipping",
        update=lambda self, context: self.update_preview()
    )

    all_types: bpy.props.BoolProperty(
        name="ALL (Full Key)", default=True,
        description="Key/delete Location, Rotation, Scale, Custom properties",
        update=lambda self, context: self._update_all_types()
    )

    only_selected: bpy.props.BoolProperty(
        name="Only Selected Bones/Objects", default=False,
        description="Affect only selected bones/objects"
    )

    pos: bpy.props.BoolProperty(name="Location", default=True)
    rot: bpy.props.BoolProperty(name="Rotation", default=True)
    scl: bpy.props.BoolProperty(name="Scale", default=True)
    custom: bpy.props.BoolProperty(name="Custom Properties", default=True)

    preview_count: bpy.props.IntProperty(default=0, options={'HIDDEN'})

    def update_preview(self):
        frames = calculate_frames(self)
        self.preview_count = len(frames)

    def _update_all_types(self):
        if self.all_types:
            self.pos = self.rot = self.scl = self.custom = True

def calculate_frames(props):
    if props.end_frame < props.start_frame or props.interval < 1:
        return []
    all_frames = list(range(props.start_frame, props.end_frame + 1))
    selected = [f for i, f in enumerate(all_frames) if (i % props.interval) == 0]
    if props.invert:
        return selected
    return [f for f in all_frames if f not in selected]

def get_targets(context, only_selected):
    if context.mode == 'POSE' and context.object and context.object.type == 'ARMATURE':
        bones = context.object.pose.bones
        if only_selected:
            return [pb for pb in bones if pb.bone.select]
        return list(bones)
    else:
        if only_selected:
            return context.selected_objects
        return context.scene.objects

def delete_keyframes_pose_bone(pb, frame, props):
    deleted = 0
    try:
        if props.all_types or props.pos:
            pb.keyframe_delete(data_path="location", frame=frame)
            deleted +=1
        if props.all_types or props.rot:
            if pb.rotation_mode == 'QUATERNION':
                pb.keyframe_delete(data_path="rotation_quaternion", frame=frame)
            else:
                pb.keyframe_delete(data_path="rotation_euler", frame=frame)
            deleted +=1
        if props.all_types or props.scl:
            pb.keyframe_delete(data_path="scale", frame=frame)
            deleted +=1
        # Custom Properties could be added here if needed
    except Exception as e:
        print(f"Delete error PoseBone: {e}")
    return deleted

def delete_keyframes_object(obj, frame, props):
    deleted = 0
    try:
        if props.all_types or props.pos:
            obj.keyframe_delete(data_path="location", frame=frame)
            deleted +=1
        if props.all_types or props.rot:
            if obj.rotation_mode == 'QUATERNION':
                obj.keyframe_delete(data_path="rotation_quaternion", frame=frame)
            else:
                obj.keyframe_delete(data_path="rotation_euler", frame=frame)
            deleted +=1
        if props.all_types or props.scl:
            obj.keyframe_delete(data_path="scale", frame=frame)
            deleted +=1
    except Exception as e:
        print(f"Delete error Object: {e}")
    return deleted

def bake_keyframes_pose_bone(pb, frame, props):
    baked = 0
    try:
        if props.all_types or props.pos:
            pb.keyframe_insert(data_path="location", frame=frame)
            baked +=1
        if props.all_types or props.rot:
            if pb.rotation_mode == 'QUATERNION':
                pb.keyframe_insert(data_path="rotation_quaternion", frame=frame)
            else:
                pb.keyframe_insert(data_path="rotation_euler", frame=frame)
            baked +=1
        if props.all_types or props.scl:
            pb.keyframe_insert(data_path="scale", frame=frame)
            baked +=1
    except Exception as e:
        print(f"Bake error PoseBone: {e}")
    return baked

def bake_keyframes_object(obj, frame, props):
    baked = 0
    try:
        if props.all_types or props.pos:
            obj.keyframe_insert(data_path="location", frame=frame)
            baked += 1
        if props.all_types or props.rot:
            if obj.rotation_mode == 'QUATERNION':
                obj.keyframe_insert(data_path="rotation_quaternion", frame=frame)
            else:
                obj.keyframe_insert(data_path="rotation_euler", frame=frame)
            baked += 1
        if props.all_types or props.scl:
            obj.keyframe_insert(data_path="scale", frame=frame)
            baked += 1
    except Exception as e:
        print(f"Bake error Object: {e}")
    return baked

class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes by Interval"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)
        targets = get_targets(context, props.only_selected)

        deleted_total = 0
        for target in targets:
            for frame in frames:
                if context.mode == 'POSE' and hasattr(target, 'bone'):
                    deleted_total += delete_keyframes_pose_bone(target, frame, props)
                else:
                    deleted_total += delete_keyframes_object(target, frame, props)

        context.view_layer.update()
        if context.mode == 'POSE':
            bpy.ops.pose.transforms_clear()
        context.view_layer.depsgraph.update()

        self.report({'INFO'}, f"Deleted {deleted_total} keyframes from {len(targets)} targets.")
        return {'FINISHED'}

class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes by Interval"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)
        targets = get_targets(context, props.only_selected)

        scene = context.scene
        original_frame = scene.frame_current
        baked_total = 0

        for target in targets:
            for frame in frames:
                scene.frame_set(frame)
                context.view_layer.update()
                if context.mode == 'POSE' and hasattr(target, 'bone'):
                    baked_total += bake_keyframes_pose_bone(target, frame, props)
                else:
                    baked_total += bake_keyframes_object(target, frame, props)

        scene.frame_set(original_frame)
        context.view_layer.update()
        context.view_layer.depsgraph.update()

        self.report({'INFO'}, f"Baked {baked_total} keyframes on {len(targets)} targets.")
        return {'FINISHED'}

class DeleteBakeKeyframePanel(bpy.types.Panel):
    bl_label = "Delete/Bake Keyframe By Interval"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props

        layout.prop(props, "start_frame")
        layout.prop(props, "end_frame")
        layout.prop(props, "interval")
        layout.prop(props, "invert")

        layout.label(text="Target Selection:")
        layout.prop(props, "only_selected")
        layout.prop(props, "all_types")

        row = layout.row()
        row.enabled = not props.all_types
        row.prop(props, "pos")
        row.prop(props, "rot")
        row = layout.row()
        row.enabled = not props.all_types
        row.prop(props, "scl")
        row.prop(props, "custom")

        layout.label(text=f"Frames affected: {props.preview_count}")

        row = layout.row(align=True)
        row.operator("object.delete_keyframe_by_interval", icon='TRASH', text="Delete")
        row.operator("object.bake_keyframe_by_interval", icon='KEY_HLT', text="Bake")

classes = (
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    DeleteBakeKeyframePanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DeleteKeyframeProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props

if __name__ == "__main__":
    register()
