# -*- coding: utf-8 -*-

# ##### BEGIN GPL LICENSE BLOCK #####
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
# ##### END GPL LICENSE BLOCK #####

bl_info = {
    "name": "Delete Keyframe by Interval",
    "author": "Venkatesh Sanku",
    "version": (1, 0, 4),
    "blender": (2, 80, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete keyframes by interval with selectable types, invert selection, and preview.",
    "warning": "",
    "category": "Animation",
}

import bpy
from bpy.props import (
    IntProperty, BoolProperty, EnumProperty, PointerProperty
)
from bpy.types import (
    Panel, Operator, PropertyGroup
)


def _update_preview(self, context):
    props = context.scene.delete_keyframe_props
    start = props.start_frame
    end = props.end_frame
    interval = max(1, props.interval)
    invert = props.invert_selection

    if end < start:
        props.preview_count = 0
        return

    frames_to_delete = 0
    for f in range(start, end + 1):
        is_interval_frame = ((f - start) % (interval + 1)) == 0
        if invert != is_interval_frame:
            frames_to_delete += 1

    props.preview_count = frames_to_delete


class DeleteKeyframeProperties(PropertyGroup):
    start_frame: IntProperty(
        name="Start Frame",
        description="First frame in range",
        default=0, min=0,
        update=_update_preview,
    )
    end_frame: IntProperty(
        name="End Frame",
        description="Last frame in range (inclusive)",
        default=100, min=0,
        update=_update_preview,
    )
    interval: IntProperty(
        name="Interval",
        description="Every N+1 frames are kept/deleted based on invert",
        default=1, min=1, max=500,
        update=_update_preview,
    )
    delete_types: EnumProperty(
        name="Delete Types",
        description="Select keyframe data types to delete",
        items=[
            ('LOC', "Location", "Delete location keyframes"),
            ('ROT', "Rotation", "Delete rotation keyframes"),
            ('SCL', "Scale", "Delete scale keyframes"),
            ('CUSTOM', "Custom Properties", "Delete custom property keyframes"),
            ('ALL', "All", "Delete all types"),
        ],
        options={'ENUM_FLAG'},
        default={'ALL'},
    )
    invert_selection: BoolProperty(
        name="Invert Selection",
        description="Delete frames at interval instead of deleting frames NOT at interval",
        default=False,
        update=_update_preview,
    )
    affect_pose_bones: BoolProperty(
        name="Affect Pose Bones",
        description="Also delete on selected pose bones when in Pose Mode",
        default=True,
    )
    only_selected_objects: BoolProperty(
        name="Selected Objects Only",
        description="Operate only on selected objects",
        default=True,
    )
    preview_count: IntProperty(
        name="Frames To Delete",
        description="Preview count of frames that will be deleted",
        default=0,
        options={'HIDDEN'},
    )


def is_custom_prop_fcurve(fcurve):
    dp = fcurve.data_path
    return dp.startswith('["') and dp.endswith('"]')


def delete_on_object_at_frame(obj, f, delete_types):
    count = 0
    if 'ALL' in delete_types or 'LOC' in delete_types:
        if obj.keyframe_delete(data_path="location", frame=f):
            count += 1
    if 'ALL' in delete_types or 'ROT' in delete_types:
        if obj.keyframe_delete(data_path="rotation_euler", frame=f):
            count += 1
        if obj.keyframe_delete(data_path="rotation_quaternion", frame=f):
            count += 1
    if 'ALL' in delete_types or 'SCL' in delete_types:
        if obj.keyframe_delete(data_path="scale", frame=f):
            count += 1
    if 'ALL' in delete_types or 'CUSTOM' in delete_types:
        ad = obj.animation_data
        if ad and ad.action:
            for fc in list(ad.action.fcurves):
                if is_custom_prop_fcurve(fc):
                    for kp in list(fc.keyframe_points):
                        if int(round(kp.co[0])) == f:
                            fc.keyframe_points.remove(kp)
                            count += 1
    return count


def delete_on_pbone_at_frame(pbone, f, delete_types):
    count = 0
    if 'ALL' in delete_types or 'LOC' in delete_types:
        if pbone.keyframe_delete(data_path="location", frame=f):
            count += 1
    if 'ALL' in delete_types or 'ROT' in delete_types:
        if pbone.keyframe_delete(data_path="rotation_euler", frame=f):
            count += 1
        if pbone.keyframe_delete(data_path="rotation_quaternion", frame=f):
            count += 1
    if 'ALL' in delete_types or 'SCL' in delete_types:
        if pbone.keyframe_delete(data_path="scale", frame=f):
            count += 1
    return count


class DeleteKeyframeOperator(Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Execute Deletion"
    bl_description = "Delete keyframes by interval with current settings"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.delete_keyframe_props

        start = props.start_frame
        end = props.end_frame
        if end < start:
            self.report({'ERROR'}, "End must be greater than or equal to Start")
            return {'CANCELLED'}

        interval = max(1, props.interval)
        invert = props.invert_selection
        delete_types = props.delete_types

        frames_to_delete = []
        for f in range(start, end + 1):
            is_interval = ((f - start) % (interval + 1)) == 0
            if invert != is_interval:
                frames_to_delete.append(f)

        targets = list(context.selected_objects) if props.only_selected_objects else list(context.scene.objects)

        if not targets:
            self.report({'WARNING'}, "No objects to process")
            return {'CANCELLED'}

        total_deleted = 0
        for f in frames_to_delete:
            for obj in targets:
                total_deleted += delete_on_object_at_frame(obj, f, delete_types)
                if props.affect_pose_bones and obj.type == 'ARMATURE' and obj.mode == 'POSE':
                    for pbone in context.selected_pose_bones:
                        total_deleted += delete_on_pbone_at_frame(pbone, f, delete_types)

        context.scene.delete_keyframe_props.preview_count = len(frames_to_delete)
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

        self.report({'INFO'}, f"Frames deleted: {len(frames_to_delete)} | Key edits: {total_deleted}")
        return {'FINISHED'}


class DeleteKeyframePanel(Panel):
    bl_label = "Delete Keyframe By Interval"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.delete_keyframe_props

        col = layout.column(align=True)
        col.label(text="Frame Range")
        row = col.row(align=True)
        row.prop(props, "start_frame")
        row.prop(props, "end_frame")
        col.prop(props, "interval")

        col.separator()
        col.label(text="Delete Types")

        # Robust label-visible checkboxes: draw enum items manually
        enum_prop = props.bl_rna.properties['delete_types']
        enum_items = enum_prop.enum_items
        grid = col.grid_flow(columns=2, row_major=True, even_columns=True, even_rows=True, align=True)
        for item in enum_items:
            # item.identifier is 'LOC', 'ROT', etc.; item.name is the label
            grid.prop(props, "delete_types", text=item.name, toggle=True, expand=False, index=item.value)

        col.separator()
        row = col.row(align=True)
        row.prop(props, "invert_selection")
        row.prop(props, "affect_pose_bones")

        col.prop(props, "only_selected_objects")

        col.separator()
        col.label(text=f"Preview frames to delete: {props.preview_count}")

        col.operator("object.delete_keyframe_by_interval", icon='TRASH')


classes = [
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    DeleteKeyframePanel,
]


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    if not hasattr(bpy.types.Scene, "delete_keyframe_props"):
        bpy.types.Scene.delete_keyframe_props = PointerProperty(type=DeleteKeyframeProperties)


def unregister():
    if hasattr(bpy.types.Scene, "delete_keyframe_props"):
        del bpy.types.Scene.delete_keyframe_props
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)


if __name__ == "__main__":
    register()
