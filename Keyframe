bl_info = {
    "name": "Delete/Bake Keyframe by Interval Extended (FIXED Selected Mode)",
    "author": "Venkatesh Sanku",
    "version": (1, 7, 2),
    "blender": (4, 2, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete/bake keyframes by interval with FULL fcurve cleanup + FIXED selected bones/objects.",
    "category": "Animation",
}

import bpy

class DeleteKeyframeProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(name="Start Frame", default=0, min=0, update=lambda self, context: self.update_preview())
    end_frame: bpy.props.IntProperty(name="End Frame", default=100, min=0, update=lambda self, context: self.update_preview())
    interval: bpy.props.IntProperty(name="Interval", default=1, min=1, update=lambda self, context: self.update_preview())
    invert: bpy.props.BoolProperty(name="Invert", default=False, update=lambda self, context: self.update_preview())
    only_selected: bpy.props.BoolProperty(name="Only Selected", default=False)
    preview_count: bpy.props.IntProperty(default=0, options={'HIDDEN'})

    def update_preview(self):
        self.preview_count = len(calculate_frames(self))

def calculate_frames(props):
    if props.end_frame < props.start_frame or props.interval < 1:
        return []
    all_frames = list(range(props.start_frame, props.end_frame + 1))
    selected = [f for i, f in enumerate(all_frames) if (i % props.interval) == 0]
    return selected if props.invert else [f for f in all_frames if f not in selected]

def get_pose_bone_targets(context):
    """FIXED: Proper selected pose bones detection"""
    if context.mode == 'POSE' and context.object and context.object.type == 'ARMATURE':
        armature = context.object
        props = context.scene.del_keyframe_props
        
        if props.only_selected:
            # âœ… CORRECT: Use pose.bone.select for Pose Mode
            return [pb for pb in armature.pose.bones if pb.bone.select]
        return armature.pose.bones
    return []

def get_object_targets(context):
    """Get objects with animation data"""
    props = context.scene.del_keyframe_props
    if props.only_selected:
        return [obj for obj in context.selected_objects if obj.animation_data]
    return [obj for obj in context.scene.objects if obj.animation_data]

def delete_keyframes_fcure_range(obj, bone_name=None, start_frame=None, end_frame=None, frames_to_delete=None):
    """
    FIXED: Handles both objects AND pose bones F-Curves correctly
    """
    if not obj.animation_data or not obj.animation_data.action:
        return 0
    
    action = obj.animation_data.action
    deleted_count = 0
    
    # Target F-Curves based on object type
    if bone_name and "pose.bones" in action.name:  # Pose bone armature
        data_path_pattern = f'pose.bones["{bone_name}"]'
    else:  # Regular object
        data_path_pattern = None
    
    for fcurve in action.fcurves:
        # Filter for specific bone or all object fcurves
        if data_path_pattern:
            if data_path_pattern not in fcurve.data_path:
                continue
        elif not any(prop in fcurve.data_path for prop in ["location", "rotation", "scale"]):
            continue
            
        keyframe_points = fcurve.keyframe_points
        for frame in frames_to_delete:
            for i, kp in enumerate(keyframe_points):
                if abs(kp.co.x - frame) < 0.1:
                    keyframe_points.remove(kp)
                    deleted_count += 1
                    break  # Only delete one per frame per fcurve
    
    return deleted_count

def delete_keyframes_pose_bone_fcure(pose_bone, start_frame, end_frame, frames_to_delete):
    """Delete keyframes for SPECIFIC pose bone"""
    armature = pose_bone.id_data
    return delete_keyframes_fcure_range(armature, pose_bone.name, start_frame, end_frame, frames_to_delete)

class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes (Full Cleanup)"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames_to_delete = calculate_frames(props)
        
        if not frames_to_delete:
            self.report({'WARNING'}, "No frames selected for deletion")
            return {'CANCELLED'}
        
        total_deleted = 0
        processed_count = 0
        
        # Handle Pose Mode - FIXED selected bones
        pose_bones = get_pose_bone_targets(context)
        if pose_bones:
            print(f"ðŸ¦´ Pose Mode: Processing {len(pose_bones)} {'selected' if props.only_selected else 'all'} bones")
            for pb in pose_bones:
                deleted = delete_keyframes_pose_bone_fcure(pb, props.start_frame, props.end_frame, frames_to_delete)
                total_deleted += deleted
                processed_count += 1
                print(f"  Bone '{pb.name}': deleted {deleted} keyframes")
        
        # Handle Object Mode
        objects = get_object_targets(context)
        if objects:
            print(f"ðŸ“¦ Object Mode: Processing {len(objects)} {'selected' if props.only_selected else 'all'} objects")
            for obj in objects:
                deleted = delete_keyframes_fcure_range(obj, None, props.start_frame, props.end_frame, frames_to_delete)
                total_deleted += deleted
                processed_count += 1
                print(f"  Object '{obj.name}': deleted {deleted} keyframes")
        
        # Full refresh
        context.view_layer.update()
        if context.mode == 'POSE':
            bpy.ops.pose.transforms_clear()
        context.view_layer.depsgraph.update()
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
        
        mode = "pose bones" if pose_bones else "objects"
        self.report({'INFO'}, f"âœ… Deleted {total_deleted} keyframes from {processed_count} {mode}")
        return {'FINISHED'}

class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames_to_bake = calculate_frames(props)
        
        if not frames_to_bake:
            self.report({'WARNING'}, "No frames selected for baking")
            return {'CANCELLED'}
        
        scene = context.scene
        original_frame = scene.frame_current
        baked_count = 0
        
        pose_bones = get_pose_bone_targets(context)
        objects = get_object_targets(context)
        
        for frame in frames_to_bake:
            scene.frame_set(frame)
            context.view_layer.update()
            
            for pb in pose_bones:
                pb.keyframe_insert(data_path="location", frame=frame)
                pb.keyframe_insert(data_path="rotation_quaternion", frame=frame)
                pb.keyframe_insert(data_path="scale", frame=frame)
                baked_count += 3
            
            for obj in objects:
                obj.keyframe_insert(data_path="location", frame=frame)
                obj.keyframe_insert(data_path="rotation_quaternion", frame=frame)
                obj.keyframe_insert(data_path="scale", frame=frame)
                baked_count += 3
        
        scene.frame_set(original_frame)
        context.view_layer.update()
        context.view_layer.depsgraph.update()
        
        self.report({'INFO'}, f"âœ… Baked {baked_count} keyframes")
        return {'FINISHED'}

class DeleteBakeKeyframePanel(bpy.types.Panel):
    bl_label = "ðŸ—‘ï¸ Delete/Bake Keyframes"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props
        
        col = layout.column(align=True)
        col.prop(props, "start_frame")
        col.prop(props, "end_frame")
        col.prop(props, "interval")
        col.prop(props, "invert")
        
        layout.separator()
        layout.prop(props, "only_selected")
        layout.label(text=f"Preview: {props.preview_count} frames")
        
        row = layout.row(align=True)
        row.scale_y = 1.4
        row.operator("object.delete_keyframe_by_interval", icon='TRASH', text="Delete")
        row.operator("object.bake_keyframe_by_interval", icon='KEY_HLT', text="Bake")

classes = (
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    DeleteBakeKeyframePanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DeleteKeyframeProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props

if __name__ == "__main__":
    register()
