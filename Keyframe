bl_info = {
    "name": "Delete/Bake Keyframe by Interval Extended",
    "author": "Venkatesh Sanku",
    "version": (1, 6, 12),
    "blender": (4, 2, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete/bake keyframes by interval with selected-only mode and live UI preview.",
    "category": "Animation",
}

import bpy

class DeleteKeyframeProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=0, min=0,
        update=lambda self, context: self.update_preview()
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=100, min=0,
        update=lambda self, context: self.update_preview()
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=1, min=1, max=100,
        update=lambda self, context: self.update_preview()
    )
    invert: bpy.props.BoolProperty(
        name="Invert", default=False,
        update=lambda self, context: self.update_preview()
    )
    all_types: bpy.props.BoolProperty(
        name="ALL (Full Key)", default=True,
        update=lambda self, context: self._update_all_types()
    )
    only_selected: bpy.props.BoolProperty(
        name="Only Selected Bones/Objects", default=False
    )
    pos: bpy.props.BoolProperty(name="Location", default=True)
    rot: bpy.props.BoolProperty(name="Rotation", default=True)
    scl: bpy.props.BoolProperty(name="Scale", default=True)
    preview_count: bpy.props.IntProperty(name="Frames", default=0, options={'HIDDEN'})

    def update_preview(self):
        frames = calculate_frames(self)
        self.preview_count = len(frames)

    def _update_all_types(self):
        if self.all_types:
            self.pos = self.rot = self.scl = True

def calculate_frames(props):
    start, end, interval, invert = props.start_frame, props.end_frame, props.interval, props.invert
    if end < start or interval < 1: return []
    all_frames = list(range(start, end + 1))
    select_frames = [f for idx, f in enumerate(all_frames) if (idx % interval) == 0]
    return select_frames if invert else [f for f in all_frames if f not in select_frames]

def delete_keyframes_interval_simple(targets, frames):
    """SIMPLEST: Use bpy.ops.action.delete() for ALL cases"""
    deleted_count = 0
    
    original_mode = bpy.context.mode
    original_frame = bpy.context.scene.frame_current
    
    # Switch to Graph Editor area temporarily
    for area in bpy.context.screen.areas:
        if area.type == 'VIEW_3D':
            override = area.as_pointer()
            break
    else:
        override = None
    
    for target in targets:
        obj = target.id_data if hasattr(target, 'id_data') else target
        
        if not obj.animation_data or not obj.animation_data.action:
            continue
            
        print(f"ðŸŽ¯ Processing: {obj.name} - Action: {obj.animation_data.action.name}")
        
        # Ensure correct mode for armature
        if obj.type == 'ARMATURE' and original_mode != 'POSE':
            bpy.ops.object.mode_set(mode='POSE')
        
        for frame in frames:
            bpy.context.scene.frame_set(frame)
            bpy.context.view_layer.update()
            
            try:
                # NATIVE Blender operators - bulletproof
                bpy.ops.action.select_all(action='DESELECT')
                bpy.ops.action.select_column(mode='SELECT')
                bpy.ops.action.frames_go_to(frame=frame)
                bpy.ops.action.select_all(action='SELECT')
                bpy.ops.action.delete(confirm=False)
                deleted_count += 1
                print(f"   Frame {frame}: DELETED")
            except Exception as e:
                print(f"   Frame {frame}: {e}")
    
    # Restore state
    bpy.context.scene.frame_set(original_frame)
    if original_mode != bpy.context.mode:
        try:
            bpy.ops.object.mode_set(mode=original_mode)
        except: pass
    
    return deleted_count

class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)
        targets = context.selected_pose_bones if context.mode == 'POSE' and context.object and context.object.type == 'ARMATURE' else context.selected_objects
        
        print(f"ðŸ” MODE: {context.mode}, FRAMES: {frames}, TARGETS: {len(targets)}")
        
        deleted_count = delete_keyframes_interval_simple(targets, frames)
        
        context.view_layer.update()
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=10)
        
        self.report({'INFO'}, f"âœ… DELETED {deleted_count} keyframes ({len(frames)} frames, {len(targets)} targets)")
        return {'FINISHED'}

class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.del_keyframe_props
        frames = calculate_frames(props)
        targets = context.selected_pose_bones if context.mode == 'POSE' and context.object and context.object.type == 'ARMATURE' else context.selected_objects
        scene = context.scene
        original_frame = scene.frame_current
        baked = 0

        for target in targets:
            for f in frames:
                scene.frame_set(f)
                context.view_layer.update()
                try:
                    target.keyframe_insert(data_path="location", frame=f, index=-1)
                    target.keyframe_insert(data_path="rotation_quaternion", frame=f, index=-1)
                    target.keyframe_insert(data_path="scale", frame=f, index=-1)
                    baked += 1
                except: pass

        scene.frame_set(original_frame)
        context.view_layer.update()
        self.report({'INFO'}, f"Baked {baked} keyframes")
        return {'FINISHED'}

class DeleteBakeKeyframePanel(bpy.types.Panel):
    bl_label = "ðŸ”§ Delete/Bake Keyframe"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props

        col = layout.column()
        col.prop(props, "start_frame")
        col.prop(props, "end_frame")
        col.prop(props, "interval")
        col.prop(props, "invert")

        col.prop(props, "only_selected")
        preview_box = col.box()
        frames_preview = calculate_frames(props)
        preview_box.label(text=f"ðŸ“Š {len(frames_preview)} frames", icon='INFO')

        row = col.row()
        row.scale_y = 1.5
        row.operator("object.delete_keyframe_by_interval", icon='TRASH', text="ðŸ—‘ï¸ Delete")
        row.operator("object.bake_keyframe_by_interval", icon='KEY_HLT', text="ðŸ”¥ Bake")

classes = (
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    DeleteBakeKeyframePanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DeleteKeyframeProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props

if __name__ == "__main__":
    register()
