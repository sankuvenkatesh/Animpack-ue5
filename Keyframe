bl_info = {
    "name": "Delete/Bake Keyframe by Interval Extended",
    "author": "Venkatesh Sanku",
    "version": (1, 5, 0),
    "blender": (2, 80, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Delete/bake keyframes by interval with full property support, entire key deletion, and all-property toggle.",
    "category": "Animation",
}

import bpy

class DeleteKeyframeProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start Frame", default=0, min=0,
        description="First frame to consider"
    )
    end_frame: bpy.props.IntProperty(
        name="End Frame", default=100, min=0,
        description="Last frame (inclusive)"
    )
    interval: bpy.props.IntProperty(
        name="Interval", default=1, min=1, max=100,
        description="Every nth frame for delete/bake"
    )
    invert: bpy.props.BoolProperty(
        name="Invert", default=False,
        description="Invert: delete/bake at interval instead of skipping"
    )

    all_types: bpy.props.BoolProperty(
        name="ALL (Full Key)", default=True,
        description="Key/delete Location, Rotation, Scale, Custom, and all other keyable properties",
        update=lambda self, context: self._update_all_types()
    )

    pos: bpy.props.BoolProperty(
        name="Location", default=True,
        description="Affect Location"
    )
    rot: bpy.props.BoolProperty(
        name="Rotation", default=True,
        description="Affect Rotation"
    )
    scl: bpy.props.BoolProperty(
        name="Scale", default=True,
        description="Affect Scale"
    )
    custom: bpy.props.BoolProperty(
        name="Custom Properties", default=True,
        description="Affect Custom Property keyframes"
    )
    preview_count: bpy.props.IntProperty(
        name="Frames to be affected", default=0, options={'HIDDEN'}
    )

    def _update_all_types(self):
        if self.all_types:
            self.pos = True
            self.rot = True
            self.scl = True
            self.custom = True

def calculate_frames(props):
    start, end, interval, invert = props.start_frame, props.end_frame, props.interval, props.invert
    if end < start or interval < 1:
        return []
    all_frames = list(range(start, end + 1))
    select_frames = [f for idx, f in enumerate(all_frames) if (idx % interval) == 0]
    if invert:
        return select_frames
    return [f for f in all_frames if f not in select_frames]

def affect_types(props):
    return dict(
        all=props.all_types,
        pos=props.pos,
        rot=props.rot,
        scl=props.scl,
        custom=props.custom,
    )

def custom_prop_fcurve(fcurve):
    dp = fcurve.data_path
    return dp.startswith('["') and dp.endswith('"]')

class DeleteKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.delete_keyframe_by_interval"
    bl_label = "Delete Keyframes"
    bl_options = {'REGISTER', 'UNDO'}
    bl_description = "Delete entire keyframes at specified frames for selected objects and bones (all properties)."

    def execute(self, context):
        props = context.scene.del_keyframe_props
        types = affect_types(props)
        frames = calculate_frames(props)
        props.preview_count = len(frames)

        for obj in bpy.context.selected_objects:
            ad = obj.animation_data
            if not ad or not ad.action:
                continue

            for frame in frames:
                if types["all"]:
                    # Delete entire keyframe across all fcurves at frame
                    for fc in ad.action.fcurves:
                        for kp in list(fc.keyframe_points):
                            if int(round(kp.co[0])) == frame:
                                fc.keyframe_points.remove(kp)
                else:
                    # Delete selected keyframe types only
                    if types["pos"]:
                        obj.keyframe_delete(data_path="location", frame=frame)
                    if types["rot"]:
                        obj.keyframe_delete(data_path="rotation_euler", frame=frame)
                        obj.keyframe_delete(data_path="rotation_quaternion", frame=frame)
                    if types["scl"]:
                        obj.keyframe_delete(data_path="scale", frame=frame)
                    if types["custom"]:
                        for fc in ad.action.fcurves:
                            if custom_prop_fcurve(fc):
                                for kp in list(fc.keyframe_points):
                                    if int(round(kp.co[0])) == frame:
                                        fc.keyframe_points.remove(kp)

            # Delete keys for pose bones similarly
            if obj.type == 'ARMATURE' and obj.mode == 'POSE':
                for pbn in bpy.context.selected_pose_bones:
                    ad_p = pbn.id_data.animation_data
                    if not ad_p or not ad_p.action:
                        continue

                    for frame in frames:
                        if types["all"]:
                            for fc in ad_p.action.fcurves:
                                for kp in list(fc.keyframe_points):
                                    if int(round(kp.co[0])) == frame:
                                        fc.keyframe_points.remove(kp)
                        else:
                            if types["pos"]:
                                pbn.keyframe_delete(data_path="location", frame=frame)
                            if types["rot"]:
                                pbn.keyframe_delete(data_path="rotation_euler", frame=frame)
                                pbn.keyframe_delete(data_path="rotation_quaternion", frame=frame)
                            if types["scl"]:
                                pbn.keyframe_delete(data_path="scale", frame=frame)
                            if types["custom"]:
                                for fc in ad_p.action.fcurves:
                                    if custom_prop_fcurve(fc):
                                        for kp in list(fc.keyframe_points):
                                            if int(round(kp.co[0])) == frame:
                                                fc.keyframe_points.remove(kp)

        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
        self.report({'INFO'}, f"Deleted {len(frames)} frames, types: " + ", ".join([k for k, v in types.items() if v]))
        return {'FINISHED'}

class BakeKeyframeOperator(bpy.types.Operator):
    bl_idname = "object.bake_keyframe_by_interval"
    bl_label = "Bake Keyframes"
    bl_options = {'REGISTER', 'UNDO'}
    bl_description = "Insert keyframes at specified frames for selected objects and bones (all properties and transforms)."

    def execute(self, context):
        props = context.scene.del_keyframe_props
        types = affect_types(props)
        frames = calculate_frames(props)
        props.preview_count = len(frames)

        scene = context.scene
        original_frame = scene.frame_current

        for obj in bpy.context.selected_objects:
            ad = obj.animation_data
            existing_frames = set()
            if ad and ad.action:
                for fc in ad.action.fcurves:
                    for kp in fc.keyframe_points:
                        frame = int(round(kp.co[0]))
                        existing_frames.add((fc.data_path, frame))

            for f in frames:
                scene.frame_set(f)
                if types["all"]:
                    bpy.ops.object.select_all(action='DESELECT')
                    obj.select_set(True)
                    scene.view_layers[0].objects.active = obj
                    bpy.ops.anim.keyframe_insert(type='LocRotScale', confirm_success=False)
                    for k in obj.keys():
                        if k.startswith("_") or not isinstance(obj[k], (int, float)):
                            continue
                        obj.keyframe_insert(data_path=f'["{k}"]', frame=f)
                else:
                    if types["pos"]:
                        if ("location", f) not in existing_frames:
                            obj.keyframe_insert(data_path="location", frame=f)
                    if types["rot"]:
                        if ("rotation_euler", f) not in existing_frames:
                            obj.keyframe_insert(data_path="rotation_euler", frame=f)
                        if ("rotation_quaternion", f) not in existing_frames:
                            obj.keyframe_insert(data_path="rotation_quaternion", frame=f)
                    if types["scl"]:
                        if ("scale", f) not in existing_frames:
                            obj.keyframe_insert(data_path="scale", frame=f)
                    if types["custom"]:
                        for k in obj.keys():
                            if k.startswith("_") or not isinstance(obj[k], (int, float)):
                                continue
                            path = f'["{k}"]'
                            if (path, f) not in existing_frames:
                                obj.keyframe_insert(data_path=path, frame=f)

            if obj.type == 'ARMATURE' and obj.mode == 'POSE':
                for pbn in bpy.context.selected_pose_bones:
                    ad_p = pbn.id_data.animation_data
                    existing_frames_p = set()
                    if ad_p and ad_p.action:
                        for fc in ad_p.action.fcurves:
                            for kp in fc.keyframe_points:
                                frame = int(round(kp.co[0]))
                                existing_frames_p.add((fc.data_path, frame))

                    for f in frames:
                        scene.frame_set(f)
                        if types["all"]:
                            bpy.ops.pose.select_all(action='DESELECT')
                            pbn.bone.select = True
                            obj.data.bones.active = pbn.bone
                            bpy.ops.anim.keyframe_insert(type='LocRotScale', confirm_success=False)
                            for k in pbn.keys():
                                if k.startswith("_") or not isinstance(pbn[k], (int, float)):
                                    continue
                                path = f'["{k}"]'
                                if (path, f) not in existing_frames_p:
                                    pbn.keyframe_insert(data_path=path, frame=f)
                        else:
                            if types["pos"]:
                                if ("location", f) not in existing_frames_p:
                                    pbn.keyframe_insert(data_path="location", frame=f)
                            if types["rot"]:
                                if ("rotation_euler", f) not in existing_frames_p:
                                    pbn.keyframe_insert(data_path="rotation_euler", frame=f)
                                if ("rotation_quaternion", f) not in existing_frames_p:
                                    pbn.keyframe_insert(data_path="rotation_quaternion", frame=f)
                            if types["scl"]:
                                if ("scale", f) not in existing_frames_p:
                                    pbn.keyframe_insert(data_path="scale", frame=f)
                            if types["custom"]:
                                for k in pbn.keys():
                                    if k.startswith("_") or not isinstance(pbn[k], (int, float)):
                                        continue
                                    path = f'["{k}"]'
                                    if (path, f) not in existing_frames_p:
                                        pbn.keyframe_insert(data_path=path, frame=f)

        scene.frame_set(original_frame)
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
        self.report({'INFO'}, f"Baked {len(frames)} keyframes, types: " + ", ".join([k for k, v in types.items() if v]))
        return {'FINISHED'}

class DeleteBakeKeyframePanel(bpy.types.Panel):
    bl_label = "Delete/Bake Keyframe By Interval"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'
    bl_options = {'DEFAULT_CLOSED'}

    def draw(self, context):
        layout = self.layout
        props = context.scene.del_keyframe_props

        col = layout.column(align=True)
        box = col.box()
        box.label(text="Frame Range and Interval")
        row = box.row(align=True)
        row.prop(props, "start_frame")
        row.prop(props, "end_frame")
        box.prop(props, "interval")
        box.prop(props, "invert")

        box.separator()
        box.label(text="Keyframe Types")
        box.prop(props, "all_types")
        row = box.row(align=True)
        row.enabled = not props.all_types
        row.prop(props, "pos")
        row.prop(props, "rot")
        row2 = box.row(align=True)
        row2.enabled = not props.all_types
        row2.prop(props, "scl")
        row2.prop(props, "custom")

        frames_preview = calculate_frames(props)
        col.label(text=f"Frames: {frames_preview}  |  Count: {len(frames_preview)}")

        row = col.row(align=True)
        row.scale_y = 1.4
        row.operator("object.delete_keyframe_by_interval", icon='TRASH')
        row.operator("object.bake_keyframe_by_interval", icon='KEY_HLT')

classes = (
    DeleteKeyframeProperties,
    DeleteKeyframeOperator,
    BakeKeyframeOperator,
    DeleteBakeKeyframePanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.del_keyframe_props = bpy.props.PointerProperty(type=DeleteKeyframeProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.del_keyframe_props

if __name__ == "__main__":
    register()
