bl_info = {
    "name": "Keyframe Interval Manager",
    "author": "Venkatesh Sanku",
    "version": (1, 6, 0),
    "blender": (2, 80, 0),
    "location": "View3D > Sidebar > Animation",
    "description": "Professional keyframe deletion and baking with live preview and advanced controls.",
    "category": "Animation",
}

import bpy

class DeleteKeyframeProperties(bpy.types.PropertyGroup):
    start_frame: bpy.props.IntProperty(
        name="Start", default=1, min=1,
        description="First frame",
        update=lambda self, context: self.update_preview()
    )
    end_frame: bpy.props.IntProperty(
        name="End", default=250, min=1,
        description="Last frame (inclusive)",
        update=lambda self, context: self.update_preview()
    )
    interval: bpy.props.IntProperty(
        name="Every", default=2, min=1, max=100,
        description="Every nth frame",
        update=lambda self, context: self.update_preview()
    )
    mode: bpy.props.EnumProperty(
        name="Mode",
        items=[
            ('KEEP', "Keep Interval", "Keep keyframes every nth frame, delete others"),
            ('DELETE', "Delete Interval", "Delete keyframes every nth frame, keep others"),
        ],
        default='KEEP',
        update=lambda self, context: self.update_preview()
    )
    
    scope: bpy.props.EnumProperty(
        name="Scope",
        items=[
            ('ALL', "All Objects", "Affect all animated objects"),
            ('SELECTED', "Selected Only", "Only selected objects/bones"),
        ],
        default='ALL'
    )
    
    types: bpy.props.EnumProperty(
        name="Properties",
        items=[
            ('FULL', "All Properties", "Location, Rotation, Scale, Custom Props"),
            ('CUSTOM', "Custom Only", "Choose specific properties below"),
        ],
        default='FULL'
    )
    
    location: bpy.props.BoolProperty(name="Location.XYZ", default=True)
    rotation: bpy.props.BoolProperty(name="Rotation", default=True)
    scale: bpy.props.BoolProperty(name="Scale.XYZ", default=True)
    custom_props: bpy.props.BoolProperty(name="Custom Props", default=True)
    
    preview_count: bpy.props.IntProperty(default=0, options={'HIDDEN'})
    preview_text: bpy.props.StringProperty(default="", options={'HIDDEN'})

    def update_preview(self):
        """Update live preview"""
        frames = calculate_frames(self)
        self.preview_count = len(frames)
        action = "Delete" if self.mode == 'DELETE' else "Keep"
        self.preview_text = f"{action} {len(frames)} keyframes"

def calculate_frames(props):
    start, end, interval = props.start_frame, props.end_frame, props.interval
    if end < start or interval < 1:
        return []
    
    all_frames = list(range(start, end + 1))
    if props.mode == 'DELETE':
        return [f for idx, f in enumerate(all_frames) if (idx % interval) == 0]
    return [f for idx, f in enumerate(all_frames) if (idx % interval) != 0]

def get_targets(context, props):
    """Get targets based on scope"""
    if props.scope == 'SELECTED':
        if context.mode == 'POSE':
            armature = context.object
            if armature and armature.type == 'ARMATURE':
                return context.selected_pose_bones
        return context.selected_objects
    return [obj for obj in context.scene.objects if obj.animation_data]

def delete_keyframes_at_frame(obj_or_bone, frame, full_mode=True):
    """Delete keyframes at frame"""
    ad = (obj_or_bone.id_data.animation_data if hasattr(obj_or_bone, 'id_data') 
          else obj_or_bone.animation_data)
    if not ad or not ad.action:
        return 0
    
    deleted = 0
    for fc in ad.action.fcurves:
        for kp in list(fc.keyframe_points):
            if int(round(kp.co[0])) == frame:
                fc.keyframe_points.remove(kp)
                deleted += 1
    return deleted

class KEYFRAME_OT_delete_interval(bpy.types.Operator):
    bl_idname = "keyframe.delete_interval"
    bl_label = "Delete Interval Keyframes"
    bl_options = {'REGISTER', 'UNDO'}
    bl_description = "Delete keyframes based on interval settings"
    
    def execute(self, context):
        props = context.scene.keyframe_interval_props
        targets = get_targets(context, props)
        total_deleted = 0
        
        for target in targets:
            frames = calculate_frames(props)
            for frame in frames:
                if props.types == 'FULL':
                    total_deleted += delete_keyframes_at_frame(target, frame)
                else:
                    # Custom property deletion
                    ad = target.animation_data
                    if ad and ad.action:
                        for fc in ad.action.fcurves:
                            for kp in list(fc.keyframe_points):
                                if int(round(kp.co[0])) == frame:
                                    fc.keyframe_points.remove(kp)
                                    total_deleted += 1
        
        context.view_layer.update()
        self.report({'INFO'}, f"Deleted {total_deleted} keyframes")
        return {'FINISHED'}

class KEYFRAME_OT_bake_interval(bpy.types.Operator):
    bl_idname = "keyframe.bake_interval"
    bl_label = "Bake Interval Keyframes"
    bl_options = {'REGISTER', 'UNDO'}
    bl_description = "Bake keyframes based on interval settings"
    
    def execute(self, context):
        props = context.scene.keyframe_interval_props
        targets = get_targets(context, props)
        scene = context.scene
        original_frame = scene.frame_current
        baked_count = 0
        
        for target in targets:
            frames = calculate_frames(props)
            for frame in frames:
                scene.frame_set(frame)
                context.view_layer.update()
                
                # Insert keyframes for all properties
                if props.types == 'FULL' or props.location:
                    target.keyframe_insert(data_path="location", frame=frame)
                if props.types == 'FULL' or props.rotation:
                    rot_path = "rotation_quaternion" if target.rotation_mode == 'QUATERNION' else "rotation_euler"
                    target.keyframe_insert(data_path=rot_path, frame=frame)
                if props.types == 'FULL' or props.scale:
                    target.keyframe_insert(data_path="scale", frame=frame)
                
                baked_count += 1
        
        scene.frame_set(original_frame)
        context.view_layer.update()
        self.report({'INFO'}, f"Baked {baked_count} keyframes")
        return {'FINISHED'}

class KEYFRAME_PT_interval_manager(bpy.types.Panel):
    bl_label = "âŒ„ Keyframe Interval"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'
    bl_options = {'DEFAULT_CLOSED'}
    
    def draw(self, context):
        layout = self.layout
        props = context.scene.keyframe_interval_props
        
        # Header
        header = layout.box()
        header_row = header.row(align=True)
        header_row.label(text="ðŸŽ¯ Frame Interval", icon='KEY_HLT')
        header_row.prop(props, "mode", text="", icon_only=True)
        
        # Frame controls
        frame_box = layout.box()
        frame_row = frame_box.row(align=True)
        frame_row.prop(props, "start_frame", text="From")
        frame_row.prop(props, "end_frame", text="To")
        frame_box.prop(props, "interval", text="Every")
        
        # Scope and Types
        scope_box = layout.box()
        scope_row = scope_box.row(align=True)
        scope_row.prop(props, "scope", text="")
        scope_row.prop(props, "types", text="")
        
        # Property checkboxes (disabled when FULL)
        prop_box = layout.box()
        prop_row1 = prop_box.row(align=True)
        prop_row1.enabled = props.types != 'FULL'
        prop_row1.prop(props, "location")
        prop_row1.prop(props, "rotation")
        
        prop_row2 = prop_box.row(align=True)
        prop_row2.enabled = props.types != 'FULL'
        prop_row2.prop(props, "scale")
        prop_row2.prop(props, "custom_props")
        
        # Preview
        preview_box = layout.box()
        preview_row = preview_box.row()
        preview_row.scale_y = 1.2
        preview_row.label(text=props.preview_text, icon='INFO')
        
        # Action buttons
        btn_box = layout.box()
        btn_row = btn_box.row(align=True)
        btn_row.scale_y = 1.6
        delete_btn = btn_row.operator("keyframe.delete_interval", 
                                    text="ðŸ—‘ï¸  Delete", icon='TRASH')
        delete_btn.mode = props.mode
        bake_btn = btn_row.operator("keyframe.bake_interval", 
                                  text="ðŸ”¥ Bake", icon='RENDER_STILL')
        bake_btn.mode = props.mode

classes = (
    DeleteKeyframeProperties,
    KEYFRAME_OT_delete_interval,
    KEYFRAME_OT_bake_interval,
    KEYFRAME_PT_interval_manager,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.keyframe_interval_props = bpy.props.PointerProperty(type=DeleteKeyframeProperties)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.keyframe_interval_props

if __name__ == "__main__":
    register()
