# -*- coding: utf-8 -*-

bl_info = {
    "name": "Anim Tool Transfer",
    "author": "Venkatesh sanku",
    "version": (1, 2, 1),
    "blender": (5, 0, 0),
    "location": "View3D > Sidebar > Anim Tool Transfer",
    "description": (
        "Transfer motion from torso/controllers to root controller, "
        "optionally keeping the character at world origin. Supports batch actions."
    ),
    "category": "Animation",
    "license": "SPDX:GPL-3.0-or-later",
}

import bpy


# ---------------------------------------------------------
# Properties
# ---------------------------------------------------------

class RMT_ControllerItem(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty()


class RMT_ActionItem(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty(name="Action Name")
    action: bpy.props.PointerProperty(type=bpy.types.Action)
    is_selected: bpy.props.BoolProperty(name="Select", default=False)


def get_torso_items(self, context):
    scene = context.scene
    return [(c.name, c.name, "") for c in scene.controllers]


def register_properties():
    bpy.types.Scene.rmt_selected_rig = bpy.props.PointerProperty(
        name="Rig",
        type=bpy.types.Object,
    )

    bpy.types.Scene.controllers = bpy.props.CollectionProperty(type=RMT_ControllerItem)
    bpy.types.Scene.controllers_index = bpy.props.IntProperty()

    bpy.types.Scene.axis_x = bpy.props.BoolProperty(name="X", default=True)
    bpy.types.Scene.axis_y = bpy.props.BoolProperty(name="Y", default=True)
    bpy.types.Scene.axis_z = bpy.props.BoolProperty(name="Z", default=False)

    bpy.types.Scene.rmt_torso_controller_enum = bpy.props.EnumProperty(
        name="Torso Controller",
        description="Controller to extract motion from",
        items=get_torso_items,
    )

    bpy.types.Scene.rmt_root_controller_name = bpy.props.StringProperty(
        name="Root Controller",
        description="Root controller bone",
    )

    bpy.types.Scene.keep_in_world_origin = bpy.props.BoolProperty(
        name="Keep in World Origin",
        description="Keep root at world origin (XY from torso only)",
        default=False,
    )

    bpy.types.Scene.rmt_action_items = bpy.props.CollectionProperty(type=RMT_ActionItem)
    bpy.types.Scene.rmt_batch_actions = bpy.props.CollectionProperty(type=RMT_ActionItem)


def unregister_properties():
    del bpy.types.Scene.rmt_selected_rig
    del bpy.types.Scene.controllers
    del bpy.types.Scene.controllers_index
    del bpy.types.Scene.axis_x
    del bpy.types.Scene.axis_y
    del bpy.types.Scene.axis_z
    del bpy.types.Scene.rmt_torso_controller_enum
    del bpy.types.Scene.rmt_root_controller_name
    del bpy.types.Scene.keep_in_world_origin
    del bpy.types.Scene.rmt_action_items
    del bpy.types.Scene.rmt_batch_actions


# ---------------------------------------------------------
# Operators
# ---------------------------------------------------------

class RMT_OT_AddController(bpy.types.Operator):
    bl_idname = "rmt.add_controller"
    bl_label = "Add Controllers"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scene = context.scene
        rig = scene.rmt_selected_rig

        if not rig or rig.type != 'ARMATURE':
            self.report({'WARNING'}, "Select a valid Armature")
            return {'CANCELLED'}

        if context.mode != 'POSE':
            self.report({'WARNING'}, "Switch to Pose Mode")
            return {'CANCELLED'}

        count = 0
        for bone in context.selected_pose_bones:
            if not any(c.name == bone.name for c in scene.controllers):
                item = scene.controllers.add()
                item.name = bone.name
                count += 1

        self.report({'INFO'}, f"Added {count} controllers")
        return {'FINISHED'}


class RMT_OT_ClearControllers(bpy.types.Operator):
    bl_idname = "rmt.clear_controllers"
    bl_label = "Clear Controllers"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        context.scene.controllers.clear()
        return {'FINISHED'}


class RMT_OT_RemoveController(bpy.types.Operator):
    bl_idname = "rmt.remove_controller"
    bl_label = "Remove Controller"
    bl_options = {'REGISTER', 'UNDO'}

    index: bpy.props.IntProperty()

    def execute(self, context):
        scene = context.scene
        if 0 <= self.index < len(scene.controllers):
            scene.controllers.remove(self.index)
        return {'FINISHED'}


class RMT_OT_SelectAllControllers(bpy.types.Operator):
    bl_idname = "rmt.select_all_controllers"
    bl_label = "Select All Controllers"

    def execute(self, context):
        scene = context.scene
        rig = scene.rmt_selected_rig

        if not rig or rig.type != 'ARMATURE':
            return {'CANCELLED'}

        context.view_layer.objects.active = rig
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action='DESELECT')

        for c in scene.controllers:
            if c.name in rig.pose.bones:
                rig.pose.bones[c.name].bone.select = True

        return {'FINISHED'}


class RMT_OT_TransferRootMotion(bpy.types.Operator):
    bl_idname = "rmt.transfer_root_motion"
    bl_label = "Transfer Root Motion"
    bl_options = {'REGISTER', 'UNDO'}

    action_name: bpy.props.StringProperty(default="")

    def execute(self, context):
        scene = context.scene
        rig = scene.rmt_selected_rig

        if not rig or rig.type != 'ARMATURE':
            return {'CANCELLED'}

        if self.action_name:
            if not rig.animation_data:
                rig.animation_data_create()
            rig.animation_data.action = bpy.data.actions.get(self.action_name)

        if not self.transfer_motion(context, rig):
            return {'CANCELLED'}

        self.bake_motion(context, rig)
        self.report({'INFO'}, "Root Motion Transferred")
        return {'FINISHED'}

    def transfer_motion(self, context, rig):
        scene = context.scene
        pb_root = rig.pose.bones.get(scene.rmt_root_controller_name)
        pb_torso = rig.pose.bones.get(scene.rmt_torso_controller_enum)

        if not pb_root or not pb_torso:
            return False

        for c in list(pb_root.constraints):
            if c.type == 'COPY_LOCATION':
                pb_root.constraints.remove(c)

        pb_root.location = (0, 0, 0)

        c = pb_root.constraints.new('COPY_LOCATION')
        c.target = rig
        c.subtarget = pb_torso.name
        c.target_space = 'WORLD'
        c.owner_space = 'WORLD'
        c.use_offset = False

        if scene.keep_in_world_origin:
            c.use_x, c.use_y, c.use_z = True, True, False
        else:
            c.use_x = scene.axis_x
            c.use_y = scene.axis_y
            c.use_z = scene.axis_z

        return True

    def bake_motion(self, context, rig):
        scene = context.scene
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action='DESELECT')
        pb_root = rig.pose.bones.get(scene.rmt_root_controller_name)
        pb_root.bone.select = True
        rig.data.bones.active = pb_root.bone

        bpy.ops.nla.bake(
            frame_start=scene.frame_start,
            frame_end=scene.frame_end,
            only_selected=True,
            visual_keying=True,
            clear_constraints=True,
            clear_parents=True,
            bake_types={'POSE'},
        )


class RMT_OT_BatchTransferRootMotionContinue(bpy.types.Operator):
    bl_idname = "rmt.batch_transfer_root_motion_continue"
    bl_label = "Batch Transfer Root Motion"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scene = context.scene
        rig = scene.rmt_selected_rig

        current_action = rig.animation_data.action if rig.animation_data else None

        for item in scene.rmt_batch_actions:
            bpy.ops.rmt.transfer_root_motion(
                'EXEC_DEFAULT',
                action_name=item.name
            )

        if current_action and rig.animation_data:
            rig.animation_data.action = current_action

        return {'FINISHED'}


# ---------------------------------------------------------
# UI
# ---------------------------------------------------------

class RMT_PT_RootMotionPanel(bpy.types.Panel):
    bl_label = "Anim Tool Transfer"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"
    bl_category = "Venky Anim Toolz"

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        layout.prop(scene, "rmt_selected_rig")
        layout.operator("rmt.add_controller", icon='PLUS')
        layout.operator("rmt.clear_controllers", icon='TRASH')

        box = layout.box()
        for i, c in enumerate(scene.controllers):
            row = box.row()
            row.label(text=c.name, icon='BONE_DATA')
            op = row.operator("rmt.remove_controller", text="", icon='X')
            op.index = i

        layout.prop(scene, "rmt_torso_controller_enum")
        layout.prop_search(
            scene,
            "rmt_root_controller_name",
            scene.rmt_selected_rig.pose if scene.rmt_selected_rig else None,
            "bones",
            text="Root"
        )

        layout.prop(scene, "keep_in_world_origin")
        if not scene.keep_in_world_origin:
            row = layout.row(align=True)
            row.prop(scene, "axis_x")
            row.prop(scene, "axis_y")
            row.prop(scene, "axis_z")

        layout.operator("rmt.transfer_root_motion", icon='PLAY')


# ---------------------------------------------------------
# Registration
# ---------------------------------------------------------

classes = (
    RMT_ControllerItem,
    RMT_ActionItem,
    RMT_OT_AddController,
    RMT_OT_ClearControllers,
    RMT_OT_RemoveController,
    RMT_OT_SelectAllControllers,
    RMT_OT_TransferRootMotion,
    RMT_OT_BatchTransferRootMotionContinue,
    RMT_PT_RootMotionPanel,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    register_properties()


def unregister():
    unregister_properties()
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)


if __name__ == "__main__":
    register()
