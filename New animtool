# -*- coding: utf-8 -*-
import bpy

bl_info = {
    "name": "Anim Tool Transfer",
    "author": "Venkatesh sanku",
    "version": (1, 0, 1),
    "blender": (5, 0, 1),
    "location": "View3D > Sidebar > Anim Tool Transfer",
    "description": (
        "Adjust root controller position per action or keep in world origin. "
        "Supports batch processing for game engine root motion."
    ),
    "category": "Animation",
    "license": "SPDX:GPL-3.0-or-later"
}

# ------------------------------------------------------------------------
# Property Groups
# ------------------------------------------------------------------------

class RMT_ControllerItem(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty()

class RMT_ActionItem(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty()
    action: bpy.props.PointerProperty(type=bpy.types.Action)
    is_selected: bpy.props.BoolProperty(default=False)

# ------------------------------------------------------------------------
# Safe Enum (Blender 5.x FIX)
# ------------------------------------------------------------------------

def get_torso_items(self, context):
    items = [(c.name, c.name, "") for c in context.scene.controllers]
    if not items:
        items.append(("NONE", "None", "No controller"))
    return items

# ------------------------------------------------------------------------
# Scene Properties
# ------------------------------------------------------------------------

def register_properties():
    bpy.types.Scene.rmt_selected_rig = bpy.props.PointerProperty(
        name="Rig",
        type=bpy.types.Object
    )

    bpy.types.Scene.controllers = bpy.props.CollectionProperty(type=RMT_ControllerItem)
    bpy.types.Scene.controllers_index = bpy.props.IntProperty()

    bpy.types.Scene.axis_x = bpy.props.BoolProperty(default=True)
    bpy.types.Scene.axis_y = bpy.props.BoolProperty(default=True)
    bpy.types.Scene.axis_z = bpy.props.BoolProperty(default=False)

    bpy.types.Scene.keep_in_world_origin = bpy.props.BoolProperty(default=False)

    bpy.types.Scene.rmt_torso_controller_enum = bpy.props.EnumProperty(
        name="Torso Controller",
        items=get_torso_items,
        default="NONE"
    )

    bpy.types.Scene.rmt_root_controller_name = bpy.props.StringProperty(
        name="Root Controller"
    )

    bpy.types.Scene.rmt_action_items = bpy.props.CollectionProperty(type=RMT_ActionItem)
    bpy.types.Scene.rmt_batch_actions = bpy.props.CollectionProperty(type=RMT_ActionItem)

def unregister_properties():
    del bpy.types.Scene.rmt_selected_rig
    del bpy.types.Scene.controllers
    del bpy.types.Scene.controllers_index
    del bpy.types.Scene.axis_x
    del bpy.types.Scene.axis_y
    del bpy.types.Scene.axis_z
    del bpy.types.Scene.keep_in_world_origin
    del bpy.types.Scene.rmt_torso_controller_enum
    del bpy.types.Scene.rmt_root_controller_name
    del bpy.types.Scene.rmt_action_items
    del bpy.types.Scene.rmt_batch_actions

# ------------------------------------------------------------------------
# Operators
# ------------------------------------------------------------------------

class RMT_OT_AddController(bpy.types.Operator):
    bl_idname = "rmt.add_controller"
    bl_label = "Add Controllers"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        rig = context.scene.rmt_selected_rig
        if not rig or rig.type != 'ARMATURE':
            self.report({'WARNING'}, "Select an Armature")
            return {'CANCELLED'}

        if context.mode != 'POSE':
            self.report({'WARNING'}, "Switch to Pose Mode")
            return {'CANCELLED'}

        for bone in context.selected_pose_bones:
            if not any(c.name == bone.name for c in context.scene.controllers):
                item = context.scene.controllers.add()
                item.name = bone.name

        return {'FINISHED'}

class RMT_OT_ClearControllers(bpy.types.Operator):
    bl_idname = "rmt.clear_controllers"
    bl_label = "Clear Controllers"

    def execute(self, context):
        context.scene.controllers.clear()
        return {'FINISHED'}

class RMT_OT_RemoveController(bpy.types.Operator):
    bl_idname = "rmt.remove_controller"
    bl_label = "Remove Controller"
    index: bpy.props.IntProperty()

    def execute(self, context):
        context.scene.controllers.remove(self.index)
        return {'FINISHED'}

class RMT_OT_SelectAllControllers(bpy.types.Operator):
    bl_idname = "rmt.select_all_controllers"
    bl_label = "Select Controllers"

    def execute(self, context):
        rig = context.scene.rmt_selected_rig
        if not rig:
            return {'CANCELLED'}

        bpy.context.view_layer.objects.active = rig
        bpy.ops.object.mode_set(mode='POSE')
        bpy.ops.pose.select_all(action='DESELECT')

        for c in context.scene.controllers:
            if c.name in rig.pose.bones:
                rig.pose.bones[c.name].bone.select = True

        return {'FINISHED'}

# ------------------------------------------------------------------------
# Root Motion Core
# ------------------------------------------------------------------------

class RMT_OT_TransferRootMotion(bpy.types.Operator):
    bl_idname = "rmt.transfer_root_motion"
    bl_label = "Apply Root Motion"
    bl_options = {'REGISTER', 'UNDO'}

    action_name: bpy.props.StringProperty(default="")

    def execute(self, context):
        rig = context.scene.rmt_selected_rig
        if not rig:
            self.report({'ERROR'}, "No rig selected")
            return {'CANCELLED'}

        if self.action_name:
            rig.animation_data.action = bpy.data.actions.get(self.action_name)

        self.create_reference(context, rig)
        self.bake_reference(context)
        self.apply_constraints(context, rig)
        self.final_bake(context, rig)
        self.cleanup(context)

        return {'FINISHED'}

    # ---- FIXED: Method exists (AttributeError solved)
    def create_reference(self, context, rig):
        col = bpy.data.collections.new("RootMotionRefs")
        context.scene.collection.children.link(col)

        for c in context.scene.controllers:
            empty = bpy.data.objects.new(f"{c.name}_ref", None)
            col.objects.link(empty)
            empty.parent = rig
            empty.matrix_world = rig.matrix_world @ rig.pose.bones[c.name].matrix

    def bake_reference(self, context):
        bpy.ops.nla.bake(
            frame_start=context.scene.frame_start,
            frame_end=context.scene.frame_end,
            visual_keying=True,
            clear_constraints=True,
            bake_types={'OBJECT'}
        )

    def apply_constraints(self, context, rig):
        root = rig.pose.bones.get(context.scene.rmt_root_controller_name)
        if not root:
            return
        con = root.constraints.new("COPY_LOCATION")
        con.use_x = context.scene.axis_x
        con.use_y = context.scene.axis_y
        con.use_z = context.scene.axis_z

    def final_bake(self, context, rig):
        bpy.ops.nla.bake(
            frame_start=context.scene.frame_start,
            frame_end=context.scene.frame_end,
            visual_keying=True,
            clear_constraints=True,
            bake_types={'POSE'}
        )

    def cleanup(self, context):
        col = bpy.data.collections.get("RootMotionRefs")
        if col:
            for o in col.objects:
                bpy.data.objects.remove(o, do_unlink=True)
            bpy.data.collections.remove(col)

# ------------------------------------------------------------------------
# Batch Processing
# ------------------------------------------------------------------------

def action_contains_rig_animation(action, rig):
    for f in action.fcurves:
        if 'pose.bones["' in f.data_path:
            return True
    return False

class RMT_OT_BatchTransferRootMotion(bpy.types.Operator):
    bl_idname = "rmt.batch_transfer_root_motion"
    bl_label = "Batch Transfer"

    def invoke(self, context, event):
        rig = context.scene.rmt_selected_rig
        context.scene.rmt_action_items.clear()

        for act in bpy.data.actions:
            if action_contains_rig_animation(act, rig):
                item = context.scene.rmt_action_items.add()
                item.name = act.name
                item.action = act

        return context.window_manager.invoke_props_dialog(self)

    def draw(self, context):
        for item in context.scene.rmt_action_items:
            self.layout.prop(item, "is_selected", text=item.name)

    def execute(self, context):
        for item in context.scene.rmt_action_items:
            if item.is_selected:
                bpy.ops.rmt.transfer_root_motion(action_name=item.name)
        return {'FINISHED'}

# ------------------------------------------------------------------------
# UI Panel
# ------------------------------------------------------------------------

class RMT_PT_RootMotionPanel(bpy.types.Panel):
    bl_label = "Anim Tool Transfer"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"
    bl_category = "Venky Anim Toolz"

    def draw(self, context):
        l = self.layout
        s = context.scene

        l.prop(s, "rmt_selected_rig")
        l.operator("rmt.add_controller")
        l.operator("rmt.clear_controllers")

        for i, c in enumerate(s.controllers):
            row = l.row()
            row.label(text=c.name)
            op = row.operator("rmt.remove_controller", text="X")
            op.index = i

        l.prop(s, "rmt_torso_controller_enum")
        l.prop_search(s, "rmt_root_controller_name", s.rmt_selected_rig.pose, "bones")
        l.prop(s, "keep_in_world_origin")
        l.prop(s, "axis_x")
        l.prop(s, "axis_y")
        l.prop(s, "axis_z")

        l.operator("rmt.transfer_root_motion", icon='PLAY')
        l.operator("rmt.batch_transfer_root_motion", icon='ACTION')

# ------------------------------------------------------------------------
# Registration
# ------------------------------------------------------------------------

classes = (
    RMT_ControllerItem,
    RMT_ActionItem,
    RMT_OT_AddController,
    RMT_OT_ClearControllers,
    RMT_OT_RemoveController,
    RMT_OT_SelectAllControllers,
    RMT_OT_TransferRootMotion,
    RMT_OT_BatchTransferRootMotion,
    RMT_PT_RootMotionPanel,
)

def register():
    for c in classes:
        bpy.utils.register_class(c)
    register_properties()

def unregister():
    unregister_properties()
    for c in reversed(classes):
        bpy.utils.unregister_class(c)

if __name__ == "__main__":
    register()
