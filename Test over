tes full

Direct fix provided below: a consolidated full script that removes all operator-based grouping and uses only the stable data API to create/get bone groups and assign them to PoseBone objects, plus explicit guards to ensure only PoseBone.bone_group is accessed. This avoids the operator-context errors at lines 69 and 195 and the earlier attribute errors. All grouping is now via the API path documented for PoseBone and BoneGroup [1][2][3][4].

## Full script (pose-bone only, API grouping)

```python
import bpy
import fnmatch
import mathutils.noise as noise

# ---------- Utilities ----------

def CleanUpProc():
    # Ensure Object Mode before selection/deletion
    if bpy.context.mode != 'OBJECT':
        try:
            bpy.ops.object.mode_set(mode='OBJECT')
        except Exception:
            pass
    patterns = ["*_overlapOffsetLocator*"]
    objs_to_delete = []
    for obj in bpy.data.objects:
        for pat in patterns:
            if fnmatch.fnmatch(obj.name, pat):
                objs_to_delete.append(obj)
                break
    for o in objs_to_delete:
        try:
            o.select_set(True)
        except Exception:
            pass
    if objs_to_delete:
        try:
            bpy.ops.object.delete()
        except Exception:
            for o in objs_to_delete:
                try:
                    bpy.data.objects.remove(o, do_unlink=True)
                except Exception:
                    pass

def ensure_active_pose(arm_obj):
    # Make arm_obj active and in Pose Mode (safe for other API parts)
    if bpy.context.view_layer.objects.active != arm_obj:
        bpy.context.view_layer.objects.active = arm_obj
    if arm_obj.mode != 'POSE':
        try:
            bpy.ops.object.mode_set(mode='POSE')
        except Exception:
            pass

def get_bone_hierarchy(pose_bones):
    # Build ordered list of pose bones including children
    hierarchy = []
    seen = set()
    def recurse(pbone):
        if pbone.name in seen:
            return
        seen.add(pbone.name)
        hierarchy.append(pbone)
        for child_bone in pbone.bone.children:
            child_pb = pbone.id_data.pose.bones.get(child_bone.name)
            if child_pb is not None:
                recurse(child_pb)
    for pb in pose_bones:
        recurse(pb)
    return hierarchy

def calculate_adaptive_scale(pose_bones, min_frame, max_frame):
    scn = bpy.context.scene
    cur = scn.frame_current
    total_motion = 0.0
    sample_count = 0
    for pbone in pose_bones:
        prev_x = None
        for f in range(min_frame, max_frame + 1):
            scn.frame_set(f)
            cx = float(pbone.location.x)
            if prev_x is not None:
                total_motion += abs(cx - prev_x)
                sample_count += 1
            prev_x = cx
    scn.frame_set(cur)
    if sample_count == 0:
        return 1.0
    avg = total_motion / sample_count
    return max(0.1, min(avg * 2.0, 10.0))

def get_or_new_bone_group_api(arm_obj, group_name):
    # Pure API path for bone groups
    pg = arm_obj.pose.bone_groups.get(group_name)
    if pg is None:
        pg = arm_obj.pose.bone_groups.new(name=group_name)
    return pg

def assign_overlap_group_api(arm_obj, target_pose_bones, group_name="Overlapper_BoneGroup"):
    # Assign the given pose bones to a named group; clear others from that group
    pg = get_or_new_bone_group_api(arm_obj, group_name)
    target_set = {pb.name for pb in target_pose_bones if isinstance(pb, bpy.types.PoseBone)}
    for pbone in arm_obj.pose.bones:
        if not isinstance(pbone, bpy.types.PoseBone):
            continue
        if pbone.name in target_set:
            pbone.bone_group = pg
        else:
            if pbone.bone_group == pg:
                pbone.bone_group = None

def create_action_and_add_nla(arm_obj, new_action_name):
    # Push down current action to NLA and create a fresh action
    if not arm_obj.animation_data:
        arm_obj.animation_data_create()
    anim = arm_obj.animation_data

    if anim.action:
        nla_track = anim.nla_tracks.new() if not anim.nla_tracks else anim.nla_tracks
        # Safe start frame as int
        try:
            start_frame = anim.action.frame_range
        except Exception:
            start_frame = bpy.context.scene.frame_start
        if start_frame is None:
            start_frame = bpy.context.scene.frame_start
        start_frame = int(start_frame)
        # Unique strip name
        base = anim.action.name
        used = {s.name for s in nla_track.strips}
        name = base
        i = 1
        while name in used:
            name = f"{base}_{i}"
            i += 1
        try:
            strip = nla_track.strips.new(name=name, start=start_frame)
            strip.action = anim.action
            anim.action = None
        except Exception as e:
            print("NLA strip create failed:", e)

    new_action = bpy.data.actions.new(new_action_name)
    anim.action = new_action
    return new_action

# ---------- Operators ----------

class OVERLAPPER_OT_RunOverlapper(bpy.types.Operator):
    bl_idname = "overlapper.run"
    bl_label = "Run Overlapper (Selected Bones)"
    bl_description = "Bake overlap on selected pose bones with adaptive scale, wind and optional cycling"

    softness: bpy.props.FloatProperty(name="Softness", default=3.0, min=0.0, max=50.0)
    adaptive_scale: bpy.props.BoolProperty(name="Adaptive Scale", default=True)
    global_scale: bpy.props.FloatProperty(name="Scale", default=1.0, min=0.0)
    wind: bpy.props.BoolProperty(name="Wind", default=False)
    wind_scale: bpy.props.FloatProperty(name="Wind Scale", default=1.0, min=0.0)
    wind_speed: bpy.props.FloatProperty(name="Wind Speed", default=1.0, min=0.0)
    first_ctrl: bpy.props.BoolProperty(name="Skip first bone", default=False)
    cycle: bpy.props.BoolProperty(name="Cycle", default=False)

    def execute(self, context):
        arm = context.active_object
        if not arm or arm.type != 'ARMATURE':
            self.report({'WARNING'}, "Active object must be an Armature")
            return {'CANCELLED'}

        ensure_active_pose(arm)

        sel_pose_bones = [pb for pb in arm.pose.bones if pb.bone.select]
        if len(sel_pose_bones) < 2:
            self.report({'WARNING'}, "Select at least 2 pose bones")
            return {'CANCELLED'}
        if self.first_ctrl:
            sel_pose_bones = sel_pose_bones[1:]
        if not sel_pose_bones:
            self.report({'WARNING'}, "No bones left after skipping first")
            return {'CANCELLED'}

        CleanUpProc()

        scn = context.scene
        f0, f1 = scn.frame_start, scn.frame_end
        eff_soft = float(self.softness)
        if self.adaptive_scale:
            eff_soft *= float(calculate_adaptive_scale(sel_pose_bones, f0, f1))

        action = create_action_and_add_nla(arm, f"{arm.name}_OverlapAction")

        # Group assignment via API (stable)
        assign_overlap_group_api(arm, sel_pose_bones, "Overlapper_BoneGroup")

        cur = scn.frame_current
        for idx, pbone in enumerate(sel_pose_bones):
            if not isinstance(pbone, bpy.types.PoseBone):
                continue
            orig_x = float(pbone.location.x)

            # Clear existing X loc fcurve points for this bone in the new action
            path = f'pose.bones["{pbone.name}"].location'
            fcurves = [fc for fc in action.fcurves if fc.data_path == path and fc.array_index == 0]
            for fc in fcurves:
                try:
                    fc.keyframe_points.clear()
                except Exception:
                    pass

            for f in range(f0, f1 + 1):
                scn.frame_set(f)
                base_x = float(pbone.location.x)
                wind_off = 0.0
                if self.wind:
                    # Smooth-ish noise by frame and bone index
                    wind_off = (noise.noise(f * 0.1 + idx) - 0.5) * 2.0 * float(self.wind_scale) * float(self.wind_speed)
                new_x = base_x + eff_soft * float(self.global_scale) + wind_off
                bake_frame = f + int(eff_soft * idx)
                if bake_frame > f1:
                    bake_frame = f1
                pbone.location.x = new_x
                try:
                    pbone.keyframe_insert(data_path="location", frame=bake_frame, index=0)
                except Exception:
                    pass

            scn.frame_set(cur)
            pbone.location.x = orig_x

        if self.cycle:
            for pbone in sel_pose_bones:
                path = f'pose.bones["{pbone.name}"].location'
                for fc in action.fcurves:
                    if fc.data_path == path:
                        fc.extrapolation = 'CYCLIC'

        self.report({'INFO'}, "Overlap bake finished on selected bones")
        return {'FINISHED'}

class OVERLAPPER_OT_RunOverlapperHierarchy(bpy.types.Operator):
    bl_idname = "overlapper.run_hierarchy"
    bl_label = "Run Overlapper (Hierarchy)"
    bl_description = "Bake overlap on selected pose bones and all children"

    softness: bpy.props.FloatProperty(name="Softness", default=3.0, min=0.0, max=50.0)
    adaptive_scale: bpy.props.BoolProperty(name="Adaptive Scale", default=True)
    global_scale: bpy.props.FloatProperty(name="Scale", default=1.0, min=0.0)
    wind: bpy.props.BoolProperty(name="Wind", default=False)
    wind_scale: bpy.props.FloatProperty(name="Wind Scale", default=1.0, min=0.0)
    wind_speed: bpy.props.FloatProperty(name="Wind Speed", default=1.0, min=0.0)
    first_ctrl: bpy.props.BoolProperty(name="Skip first bone", default=False)
    cycle: bpy.props.BoolProperty(name="Cycle", default=False)

    def execute(self, context):
        arm = context.active_object
        if not arm or arm.type != 'ARMATURE':
            self.report({'WARNING'}, "Active object must be an Armature")
            return {'CANCELLED'}

        ensure_active_pose(arm)

        roots = [pb for pb in arm.pose.bones if pb.bone.select]
        if not roots:
            self.report({'WARNING'}, "Select at least one pose bone")
            return {'CANCELLED'}

        all_pose_bones = get_bone_hierarchy(roots)
        if self.first_ctrl and all_pose_bones:
            all_pose_bones = all_pose_bones[1:]
        if not all_pose_bones:
            self.report({'WARNING'}, "No bones left after skipping first")
            return {'CANCELLED'}

        CleanUpProc()

        scn = context.scene
        f0, f1 = scn.frame_start, scn.frame_end
        eff_soft = float(self.softness)
        if self.adaptive_scale:
            eff_soft *= float(calculate_adaptive_scale(all_pose_bones, f0, f1))

        action = create_action_and_add_nla(arm, f"{arm.name}_OverlapHierarchyAction")

        # Group assignment via API (stable)
        assign_overlap_group_api(arm, all_pose_bones, "Overlapper_BoneGroup")

        cur = scn.frame_current
        for idx, pbone in enumerate(all_pose_bones):
            if not isinstance(pbone, bpy.types.PoseBone):
                continue
            orig_x = float(pbone.location.x)

            path = f'pose.bones["{pbone.name}"].location'
            fcurves = [fc for fc in action.fcurves if fc.data_path == path and fc.array_index == 0]
            for fc in fcurves:
                try:
                    fc.keyframe_points.clear()
                except Exception:
                    pass

            for f in range(f0, f1 + 1):
                scn.frame_set(f)
                base_x = float(pbone.location.x)
                wind_off = 0.0
                if self.wind:
                    wind_off = (noise.noise(f * 0.1 + idx) - 0.5) * 2.0 * float(self.wind_scale) * float(self.wind_speed)
                new_x = base_x + eff_soft * float(self.global_scale) + wind_off
                bake_frame = f + int(eff_soft * idx)
                if bake_frame > f1:
                    bake_frame = f1
                pbone.location.x = new_x
                try:
                    pbone.keyframe_insert(data_path="location", frame=bake_frame, index=0)
                except Exception:
                    pass

            scn.frame_set(cur)
            pbone.location.x = orig_x

        if self.cycle:
            for pbone in all_pose_bones:
                path = f'pose.bones["{pbone.name}"].location'
                for fc in action.fcurves:
                    if fc.data_path == path:
                        fc.extrapolation = 'CYCLIC'

        self.report({'INFO'}, f"Overlap bake finished on {len(all_pose_bones)} bones")
        return {'FINISHED'}

# ---------- UI Panel ----------

class OVERLAPPER_PT_Panel(bpy.types.Panel):
    bl_idname = "OVERLAPPER_PT_panel"
    bl_label = "Overlapper Tool (Bones)"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"
    bl_category = "Overlapper"

    def draw(self, context):
        layout = self.layout
        scn = context.scene
        layout.prop(scn, "overlapper_softness")
        layout.prop(scn, "overlapper_adaptive_scale")
        layout.prop(scn, "overlapper_global_scale")
        layout.prop(scn, "overlapper_wind")
        if scn.overlapper_wind:
            layout.prop(scn, "overlapper_wind_scale")
            layout.prop(scn, "overlapper_wind_speed")
        layout.prop(scn, "overlapper_first_ctrl")
        layout.prop(scn, "overlapper_cycle")
        layout.operator("overlapper.run", text="Overlap Selected Bones")
        layout.operator("overlapper.run_hierarchy", text="Overlap Bone Hierarchy")

# ---------- Register ----------

classes = (
    OVERLAPPER_OT_RunOverlapper,
    OVERLAPPER_OT_RunOverlapperHierarchy,
    OVERLAPPER_PT_Panel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.overlapper_softness = bpy.props.FloatProperty(name="Softness", default=3.0, min=0.0, max=50.0)
    bpy.types.Scene.overlapper_adaptive_scale = bpy.props.BoolProperty(name="Adaptive Scale", default=True)
    bpy.types.Scene.overlapper_global_scale = bpy.props.FloatProperty(name="Scale", default=1.0, min=0.0)
    bpy.types.Scene.overlapper_wind = bpy.props.BoolProperty(name="Wind", default=False)
    bpy.types.Scene.overlapper_wind_scale = bpy.props.FloatProperty(name="Wind Scale", default=1.0, min=0.0)
    bpy.types.Scene.overlapper_wind_speed = bpy.props.FloatProperty(name="Wind Speed", default=1.0, min=0.0)
    bpy.types.Scene.overlapper_first_ctrl = bpy.props.BoolProperty(name="Skip first bone", default=False)
    bpy.types.Scene.overlapper_cycle = bpy.props.BoolProperty(name="Cycle", default=False)

def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.overlapper_softness
    del bpy.types.Scene.overlapper_adaptive_scale
    del bpy.types.Scene.overlapper_global_scale
    del bpy.types.Scene.overlapper_wind
    del bpy.types.Scene.overlapper_wind_scale
    del bpy.types.Scene.overlapper_wind_speed
    del bpy.types.Scene.overlapper_first_ctrl
    del bpy.types.Scene.overlapper_cycle

if __name__ == "__main__":
    register()
```

Why this should resolve line 69 and 195 errors:
- Those lines were previously tied to pose operators failing due to context or selection; now grouping uses only the API documented for PoseBone.bone_group and Pose.bone_groups, which is valid on PoseBone objects without operator context [1][2][3][4].
- The code explicitly filters for PoseBone instances before any bone_group access, preventing attribute errors on the Pose container.

If an error persists, please paste the exact traceback and confirm Blender version and the armature context (active object, Pose Mode), and the next fix will be targeted precisely.

Citations:
[1] PoseBone(bpy_struct) - Blender Python API https://docs.blender.org/api/current/bpy.types.PoseBone.html
[2] PoseBone(bpy_struct) — Blender 2.65.8 - API documentation https://docs.blender.org/api/blender_python_api_2_65_8/bpy.types.PoseBone.html
[3] Bones & Armatures - Blender Python API https://docs.blender.org/api/current/info_gotchas_armatures_and_bones.html
[4] BoneGroup(bpy_struct) — Blender 2.62.0 - API documentation https://docs.blender.org/api/blender_python_api_2_62_0/bpy.types.BoneGroup.html
[5] PoseBone(bpy_struct) — Blender 2.78.0 0b13b7a https://docs.blender.org/api/2.78/bpy.types.PoseBone.html
[6] PoseBone(bpy_struct) — Blender v2.59.0 r39257 - API documentation https://docs.blender.org/api/blender_python_api_2_59_release/bpy.types.PoseBone.html
[7] Select pose bone in pose mode - Python Support https://blenderartists.org/t/select-pose-bone-in-pose-mode/513439
[8] Property Definitions (bpy.props) - Blender Python API https://docs.blender.org/api/current/bpy.props.html
