import bpy
import random
import fnmatch
import mathutils.noise as noise

def CleanUpProc():
    if bpy.context.mode != 'OBJECT':
        bpy.ops.object.mode_set(mode='OBJECT')
    patterns = ["*_overlapOffsetLocator*"]
    objs_to_delete = []
    for obj in bpy.data.objects:
        for pat in patterns:
            if fnmatch.fnmatch(obj.name, pat):
                objs_to_delete.append(obj)
                break
    bpy.ops.object.select_all(action='DESELECT')
    for o in objs_to_delete:
        o.select_set(True)
    if objs_to_delete:
        bpy.ops.object.delete()

def get_bone_hierarchy(pose_bones):
    hierarchy = []
    def recurse(pbone):
        if pbone in hierarchy:
            return
        hierarchy.append(pbone)
        for child_bone in pbone.bone.children:
            child_pbone = pbone.id_data.pose.bones.get(child_bone.name)
            if child_pbone:
                recurse(child_pbone)
    for pb in pose_bones:
        recurse(pb)
    return hierarchy

def calculate_adaptive_scale(pose_bones, min_frame, max_frame):
    total_motion = 0
    sample_count = 0
    scn = bpy.context.scene
    cur = scn.frame_current
    for pbone in pose_bones:
        prev_x = None
        for frame in range(min_frame, max_frame + 1):
            scn.frame_set(frame)
            current_x = pbone.location.x
            if prev_x is not None:
                total_motion += abs(current_x - prev_x)
                sample_count += 1
            prev_x = current_x
    scn.frame_set(cur)
    if sample_count == 0:
        return 1.0
    avg_motion = total_motion / sample_count
    return max(0.1, min(avg_motion * 2.0, 10.0))

def create_action_and_add_nla(arm_obj, new_action_name):
    if not arm_obj.animation_data:
        arm_obj.animation_data_create()
    anim_data = arm_obj.animation_data

    if anim_data.action:
        nla_track = anim_data.nla_tracks.new() if not anim_data.nla_tracks else anim_data.nla_tracks
        try:
            start_frame = anim_data.action.frame_range
            if start_frame is None or start_frame == float('inf'):
                start_frame = bpy.context.scene.frame_start
        except Exception:
            start_frame = bpy.context.scene.frame_start
        start_frame = int(start_frame)
        existing_names = {strip.name for strip in nla_track.strips}
        strip_name = anim_data.action.name
        count = 1
        unique_name = strip_name
        while unique_name in existing_names:
            unique_name = f"{strip_name}_{count}"
            count += 1
        try:
            nla_strip = nla_track.strips.new(name=unique_name, start=start_frame)
            nla_strip.action = anim_data.action
            anim_data.action = None
        except Exception as e:
            print(f"Could not create NLA strip: {e}")

    new_action = bpy.data.actions.new(new_action_name)
    anim_data.action = new_action
    return new_action

def ensure_pose_mode(obj):
    if bpy.context.view_layer.objects.active != obj:
        bpy.context.view_layer.objects.active = obj
    if obj.mode != 'POSE':
        bpy.ops.object.mode_set(mode='POSE')

def set_bone_group_via_ops(arm_obj, target_pose_bones, group_name="Overlapper_BoneGroup"):
    # Ensure pose mode and active object
    ensure_pose_mode(arm_obj)

    # Select only target bones at data.bones level (selection is read from data for pose ops)
    data_bones = arm_obj.data.bones
    for b in data_bones:
        b.select = False
    for pbone in target_pose_bones:
        db = data_bones.get(pbone.name)
        if db:
            db.select = True
            data_bones.active = db

    # Ensure a bone group exists and make it active by name
    # If a group with same name exists, set it active; otherwise add and rename
    # Operators operate on the active pose object context
    groups = arm_obj.pose.bone_groups
    target_index = None
    for i, g in enumerate(groups):
        if g.name == group_name:
            target_index = i
            break
    if target_index is None:
        # Add a new group and rename it
        try:
            bpy.ops.pose.group_add()
            # The new group becomes active; rename it
            for g in groups:
                pass
            # Last group heuristic
            groups[-1].name = group_name
        except Exception as e:
            print(f"Could not add bone group: {e}")
    else:
        # Make that group active
        arm_obj.pose.bone_groups.active = groups[target_index]

    # Assign selected bones to the active group
    try:
        bpy.ops.pose.group_assign(type=0)  # type=0 assigns to active group
    except Exception as e:
        print(f"Could not assign bones to group: {e}")

class OVERLAPPER_OT_RunOverlapper(bpy.types.Operator):
    bl_idname = "overlapper.run"
    bl_label = "Run Overlapper on Bones"
    bl_description = "Bake overlapping animation with adaptive softness, wind, and cycle on selected bones"

    softness: bpy.props.FloatProperty(name="Softness", default=3.0, min=0.0, max=50.0)
    adaptive_scale: bpy.props.BoolProperty(name="Adaptive Scale", default=True)
    global_scale: bpy.props.FloatProperty(name="Scale", default=1.0, min=0.0)
    wind: bpy.props.BoolProperty(name="Wind", default=False)
    wind_scale: bpy.props.FloatProperty(name="Wind Scale", default=1.0, min=0.0)
    wind_speed: bpy.props.FloatProperty(name="Wind Speed", default=1.0, min=0.0)
    first_ctrl: bpy.props.BoolProperty(name="Don't use first control", default=False)
    cycle: bpy.props.BoolProperty(name="Cycle Animation", default=False)

    def execute(self, context):
        objs = context.selected_objects
        if not objs:
            self.report({'WARNING'}, "Select at least one armature object")
            return {'CANCELLED'}

        sel_pose_bones = []
        for obj in objs:
            if obj.type != 'ARMATURE':
                continue
            if obj.mode != 'POSE':
                self.report({'WARNING'}, f"Armature '{obj.name}' not in Pose Mode. Please enter Pose Mode.")
                return {'CANCELLED'}
            sel_pose_bones.extend([pb for pb in obj.pose.bones if pb.bone.select])

        if len(sel_pose_bones) < 2:
            self.report({'WARNING'}, "Select at least 2 bones in Pose Mode")
            return {'CANCELLED'}

        CleanUpProc()

        active_arm_obj = context.active_object
        if not active_arm_obj or active_arm_obj.type != 'ARMATURE':
            self.report({'WARNING'}, "Active object must be an armature for baking")
            return {'CANCELLED'}

        ensure_pose_mode(active_arm_obj)

        if self.first_ctrl:
            sel_pose_bones = sel_pose_bones[1:]

        if not sel_pose_bones:
            self.report({'WARNING'}, "No bones to bake after skipping first control")
            return {'CANCELLED'}

        scene = context.scene
        min_frame = scene.frame_start
        max_frame = scene.frame_end

        eff_softness = self.softness
        if self.adaptive_scale:
            eff_softness *= calculate_adaptive_scale(sel_pose_bones, min_frame, max_frame)

        new_action = create_action_and_add_nla(active_arm_obj, f"{active_arm_obj.name}_OverlapAction")

        # Assign group using operators (robust across versions)
        set_bone_group_via_ops(active_arm_obj, sel_pose_bones, "Overlapper_BoneGroup")

        cur = scene.frame_current
        for index, pbone in enumerate(sel_pose_bones):
            orig_x = pbone.location.x
            # Clear existing X-location keys for this bone in the new action
            fcurves_to_clear = [fc for fc in new_action.fcurves
                                if fc.data_path == f'pose.bones["{pbone.name}"].location' and fc.array_index == 0]
            for fc in fcurves_to_clear:
                fc.keyframe_points.clear()

            for frame in range(min_frame, max_frame + 1):
                scene.frame_set(frame)
                base_val = pbone.location.x

                wind_offset = 0
                if self.wind:
                    wind_offset = (noise.noise(frame * 0.1 + index) - 0.5) * 2 * self.wind_scale * self.wind_speed

                new_val = base_val + eff_softness * self.global_scale + wind_offset
                bake_frame = frame + int(eff_softness * index)
                if bake_frame > max_frame:
                    bake_frame = max_frame

                pbone.location.x = new_val
                pbone.keyframe_insert(data_path="location", frame=bake_frame, index=0)

            scene.frame_set(cur)
            pbone.location.x = orig_x

        if self.cycle:
            for pbone in sel_pose_bones:
                for fc in new_action.fcurves:
                    if fc.data_path.startswith(f'pose.bones["{pbone.name}"].location'):
                        fc.extrapolation = 'Cyclic'

        self.report({'INFO'}, "Overlapper on bones completed.")
        return {'FINISHED'}

class OVERLAPPER_OT_RunOverlapperHierarchy(bpy.types.Operator):
    bl_idname = "overlapper.run_hierarchy"
    bl_label = "Run Overlapper on Bone Hierarchy"
    bl_description = "Bake overlapping animation on selected bones and their child hierarchy with adaptive softness, wind, and cycle"

    softness: bpy.props.FloatProperty(name="Softness", default=3.0, min=0.0, max=50.0)
    adaptive_scale: bpy.props.BoolProperty(name="Adaptive Scale", default=True)
    global_scale: bpy.props.FloatProperty(name="Scale", default=1.0, min=0.0)
    wind: bpy.props.BoolProperty(name="Wind", default=False)
    wind_scale: bpy.props.FloatProperty(name="Wind Scale", default=1.0, min=0.0)
    wind_speed: bpy.props.FloatProperty(name="Wind Speed", default=1.0, min=0.0)
    first_ctrl: bpy.props.BoolProperty(name="Don't use first control", default=False)
    cycle: bpy.props.BoolProperty(name="Cycle Animation", default=False)

    def execute(self, context):
        objs = context.selected_objects
        if not objs:
            self.report({'WARNING'}, "Select at least one armature object")
            return {'CANCELLED'}

        sel_pose_bones = []
        for obj in objs:
            if obj.type != 'ARMATURE':
                continue
            if obj.mode != 'POSE':
                self.report({'WARNING'}, f"Armature '{obj.name}' not in Pose Mode. Please enter Pose Mode.")
                return {'CANCELLED'}
            sel_pose_bones.extend([pb for pb in obj.pose.bones if pb.bone.select])

        if len(sel_pose_bones) < 1:
            self.report({'WARNING'}, "Select at least one bone in Pose Mode")
            return {'CANCELLED'}

        all_pose_bones = get_bone_hierarchy(sel_pose_bones)

        if self.first_ctrl and all_pose_bones:
            all_pose_bones = all_pose_bones[1:]

        if not all_pose_bones:
            self.report({'WARNING'}, "No bones to bake after skipping first control")
            return {'CANCELLED'}

        CleanUpProc()

        active_arm_obj = context.active_object
        if not active_arm_obj or active_arm_obj.type != 'ARMATURE':
            self.report({'WARNING'}, "Active object must be an armature for baking")
            return {'CANCELLED'}

        ensure_pose_mode(active_arm_obj)

        scene = context.scene
        min_frame = scene.frame_start
        max_frame = scene.frame_end

        eff_softness = self.softness
        if self.adaptive_scale:
            eff_softness *= calculate_adaptive_scale(all_pose_bones, min_frame, max_frame)

        new_action = create_action_and_add_nla(active_arm_obj, f"{active_arm_obj.name}_OverlapHierarchyAction")

        # Assign group using operators
        set_bone_group_via_ops(active_arm_obj, all_pose_bones, "Overlapper_BoneGroup")

        cur = scene.frame_current
        for index, pbone in enumerate(all_pose_bones):
            orig_x = pbone.location.x

            fcurves_to_clear = [fc for fc in new_action.fcurves
                                if fc.data_path == f'pose.bones["{pbone.name}"].location' and fc.array_index == 0]
            for fc in fcurves_to_clear:
                fc.keyframe_points.clear()

            for frame in range(min_frame, max_frame + 1):
                scene.frame_set(frame)
                base_val = pbone.location.x

                wind_offset = 0
                if self.wind:
                    wind_offset = (noise.noise(frame * 0.1 + index) - 0.5) * 2 * self.wind_scale * self.wind_speed

                new_val = base_val + eff_softness * self.global_scale + wind_offset
                bake_frame = frame + int(eff_softness * index)
                if bake_frame > max_frame:
                    bake_frame = max_frame

                pbone.location.x = new_val
                pbone.keyframe_insert(data_path="location", frame=bake_frame, index=0)

            scene.frame_set(cur)
            pbone.location.x = orig_x

        if self.cycle:
            for pbone in all_pose_bones:
                for fc in new_action.fcurves:
                    if fc.data_path.startswith(f'pose.bones["{pbone.name}"].location'):
                        fc.extrapolation = 'Cyclic'

        self.report({'INFO'}, f"Overlapper hierarchy baked on {len(all_pose_bones)} bones.")
        return {'FINISHED'}

class OVERLAPPER_PT_Panel(bpy.types.Panel):
    bl_idname = "OVERLAPPER_PT_panel"
    bl_label = "Overlapper Tool (Bones)"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"
    bl_category = "Overlapper"

    def draw(self, context):
        layout = self.layout
        scn = context.scene

        layout.prop(scn, "overlapper_softness")
        layout.prop(scn, "overlapper_adaptive_scale")
        layout.prop(scn, "overlapper_global_scale")
        layout.prop(scn, "overlapper_wind")
        if scn.overlapper_wind:
            layout.prop(scn, "overlapper_wind_scale")
            layout.prop(scn, "overlapper_wind_speed")
        layout.prop(scn, "overlapper_first_ctrl")
        layout.prop(scn, "overlapper_cycle")

        layout.operator("overlapper.run", text="Overlap Selected Bones")
        layout.operator("overlapper.run_hierarchy", text="Overlap Bone Hierarchy")

classes = (
    OVERLAPPER_OT_RunOverlapper,
    OVERLAPPER_OT_RunOverlapperHierarchy,
    OVERLAPPER_PT_Panel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.overlapper_softness = bpy.props.FloatProperty(name="Softness", default=3.0, min=0.0, max=50.0)
    bpy.types.Scene.overlapper_adaptive_scale = bpy.props.BoolProperty(name="Adaptive Scale", default=True)
    bpy.types.Scene.overlapper_global_scale = bpy.props.FloatProperty(name="Scale", default=1.0, min=0.0)
    bpy.types.Scene.overlapper_wind = bpy.props.BoolProperty(name="Wind", default=False)
    bpy.types.Scene.overlapper_wind_scale = bpy.props.FloatProperty(name="Wind Scale", default=1.0, min=0.0)
    bpy.types.Scene.overlapper_wind_speed = bpy.props.FloatProperty(name="Wind Speed", default=1.0, min=0.0)
    bpy.types.Scene.overlapper_first_ctrl = bpy.props.BoolProperty(name="Don't use first control", default=False)
    bpy.types.Scene.overlapper_cycle = bpy.props.BoolProperty(name="Cycle Animation", default=False)

def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.overlapper_softness
    del bpy.types.Scene.overlapper_adaptive_scale
    del bpy.types.Scene.overlapper_global_scale
    del bpy.types.Scene.overlapper_wind
    del bpy.types.Scene.overlapper_wind_scale
    del bpy.types.Scene.overlapper_wind_speed
    del bpy.types.Scene.overlapper_first_ctrl
    del bpy.types.Scene.overlapper_cycle

if __name__ == "__main__":
    register()
