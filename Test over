bl_info = {
    "name": "Reliable Bone Overlapper",
    "blender": (3, 0, 0),
    "category": "Animation",
    "author": "AI Assistant",
    "version": (1, 0, 2),
    "description": "Bone overlapping animation tool with proper delayed frame sampling"
}

import bpy
import mathutils

class OverlapItem(bpy.types.PropertyGroup):
    armature_ref: bpy.props.PointerProperty(type=bpy.types.Object)
    bone_name: bpy.props.StringProperty()
    delay: bpy.props.IntProperty(name="Delay", default=3, min=0, max=30)
    damping: bpy.props.FloatProperty(name="Damping", default=0.8, min=0.0, max=1.0)
    affect_translation: bpy.props.BoolProperty(name="Affect Translation", default=True)
    affect_rotation: bpy.props.BoolProperty(name="Affect Rotation", default=True)
    cycle: bpy.props.BoolProperty(name="Seamless Cycle", default=True)

def get_frame_range(context):
    scene = context.scene
    if scene.use_preview_range:
        return scene.frame_preview_start, scene.frame_preview_end
    return scene.frame_start, scene.frame_end

def blend_cycle(values, cycle):
    if cycle and len(values) > 2:
        first = values[0]
        last = values[-1]
        values[-1] = (first * 0.5 + last * 0.5)
    return values

def evaluate_pose_at_frame(arm_obj, frame):
    scene = bpy.context.scene
    current_frame = scene.frame_current
    scene.frame_set(frame)
    depsgraph = bpy.context.evaluated_depsgraph_get()
    eval_obj = arm_obj.evaluated_get(depsgraph)
    eval_pose = eval_obj.pose
    scene.frame_set(current_frame)
    return eval_pose

def apply_overlap_on_pose_bones(items, f_start, f_end):
    scene = bpy.context.scene
    for item in items:
        arm = item.armature_ref
        bone_name = item.bone_name
        delay = item.delay
        damping = item.damping
        affect_loc = item.affect_translation
        affect_rot = item.affect_rotation
        cycle = item.cycle

        if not arm or arm.type != 'ARMATURE':
            continue

        if not arm.animation_data or not arm.animation_data.action:
            continue

        pose_bone = arm.pose.bones.get(bone_name)
        if not pose_bone:
            continue

        original_action = arm.animation_data.action
        new_action = bpy.data.actions.new(name=f"{arm.name}_{bone_name}_Overlapped")
        arm.animation_data.action = new_action

        rot_mode = pose_bone.rotation_mode

        translations = []
        rotations = []

        for frame in range(f_start, f_end + 1):
            sample_frame = max(f_start, frame - delay)
            scene.frame_set(sample_frame)
            depsgraph = bpy.context.evaluated_depsgraph_get()
            eval_arm = arm.evaluated_get(depsgraph)
            eval_pose_bone = eval_arm.pose.bones.get(bone_name)

            if not eval_pose_bone:
                continue

            loc = eval_pose_bone.location.copy()
            if rot_mode == 'QUATERNION':
                rot = eval_pose_bone.rotation_quaternion.copy()
            else:
                rot = eval_pose_bone.rotation_euler.copy()

            # Apply damping blending towards zero transform to simulate overlap lag
            if affect_loc:
                loc_damped = loc * damping
                translations.append(loc_damped)
            else:
                translations.append(pose_bone.location.copy())

            if affect_rot:
                if rot_mode == 'QUATERNION':
                    q_identity = mathutils.Quaternion((1,0,0,0))
                    blended = rot.slerp(q_identity, 1.0 - damping)
                    rotations.append(blended)
                else:
                    e_identity = mathutils.Euler((0,0,0), rot_mode)
                    blended = e_identity.lerp(rot, damping)
                    rotations.append(blended)
            else:
                if rot_mode == 'QUATERNION':
                    rotations.append(pose_bone.rotation_quaternion.copy())
                else:
                    rotations.append(pose_bone.rotation_euler.copy())

        translations = blend_cycle(translations, cycle)
        rotations = blend_cycle(rotations, cycle)

        for idx, frame in enumerate(range(f_start, f_end + 1)):
            if affect_loc:
                pose_bone.location = translations[idx]
                pose_bone.keyframe_insert(data_path="location", frame=frame)
            if affect_rot:
                if rot_mode == 'QUATERNION':
                    pose_bone.rotation_mode = 'QUATERNION'
                    pose_bone.rotation_quaternion = rotations[idx]
                    pose_bone.keyframe_insert(data_path="rotation_quaternion", frame=frame)
                else:
                    pose_bone.rotation_mode = rot_mode
                    pose_bone.rotation_euler = rotations[idx]
                    pose_bone.keyframe_insert(data_path="rotation_euler", frame=frame)

class ANIM_UL_BonePicker(bpy.types.UIList):
    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
        row = layout.row(align=True)
        bone_name = item.bone_name
        arm_name = item.armature_ref.name if item.armature_ref else "?"
        row.label(text=f"{arm_name}: {bone_name}")
        row.prop(item, "delay", text="Delay")
        row.prop(item, "damping", text="Damp")
        row.prop(item, "affect_translation", text="Loc")
        row.prop(item, "affect_rotation", text="Rot")
        row.prop(item, "cycle", text="Cycle")

class ANIM_OT_AddSelectedBones(bpy.types.Operator):
    bl_idname = "anim.add_selected_bones"
    bl_label = "Add Selected Bones to Picker"
    def execute(self, context):
        sc = context.scene
        arm_obj = context.active_object
        if not arm_obj or arm_obj.type != 'ARMATURE':
            self.report({'WARNING'}, "Select an armature object")
            return {'CANCELLED'}

        picker = sc.bone_picker
        for pbone in arm_obj.data.bones:
            if pbone.select:
                exists = False
                for item in picker:
                    if (item.armature_ref == arm_obj and item.bone_name == pbone.name):
                        exists = True
                        break
                if not exists:
                    it = picker.add()
                    it.armature_ref = arm_obj
                    it.bone_name = pbone.name
        return {'FINISHED'}

class ANIM_OT_RemoveFromPicker(bpy.types.Operator):
    bl_idname = "anim.remove_from_picker"
    bl_label = "Remove From Picker"
    index: bpy.props.IntProperty()
    def execute(self, context):
        context.scene.bone_picker.remove(self.index)
        return {'FINISHED'}

class ANIM_OT_ClearPicker(bpy.types.Operator):
    bl_idname = "anim.clear_picker"
    bl_label = "Clear Picker"
    def execute(self, context):
        context.scene.bone_picker.clear()
        return {'FINISHED'}

class ANIM_OT_ApplyOverlapBones(bpy.types.Operator):
    bl_idname = "anim.apply_overlap_bones"
    bl_label = "Apply Overlap to Bones"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        f_start, f_end = get_frame_range(context)
        picker = context.scene.bone_picker
        if not picker:
            self.report({'WARNING'}, "No bones in picker")
            return {'CANCELLED'}
        apply_overlap_on_pose_bones(picker, f_start, f_end)
        self.report({'INFO'}, "Overlap applied to bones")
        return {'FINISHED'}

class VIEW3D_PT_BoneOverlapper(bpy.types.Panel):
    bl_label = "Bone Overlapper Picker"
    bl_idname = "VIEW3D_PT_bone_overlapper"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Animation'

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        row = layout.row()
        row.template_list("ANIM_UL_BonePicker", "", scene, "bone_picker", scene, "bone_picker_index", rows=5)

        col = row.column(align=True)
        col.operator("anim.add_selected_bones", icon='ADD', text="")
        col.operator("anim.remove_from_picker", icon='REMOVE', text="").index = scene.bone_picker_index
        col.operator("anim.clear_picker", icon='TRASH', text="")

        layout.operator("anim.apply_overlap_bones", icon='ANIM')

classes = [
    OverlapItem,
    ANIM_UL_BonePicker,
    ANIM_OT_AddSelectedBones,
    ANIM_OT_RemoveFromPicker,
    ANIM_OT_ClearPicker,
    ANIM_OT_ApplyOverlapBones,
    VIEW3D_PT_BoneOverlapper,
]

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.bone_picker = bpy.props.CollectionProperty(type=OverlapItem)
    bpy.types.Scene.bone_picker_index = bpy.props.IntProperty(default=0)

def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.bone_picker
    del bpy.types.Scene.bone_picker_index

if __name__ == "__main__":
    register()
