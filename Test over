import bpy
import random
import fnmatch
import mathutils.noise as noise

def CleanUpProc():
    # Ensure Object Mode before selection and deletion ops
    if bpy.context.mode != 'OBJECT':
        bpy.ops.object.mode_set(mode='OBJECT')

    if "OverlapperArmature" in bpy.data.objects:
        obj = bpy.data.objects["OverlapperArmature"]
        bpy.data.objects.remove(obj, do_unlink=True)
    patterns = [
        "*_overlapOffsetLocator*",
    ]
    objs_to_delete = []
    for obj in bpy.data.objects:
        for pat in patterns:
            if fnmatch.fnmatch(obj.name, pat):
                objs_to_delete.append(obj)
                break
    bpy.ops.object.select_all(action='DESELECT')
    for o in objs_to_delete:
        o.select_set(True)
    if objs_to_delete:
        bpy.ops.object.delete()

def get_bone_hierarchy(bones):
    hierarchy = []
    def recurse(bone):
        if bone in hierarchy:
            return
        hierarchy.append(bone)
        for child in bone.children:
            recurse(child)
    for bone in bones:
        recurse(bone)
    return hierarchy

def calculate_adaptive_scale(sel_bones, arm_obj, min_frame, max_frame):
    total_motion = 0
    sample_count = 0
    for pb in sel_bones:
        pose_bone = arm_obj.pose.bones.get(pb.name)
        if not pose_bone:
            continue
        prev_x = None
        for frame in range(min_frame, max_frame + 1):
            bpy.context.scene.frame_set(frame)
            current_x = pose_bone.location.x
            if prev_x is not None:
                total_motion += abs(current_x - prev_x)
                sample_count += 1
            prev_x = current_x
    if sample_count == 0:
        return 1.0
    avg_motion = total_motion / sample_count
    return max(0.1, min(avg_motion * 2.0, 10.0))

def get_or_create_bone_group(arm_obj, group_name):
    p = arm_obj.pose
    if not p:
        arm_obj.pose_create()
        p = arm_obj.pose
    bg = p.bone_groups.get(group_name)
    if not bg:
        bg = p.bone_groups.new(name=group_name)
    return bg

def create_action_and_add_nla(arm_obj, new_action_name):
    if not arm_obj.animation_data:
        arm_obj.animation_data_create()
    anim_data = arm_obj.animation_data

    # Push down existing action to NLA track if present
    if anim_data.action:
        nla_track = None
        for track in anim_data.nla_tracks:
            nla_track = track
            break
        if not nla_track:
            nla_track = anim_data.nla_tracks.new()

        start_frame = anim_data.action.frame_range[0] if anim_data.action.frame_range else bpy.context.scene.frame_start
        if start_frame is None or start_frame == float('inf'):
            start_frame = bpy.context.scene.frame_start

        strip_name = anim_data.action.name
        existing_names = {strip.name for strip in nla_track.strips}
        count = 1
        unique_name = strip_name
        while unique_name in existing_names:
            unique_name = f"{strip_name}_{count}"
            count += 1

        nla_strip = nla_track.strips.new(name=unique_name, start=start_frame)
        nla_strip.action = anim_data.action
        anim_data.action = None

    new_action = bpy.data.actions.new(new_action_name)
    anim_data.action = new_action
    return new_action

class OVERLAPPER_OT_RunOverlapper(bpy.types.Operator):
    bl_idname = "overlapper.run"
    bl_label = "Run Overlapper on Bones"
    bl_description = "Bake overlapping animation with adaptive softness, wind, and cycle on selected bones"

    softness: bpy.props.FloatProperty(name="Softness", default=3.0, min=0.0, max=50.0)
    adaptive_scale: bpy.props.BoolProperty(name="Adaptive Scale", default=True)
    global_scale: bpy.props.FloatProperty(name="Scale", default=1.0, min=0.0)
    wind: bpy.props.BoolProperty(name="Wind", default=False)
    wind_scale: bpy.props.FloatProperty(name="Wind Scale", default=1.0, min=0.0)
    wind_speed: bpy.props.FloatProperty(name="Wind Speed", default=1.0, min=0.0)
    first_ctrl: bpy.props.BoolProperty(name="Don't use first control", default=False)
    cycle: bpy.props.BoolProperty(name="Cycle Animation", default=False)

    def execute(self, context):
        objs = context.selected_objects
        if not objs:
            self.report({'WARNING'}, "Select at least one armature object")
            return {'CANCELLED'}

        sel_bones = []
        for obj in objs:
            if obj.type != 'ARMATURE':
                continue
            if obj.mode != 'POSE':
                self.report({'WARNING'}, f"Armature '{obj.name}' not in Pose Mode. Please enter Pose Mode.")
                return {'CANCELLED'}
            sel_bones.extend([pb.bone for pb in obj.pose.bones if pb.bone.select])

        if len(sel_bones) < 2:
            self.report({'WARNING'}, "Select at least 2 bones in Pose Mode")
            return {'CANCELLED'}

        CleanUpProc()

        active_arm_obj = context.active_object
        if not active_arm_obj or active_arm_obj.type != 'ARMATURE':
            self.report({'WARNING'}, "Active object must be an armature for baking")
            return {'CANCELLED'}
        if active_arm_obj.mode != 'POSE':
            bpy.ops.object.mode_set(mode='POSE')

        if self.first_ctrl:
            sel_bones = sel_bones[1:]

        if not sel_bones:
            self.report({'WARNING'}, "No bones to bake after skipping first control")
            return {'CANCELLED'}

        scene = context.scene
        min_frame = scene.frame_start
        max_frame = scene.frame_end

        softness = self.softness
        if self.adaptive_scale:
            adaptive = calculate_adaptive_scale(sel_bones, active_arm_obj, min_frame, max_frame)
            softness *= adaptive

        new_action = create_action_and_add_nla(active_arm_obj, f"{active_arm_obj.name}_OverlapAction")

        overlap_group = get_or_create_bone_group(active_arm_obj, "Overlapper_BoneGroup")

        for pb in active_arm_obj.pose.bones:
            if pb.bone in sel_bones:
                pb.bone_group = overlap_group
            else:
                if hasattr(pb, 'bone_group') and pb.bone_group == overlap_group:
                    pb.bone_group = None

        for index, pb in enumerate(sel_bones):
            pose_bone = active_arm_obj.pose.bones.get(pb.name)
            if not pose_bone:
                continue
            orig_x = pose_bone.location.x

            fcurves_to_clear = [fc for fc in new_action.fcurves if fc.data_path == f'pose.bones["{pb.name}"].location' and fc.array_index == 0]
            for fc in fcurves_to_clear:
                fc.keyframe_points.clear()

            for frame in range(min_frame, max_frame + 1):
                bpy.context.scene.frame_set(frame)
                base_val = pose_bone.location.x

                wind_offset = 0
                if self.wind:
                    wind_offset = (noise.noise(frame * 0.1 + index) - 0.5) * 2 * self.wind_scale * self.wind_speed

                new_val = base_val + softness * self.global_scale + wind_offset
                bake_frame = frame + (softness * index)
                if bake_frame > max_frame:
                    bake_frame = max_frame

                pose_bone.location.x = new_val
                pose_bone.keyframe_insert(data_path="location", frame=bake_frame, index=0)

            bpy.context.scene.frame_set(scene.frame_current)
            pose_bone.location.x = orig_x

        if self.cycle:
            for pb in sel_bones:
                for fc in new_action.fcurves:
                    if fc.data_path.startswith(f'pose.bones["{pb.name}"].location'):
                        fc.extrapolation = 'Cyclic'

        self.report({'INFO'}, "Overlapper on bones completed.")
        return {'FINISHED'}

class OVERLAPPER_OT_RunOverlapperHierarchy(bpy.types.Operator):
    bl_idname = "overlapper.run_hierarchy"
    bl_label = "Run Overlapper on Bone Hierarchy"
    bl_description = "Bake overlapping animation on selected bones and their child hierarchy with adaptive softness, wind, and cycle"

    softness: bpy.props.FloatProperty(name="Softness", default=3.0, min=0.0, max=50.0)
    adaptive_scale: bpy.props.BoolProperty(name="Adaptive Scale", default=True)
    global_scale: bpy.props.FloatProperty(name="Scale", default=1.0, min=0.0)
    wind: bpy.props.BoolProperty(name="Wind", default=False)
    wind_scale: bpy.props.FloatProperty(name="Wind Scale", default=1.0, min=0.0)
    wind_speed: bpy.props.FloatProperty(name="Wind Speed", default=1.0, min=0.0)
    first_ctrl: bpy.props.BoolProperty(name="Don't use first control", default=False)
    cycle: bpy.props.BoolProperty(name="Cycle Animation", default=False)

    def execute(self, context):
        objs = context.selected_objects
        if not objs:
            self.report({'WARNING'}, "Select at least one armature object")
            return {'CANCELLED'}

        sel_bones = []
        for obj in objs:
            if obj.type != 'ARMATURE':
                continue
            if obj.mode != 'POSE':
                self.report({'WARNING'}, f"Armature '{obj.name}' not in Pose Mode. Please enter Pose Mode.")
                return {'CANCELLED'}
            sel_bones.extend([pb.bone for pb in obj.pose.bones if pb.bone.select])

        if len(sel_bones) < 1:
            self.report({'WARNING'}, "Select at least one bone in Pose Mode")
            return {'CANCELLED'}

        all_bones = get_bone_hierarchy(sel_bones)

        if self.first_ctrl and all_bones:
            all_bones = all_bones[1:]

        if not all_bones:
            self.report({'WARNING'}, "No bones to bake after skipping first control")
            return {'CANCELLED'}

        CleanUpProc()

        active_arm_obj = context.active_object
        if not active_arm_obj or active_arm_obj.type != 'ARMATURE':
            self.report({'WARNING'}, "Active object must be an armature for baking")
            return {'CANCELLED'}
        if active_arm_obj.mode != 'POSE':
            bpy.ops.object.mode_set(mode='POSE')

        scene = context.scene
        min_frame = scene.frame_start
        max_frame = scene.frame_end

        softness = self.softness
        if self.adaptive_scale:
            adaptive = calculate_adaptive_scale(all_bones, active_arm_obj, min_frame, max_frame)
            softness *= adaptive

        new_action = create_action_and_add_nla(active_arm_obj, f"{active_arm_obj.name}_OverlapHierarchyAction")

        overlap_group = get_or_create_bone_group(active_arm_obj, "Overlapper_BoneGroup")

        for pb in active_arm_obj.pose.bones:
            if pb.bone in all_bones:
                pb.bone_group = overlap_group
            else:
                if hasattr(pb, 'bone_group') and pb.bone_group == overlap_group:
                    pb.bone_group = None

        for index, pb in enumerate(all_bones):
            pose_bone = active_arm_obj.pose.bones.get(pb.name)
            if not pose_bone:
                continue
            orig_x = pose_bone.location.x

            fcurves_to_clear = [fc for fc in new_action.fcurves if fc.data_path == f'pose.bones["{pb.name}"].location' and fc.array_index == 0]
            for fc in fcurves_to_clear:
                fc.keyframe_points.clear()

            for frame in range(min_frame, max_frame + 1):
                bpy.context.scene.frame_set(frame)
                base_val = pose_bone.location.x

                wind_offset = 0
                if self.wind:
                    wind_offset = (noise.noise(frame * 0.1 + index) - 0.5) * 2 * self.wind_scale * self.wind_speed

                new_val = base_val + softness * self.global_scale + wind_offset
                bake_frame = frame + (softness * index)
                if bake_frame > max_frame:
                    bake_frame = max_frame

                pose_bone.location.x = new_val
                pose_bone.keyframe_insert(data_path="location", frame=bake_frame, index=0)

            bpy.context.scene.frame_set(scene.frame_current)
            pose_bone.location.x = orig_x

        if self.cycle:
            for pb in all_bones:
                for fc in new_action.fcurves:
                    if fc.data_path.startswith(f'pose.bones["{pb.name}"].location'):
                        fc.extrapolation = 'Cyclic'

        self.report({'INFO'}, f"Overlapper hierarchy baked on {len(all_bones)} bones.")
        return {'FINISHED'}

class OVERLAPPER_PT_Panel(bpy.types.Panel):
    bl_idname = "OVERLAPPER_PT_panel"
    bl_label = "Overlapper Tool (Bones)"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"
    bl_category = "Overlapper"

    def draw(self, context):
        layout = self.layout
        scn = context.scene

        layout.prop(scn, "overlapper_softness")
        layout.prop(scn, "overlapper_adaptive_scale")
        layout.prop(scn, "overlapper_global_scale")
        layout.prop(scn, "overlapper_wind")
        if scn.overlapper_wind:
            layout.prop(scn, "overlapper_wind_scale")
            layout.prop(scn, "overlapper_wind_speed")
        layout.prop(scn, "overlapper_first_ctrl")
        layout.prop(scn, "overlapper_cycle")

        layout.operator("overlapper.run", text="Overlap Selected Bones")
        layout.operator("overlapper.run_hierarchy", text="Overlap Bone Hierarchy")

classes = (
    OVERLAPPER_OT_RunOverlapper,
    OVERLAPPER_OT_RunOverlapperHierarchy,
    OVERLAPPER_PT_Panel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

    bpy.types.Scene.overlapper_softness = bpy.props.FloatProperty(name="Softness", default=3.0, min=0.0, max=50.0)
    bpy.types.Scene.overlapper_adaptive_scale = bpy.props.BoolProperty(name="Adaptive Scale", default=True)
    bpy.types.Scene.overlapper_global_scale = bpy.props.FloatProperty(name="Scale", default=1.0, min=0.0)
    bpy.types.Scene.overlapper_wind = bpy.props.BoolProperty(name="Wind", default=False)
    bpy.types.Scene.overlapper_wind_scale = bpy.props.FloatProperty(name="Wind Scale", default=1.0, min=0.0)
    bpy.types.Scene.overlapper_wind_speed = bpy.props.FloatProperty(name="Wind Speed", default=1.0, min=0.0)
    bpy.types.Scene.overlapper_first_ctrl = bpy.props.BoolProperty(name="Don't use first control", default=False)
    bpy.types.Scene.overlapper_cycle = bpy.props.BoolProperty(name="Cycle Animation", default=False)

def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)

    del bpy.types.Scene.overlapper_softness
    del bpy.types.Scene.overlapper_adaptive_scale
    del bpy.types.Scene.overlapper_global_scale
    del bpy.types.Scene.overlapper_wind
    del bpy.types.Scene.overlapper_wind_scale
    del bpy.types.Scene.overlapper_wind_speed
    del bpy.types.Scene.overlapper_first_ctrl
    del bpy.types.Scene.overlapper_cycle

if __name__ == "__main__":
    register()
