import bpy
import random

def get_bone_hierarchy(bones):
    hierarchy = set()
    def recurse(bone):
        if bone in hierarchy:
            return
        hierarchy.add(bone)
        for child in bone.children:
            recurse(child)
    for bone in bones:
        recurse(bone)
    return list(hierarchy)

class OVERLAPPER_OT_ApplyOverlap(bpy.types.Operator):
    bl_idname = "overlapper.apply_overlap"
    bl_label = "Apply Overlap Animation"
    bl_description = "Offset animation curves in time progressively on selected bones with optional hierarchy"

    base_offset: bpy.props.IntProperty(name="Base Time Offset", default=3, min=0)
    offset_increment: bpy.props.IntProperty(name="Offset Increment per Bone", default=2, min=0)
    use_hierarchy: bpy.props.BoolProperty(name="Use Hierarchy", default=True)
    channels_to_offset: bpy.props.EnumProperty(
        name="Channels to Offset",
        description="Animation channels to offset",
        items=[
            ('LOC', "Location", "Offset location channels"),
            ('ROT', "Rotation", "Offset rotation channels"),
            ('ALL', "All Channels", "Offset all animation channels"),
        ],
        default='ALL',
    )

    def execute(self, context):
        arm_obj = context.active_object

        if not arm_obj or arm_obj.type != 'ARMATURE':
            self.report({'ERROR'}, "Select an armature and enter Pose Mode")
            return {'CANCELLED'}

        if arm_obj.mode != 'POSE':
            self.report({'ERROR'}, "Armature must be in Pose Mode")
            return {'CANCELLED'}

        sel_bones = [b for b in arm_obj.data.bones if b.select]

        if not sel_bones:
            self.report({'ERROR'}, "Select at least one bone")
            return {'CANCELLED'}

        if self.use_hierarchy:
            bones = get_bone_hierarchy(sel_bones)
        else:
            bones = sel_bones

        bones.sort(key=lambda b: b.name)  # sort to keep order consistent

        action = arm_obj.animation_data.action if arm_obj.animation_data else None
        if not action:
            self.report({'ERROR'}, "Armature has no active animation to offset")
            return {'CANCELLED'}

        for i, bone in enumerate(bones):
            time_offset = self.base_offset + i * self.offset_increment
            bone_name = bone.name

            for fc in action.fcurves:
                if fc.data_path.startswith(f'pose.bones["{bone_name}"].'):
                    if self.channels_to_offset == 'LOC' and 'location' not in fc.data_path:
                        continue
                    if self.channels_to_offset == 'ROT' and 'rotation_euler' not in fc.data_path and 'rotation_quaternion' not in fc.data_path:
                        continue

                    # Offset each keyframe's frame coordinate
                    for kp in fc.keyframe_points:
                        kp.co.x += time_offset
                    fc.update()

        self.report({'INFO'}, f'Applied overlap animation on {len(bones)} bones.')
        return {'FINISHED'}

class OVERLAPPER_PT_Panel(bpy.types.Panel):
    bl_label = "Overlap Animation Tool"
    bl_idname = "OVERLAPPER_PT_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'Overlapper'

    def draw(self, context):
        layout = self.layout
        wm = context.window_manager

        layout.prop(wm, "overlap_base_offset")
        layout.prop(wm, "overlap_offset_increment")
        layout.prop(wm, "overlap_use_hierarchy")
        layout.prop(wm, "overlap_channels_to_offset")

        layout.operator("overlapper.apply_overlap")

def register():
    bpy.utils.register_class(OVERLAPPER_OT_ApplyOverlap)
    bpy.utils.register_class(OVERLAPPER_PT_Panel)

    wm = bpy.types.WindowManager
    wm.overlap_base_offset = bpy.props.IntProperty(name="Base Time Offset", default=3, min=0)
    wm.overlap_offset_increment = bpy.props.IntProperty(name="Offset Increment per Bone", default=2, min=0)
    wm.overlap_use_hierarchy = bpy.props.BoolProperty(name="Use Hierarchy", default=True)
    wm.overlap_channels_to_offset = bpy.props.EnumProperty(
        name="Channels to Offset",
        description="Animation channels to offset",
        items=[
            ('LOC', "Location", "Offset location channels"),
            ('ROT', "Rotation", "Offset rotation channels"),
            ('ALL', "All Channels", "Offset all animation channels"),
        ],
        default='ALL',
    )

def unregister():
    bpy.utils.unregister_class(OVERLAPPER_OT_ApplyOverlap)
    bpy.utils.unregister_class(OVERLAPPER_PT_Panel)

    wm = bpy.types.WindowManager
    del wm.overlap_base_offset
    del wm.overlap_offset_increment
    del wm.overlap_use_hierarchy
    del wm.overlap_channels_to_offset

if __name__ == "__main__":
    register()
