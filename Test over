bl_info = {
    "name": "Overlap Helper (Blender)",
    "author": "Perplexity AI",
    "version": (1, 0, 0),
    "blender": (3, 6, 0),
    "location": "View3D > Sidebar > Overlap Helper",
    "description": "Create overlapping/jiggle motion on bone chains (hair, tails, cloth strips, muscles) with non-physics offsets or physics jiggle; auto chain detection; bake to keyframes.",
    "category": "Animation",
}

import bpy
from bpy.types import Operator, Panel, PropertyGroup
from bpy.props import (
    BoolProperty, EnumProperty, FloatProperty, IntProperty,
    PointerProperty, CollectionProperty, StringProperty
)
from mathutils import Vector, Quaternion, Matrix
import math

# ---------- Utilities ----------

def get_scene_fps(scene):
    fps = scene.render.fps / scene.render.fps_base
    return fps if fps > 0 else 24.0

def iter_bone_chain(arm, pose_bone):
    # Walk down children if there is exactly one deform child repeatedly (simple FK chain)
    chain = [pose_bone]
    pb = pose_bone
    while True:
        children = [c for c in pb.children if True]
        if len(children) != 1:
            break
        pb = children
        chain.append(pb)
    return chain

def discover_chains(context):
    obj = context.object
    if not obj or obj.type != 'ARMATURE':
        return []
    if not obj.mode == 'POSE':
        return []
    sel = [b for b in obj.pose.bones if b.bone.select]
    chains = []
    seen = set()
    for b in sel:
        if b.name in seen:
            continue
        chain = iter_bone_chain(obj, b)
        for c in chain:
            seen.add(c.name)
        if len(chain) >= 2:
            chains.append([p.name for p in chain])
    return chains

def ensure_action(obj, action_name="Overlap_Bake"):
    if not obj.animation_data:
        obj.animation_data_create()
    ad = obj.animation_data
    if not ad.action:
        act = bpy.data.actions.new(action_name)
        ad.action = act
    return ad.action

def get_chain_posebones(obj, names):
    return [obj.pose.bones.get(n) for n in names if obj.pose.bones.get(n) is not None]

# ---------- Non-physics overlap (offset + damping) ----------

def slerp(q1, q2, t):
    return q1.slerp(q2, t)

def lowpass_quat(prev_q, target_q, alpha):
    # Blend prev toward target by alpha
    out = Quaternion(prev_q)
    out = slerp(prev_q, target_q, alpha)
    return out

def apply_nonphysics_overlap(context, obj, chains, start, end, fps, per_bone_delay_frames, rot_damping, pos_damping, affect_loc, affect_rot):
    # Read original animation as target, build filtered/offset values, then bake
    scene = context.scene
    action = ensure_action(obj, "Overlap_Bake")
    # Create FCurves if needed
    # We'll bake by setting evaluated pose each frame and keying
    for chain_names in chains:
        # Build per-bone state
        state_rot = {}
        state_loc = {}
        # per bone effective delay = index * per_bone_delay_frames
        for frame in range(int(start), int(end)+1):
            scene.frame_set(frame)
            for idx, bone_name in enumerate(chain_names):
                pb = obj.pose.bones[bone_name]
                # Get target transforms in bone space (pose space)
                target_rot = pb.rotation_quaternion.copy() if pb.rotation_mode == 'QUATERNION' else pb.matrix.to_quaternion()
                target_loc = pb.location.copy()
                # Initialize state
                if bone_name not in state_rot:
                    state_rot[bone_name] = target_rot.copy()
                if bone_name not in state_loc:
                    state_loc[bone_name] = target_loc.copy()
                # Compute delayed frame to sample from target
                delay = per_bone_delay_frames * idx
                sample_frame = max(int(start), frame - delay)
                if delay > 0:
                    scene.frame_set(sample_frame)
                    pb2 = obj.pose.bones[bone_name]
                    target_rot = pb2.rotation_quaternion.copy() if pb2.rotation_mode == 'QUATERNION' else pb2.matrix.to_quaternion()
                    target_loc = pb2.location.copy()
                    scene.frame_set(frame)
                # Apply damping as low-pass
                if affect_rot:
                    prev = state_rot[bone_name]
                    blended = lowpass_quat(prev, target_rot, rot_damping)
                    state_rot[bone_name] = blended
                    if pb.rotation_mode == 'QUATERNION':
                        pb.rotation_quaternion = blended
                    else:
                        pb.rotation_quaternion = blended
                        pb.rotation_mode = 'QUATERNION'
                if affect_loc:
                    prevl = state_loc[bone_name]
                    newl = prevl.lerp(target_loc, pos_damping)
                    state_loc[bone_name] = newl
                    pb.location = newl
                pb.keyframe_insert(data_path="rotation_quaternion", frame=frame)
                if affect_loc:
                    pb.keyframe_insert(data_path="location", frame=frame)

# ---------- Physics jiggle (mass-spring) ----------

class JiggleBoneState:
    def __init__(self, rest_matrix, pos, vel, mass):
        self.rest_matrix = rest_matrix.copy()
        self.pos = Vector(pos)
        self.vel = Vector(vel)
        self.mass = mass

def apply_physics_overlap(context, obj, chains, start, end, fps, stiffness, damping, gravity, affect_loc, affect_rot, collision_radius):
    scene = context.scene
    dt = 1.0 / fps
    action = ensure_action(obj, "Overlap_Bake")
    # Initialize per-bone states at start frame
    scene.frame_set(int(start))
    states = {}
    for chain_names in chains:
        for bone_name in chain_names:
            pb = obj.pose.bones[bone_name]
            m = pb.matrix.copy()
            head_world = obj.matrix_world @ pb.head
            states[bone_name] = JiggleBoneState(m, head_world, Vector((0,0,0)), mass=1.0)

    for frame in range(int(start), int(end)+1):
        scene.frame_set(frame)
        # Integrate each chain from parent to child so child uses updated parent rest
        for chain_names in chains:
            for idx, bone_name in enumerate(chain_names):
                pb = obj.pose.bones[bone_name]
                st = states[bone_name]
                # Target (spring rest) is current animated head position (so jiggle overlays)
                target = obj.matrix_world @ pb.head
                # Spring force
                k = stiffness
                c = damping
                dir_vec = (target - st.pos)
                force = k * dir_vec - c * st.vel + Vector((0,0,-abs(gravity))) * st.mass
                # Integrate
                acc = force / st.mass
                st.vel = st.vel + acc * dt
                st.pos = st.pos + st.vel * dt
                # Apply back to pose
                # Build a new bone matrix orienting from pos to tail direction
                tail_world = obj.matrix_world @ pb.tail
                rest_dir = (tail_world - (obj.matrix_world @ pb.head)).normalized() if (tail_world - (obj.matrix_world @ pb.head)).length > 1e-6 else Vector((0,1,0))
                new_dir = (tail_world - st.pos)
                if new_dir.length < 1e-6:
                    new_dir = rest_dir
                new_dir = new_dir.normalized()
                # Compute rotation that rotates rest_dir to new_dir
                axis = rest_dir.cross(new_dir)
                angle = max(-math.pi, min(math.pi, math.acos(max(-1.0, min(1.0, rest_dir.dot(new_dir))))))
                if axis.length > 1e-6:
                    rot = Quaternion(axis.normalized(), angle)
                else:
                    rot = Quaternion()
                if affect_rot:
                    pb.rotation_mode = 'QUATERNION'
                    pb.rotation_quaternion = rot @ pb.rotation_quaternion
                if affect_loc:
                    # Move head toward st.pos in local space
                    # Convert desired world head pos to local delta
                    current_head_world = obj.matrix_world @ pb.head
                    delta_world = st.pos - current_head_world
                    # Approximate by adding to location in bone local space (small jiggle effect)
                    local_delta = (obj.matrix_world.inverted() @ Matrix.Translation(delta_world)).to_translation()
                    pb.location += local_delta
                pb.keyframe_insert(data_path="rotation_quaternion", frame=frame)
                if affect_loc:
                    pb.keyframe_insert(data_path="location", frame=frame)

# ---------- Properties ----------

class OH_ChainItem(PropertyGroup):
    name: StringProperty()
    bones: StringProperty()  # comma-separated bone names

class OH_Settings(PropertyGroup):
    mode: EnumProperty(
        name="Mode",
        description="Non-Physics: offset+damping. Physics: jiggle solver.",
        items=[
            ('NONPHYS', "Non-Physics", "Offset per bone with damping"),
            ('PHYS', "Physics", "Mass-spring jiggle"),
        ],
        default='NONPHYS'
    )
    affect_rot: BoolProperty(name="Affect Rotation", default=True)
    affect_loc: BoolProperty(name="Affect Location", default=False)
    start_frame: IntProperty(name="Start", default=1, min=0)
    end_frame: IntProperty(name="End", default=250, min=1)
    # Non-physics params
    per_bone_delay: IntProperty(name="Delay/Step (frames)", default=2, min=0, max=20)
    rot_damping: FloatProperty(name="Rot Damping (0-1)", default=0.25, min=0.0, max=1.0)
    pos_damping: FloatProperty(name="Pos Damping (0-1)", default=0.25, min=0.0, max=1.0)
    # Physics params
    stiffness: FloatProperty(name="Stiffness", default=50.0, min=0.0, max=1000.0)
    damping: FloatProperty(name="Damping", default=5.0, min=0.0, max=1000.0)
    gravity: FloatProperty(name="Gravity", default=9.81, min=-100.0, max=100.0)
    collision_radius: FloatProperty(name="Collider Radius", default=0.02, min=0.0, max=1.0)
    # Chains
    chains: CollectionProperty(type=OH_ChainItem)
    active_chain: IntProperty(name="Active Chain", default=0, min=0)

# ---------- Operators ----------

class OH_OT_DetectChains(Operator):
    bl_idname = "oh.detect_chains"
    bl_label = "Detect Chains"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        props = context.scene.oh_settings
        props.chains.clear()
        chains = discover_chains(context)
        for ch in chains:
            item = props.chains.add()
            item.name = f"Chain: {ch} -> {ch[-1]}"
            item.bones = ",".join(ch)
        self.report({'INFO'}, f"Detected {len(props.chains)} chains.")
        return {'FINISHED'}

class OH_OT_ApplyOverlap(Operator):
    bl_idname = "oh.apply_overlap"
    bl_label = "Apply Overlap (Preview/Bake)"
    bl_options = {'REGISTER', 'UNDO'}

    preview_only: BoolProperty(default=True)

    def execute(self, context):
        obj = context.object
        if not obj or obj.type != 'ARMATURE':
            self.report({'ERROR'}, "Select an armature in Pose Mode.")
            return {'CANCELLED'}
        props = context.scene.oh_settings
        if len(props.chains) == 0:
            self.report({'ERROR'}, "No chains detected.")
            return {'CANCELLED'}
        chains = []
        for item in props.chains:
            bones = [b for b in item.bones.split(",") if b]
            if bones:
                chains.append(bones)
        fps = get_scene_fps(context.scene)
        if props.mode == 'NONPHYS':
            apply_nonphysics_overlap(
                context, obj, chains,
                props.start_frame, props.end_frame, fps,
                props.per_bone_delay, props.rot_damping, props.pos_damping,
                props.affect_loc, props.affect_rot
            )
        else:
            apply_physics_overlap(
                context, obj, chains,
                props.start_frame, props.end_frame, fps,
                props.stiffness, props.damping, props.gravity,
                props.affect_loc, props.affect_rot, props.collision_radius
            )
        return {'FINISHED'}

class OH_OT_BakeOnly(Operator):
    bl_idname = "oh.bake_overlap"
    bl_label = "Bake to Keyframes"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        # Baking is already performed by Apply operators via keyframe_insert per frame.
        self.report({'INFO'}, "Overlap baked to keyframes in active action.")
        return {'FINISHED'}

# ---------- UI Panel ----------

class OH_PT_Panel(Panel):
    bl_label = "Overlap Helper"
    bl_idname = "OH_PT_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Overlap Helper"

    def draw(self, context):
        layout = self.layout
        props = context.scene.oh_settings

        col = layout.column(align=True)
        col.label(text="Detection")
        row = col.row(align=True)
        row.operator("oh.detect_chains", text="Detect Chains")

        col.separator()
        col.label(text="Chains")
        if len(props.chains) == 0:
            col.label(text="No chains detected")
        else:
            for i, item in enumerate(props.chains):
                box = col.box()
                box.label(text=item.name)
                box.label(text=item.bones)

        col.separator()
        col.label(text="Mode")
        col.prop(props, "mode", expand=True)
        col.prop(props, "affect_rot")
        col.prop(props, "affect_loc")
        col.prop(props, "start_frame")
        col.prop(props, "end_frame")

        if props.mode == 'NONPHYS':
            col.separator()
            col.label(text="Non-Physics Settings")
            col.prop(props, "per_bone_delay")
            col.prop(props, "rot_damping")
            col.prop(props, "pos_damping")
        else:
            col.separator()
            col.label(text="Physics Settings")
            col.prop(props, "stiffness")
            col.prop(props, "damping")
            col.prop(props, "gravity")
            col.prop(props, "collision_radius")

        col.separator()
        col.operator("oh.apply_overlap", text="Apply Overlap (Preview/Bake)")
        col.operator("oh.bake_overlap", text="Bake to Keyframes")

classes = (
    OH_ChainItem,
    OH_Settings,
    OH_OT_DetectChains,
    OH_OT_ApplyOverlap,
    OH_OT_BakeOnly,
    OH_PT_Panel,
)

def register():
    for c in classes:
        bpy.utils.register_class(c)
    bpy.types.Scene.oh_settings = PointerProperty(type=OH_Settings)

def unregister():
    for c in reversed(classes):
        bpy.utils.unregister_class(c)
    del bpy.types.Scene.oh_settings

if __name__ == "__main__":
    register()
