bl_info = {
    "name": "Anim Lattice - WORKING",
    "author": "Your Name", 
    "version": (2, 0, 0),
    "blender": (5, 0, 0),
    "location": "Graph Editor > Sidebar (N) > Anim Lattice",
    "description": "Bounding box keyframe manipulation - WORKS IN BLENDER 5.0",
    "category": "Animation",
}

import bpy
import bmesh
from mathutils import Vector
from bpy.props import FloatProperty, BoolProperty

def get_selected_keyframes():
    """CORRECT way to get Graph Editor selected keyframes - works in Blender 5.0"""
    keyframes = []
    
    # Get ALL actions in the scene (Graph Editor shows all animated objects)
    for obj in bpy.context.scene.objects:
        if obj.animation_data and obj.animation_data.action:
            action = obj.animation_data.action
            for fcurve in action.fcurves:
                # Skip hidden/locked curves
                if fcurve.hide or fcurve.lock:
                    continue
                for point in fcurve.keyframe_points:
                    # Check if keyframe is SELECTED (this is the key!)
                    if point.select_control_point:
                        keyframes.append({
                            'fcurve': fcurve,
                            'point': point,
                            'co': point.co.copy(),
                            'handle_left': point.handle_left.copy(),
                            'handle_right': point.handle_right.copy()
                        })
    return keyframes

class ANIMLATTICE_OT_scale_time(bpy.types.Operator):
    """Scale selected keyframes time proportionally"""
    bl_idname = "animlattice.scale_time"
    bl_label = "Scale Time"
    bl_options = {'REGISTER', 'UNDO'}
    
    scale_factor: FloatProperty(default=1.0, min=0.1, max=5.0)
    
    def execute(self, context):
        keyframes = get_selected_keyframes()
        if not keyframes:
            self.report({'WARNING'}, "No keyframes selected!")
            return {'CANCELLED'}
        
        # Calculate bounding box center
        times = [kf['co'][0] for kf in keyframes]
        center_time = sum(times) / len(times)
        
        # Scale around center
        for kf in keyframes:
            point = kf['point']
            old_time = kf['co'][0]
            new_time = center_time + (old_time - center_time) * self.scale_factor
            
            # Move keyframe
            point.co[0] = new_time
            
            # Move handles proportionally
            delta_time = new_time - old_time
            point.handle_left[0] += delta_time
            point.handle_right[0] += delta_time
        
        # Update curves
        for kf in keyframes:
            kf['fcurve'].update()
        
        context.area.tag_redraw()
        self.report({'INFO'}, f"Scaled {len(keyframes)} keyframes time by {self.scale_factor:.2f}x")
        return {'FINISHED'}

class ANIMLATTICE_OT_scale_value(bpy.types.Operator):
    """Scale selected keyframes values proportionally"""
    bl_idname = "animlattice.scale_value"
    bl_label = "Scale Value"
    bl_options = {'REGISTER', 'UNDO'}
    
    scale_factor: FloatProperty(default=1.0, min=0.1, max=5.0)
    
    def execute(self, context):
        keyframes = get_selected_keyframes()
        if not keyframes:
            self.report({'WARNING'}, "No keyframes selected!")
            return {'CANCELLED'}
        
        # Calculate bounding box center
        values = [kf['co'][1] for kf in keyframes]
        center_value = sum(values) / len(values)
        
        # Scale around center
        for kf in keyframes:
            point = kf['point']
            old_value = kf['co'][1]
            new_value = center_value + (old_value - center_value) * self.scale_factor
            
            point.co[1] = new_value
        
        for kf in keyframes:
            kf['fcurve'].update()
        
        context.area.tag_redraw()
        self.report({'INFO'}, f"Scaled {len(keyframes)} keyframes values by {self.scale_factor:.2f}x")
        return {'FINISHED'}

class ANIMLATTICE_OT_retime_range(bpy.types.Operator):
    """Retime selected keyframes to fit frame range"""
    bl_idname = "animlattice.retime_range"
    bl_label = "Retime to Range"
    bl_options = {'REGISTER', 'UNDO'}
    
    target_frames: FloatProperty(
        name="Target Frames", 
        default=24.0,
        min=1.0, max=1000.0
    )
    
    def execute(self, context):
        keyframes = get_selected_keyframes()
        if not keyframes:
            self.report({'WARNING'}, "No keyframes selected!")
            return {'CANCELLED'}
        
        # Get current time range
        times = [kf['co'][0] for kf in keyframes]
        min_time, max_time = min(times), max(times)
        current_range = max_time - min_time
        
        scale_factor = self.target_frames / current_range
        
        # Use scale_time operator
        bpy.ops.animlattice.scale_time('INVOKE_DEFAULT', scale_factor=scale_factor)
        
        return {'FINISHED'}

class ANIMLATTICE_PT_panel(bpy.types.Panel):
    bl_label = "Anim Lattice"
    bl_idname = "ANIMLATTICE_PT_panel"
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = "Anim Lattice"
    
    def draw(self, context):
        layout = self.layout
        
        # Show selected keyframe count
        kf_count = len(get_selected_keyframes())
        box = layout.box()
        box.prop(context.space_data, "show_only_selected", text="Only Selected")
        box.label(text=f"Keys: {kf_count}", icon='KEY_HLT' if kf_count else 'INFO')
        
        if kf_count == 0:
            box.label(text="1. Select object with keyframes", icon='INFO')
            box.label(text="2. Go to Graph Editor", icon='INFO')
            box.label(text="3. B = Box select keyframes", icon='INFO')
            return
        
        # Time Scaling (Horizontal - Retiming)
        box = layout.box()
        box.label(text="Time Scaling", icon='TIME')
        col = box.column(align=True)
        
        row = col.row(align=True)
        row.operator("animlattice.scale_time", text="Fast (0.8x)").scale_factor = 0.8
        row.operator("animlattice.scale_time", text="Slow (1.2x)").scale_factor = 1.2
        
        row = col.row(align=True)
        row.operator("animlattice.scale_time", text="×0.5").scale_factor = 0.5
        row.operator("animlattice.scale_time", text="×2").scale_factor = 2.0
        
        # Value Scaling (Vertical - Amplitude)
        box = layout.box()
        box.label(text="Value Scaling", icon='DRIVER_DISTANCE')
        col = box.column(align=True)
        
        row = col.row(align=True)
        row.operator("animlattice.scale_value", text="Small (0.8x)").scale_factor = 0.8
        row.operator("animlattice.scale_value", text="Big (1.2x)").scale_factor = 1.2
        
        row = col.row(align=True)
        row.operator("animlattice.scale_value", text="×0.5").scale_factor = 0.5
        row.operator("animlattice.scale_value", text="×2").scale_factor = 2.0
        
        # Retime to exact frames
        box = layout.box()
        box.label(text="Retime Range", icon='SEQ_SEQUENCER')
        row = box.row()
        row.prop(context.scene, "frame_end", text="To Frame")
        row.operator("animlattice.retime_range", text="Fit")

# Register
classes = (
    ANIMLATTICE_OT_scale_time,
    ANIMLATTICE_OT_scale_value,
    ANIMLATTICE_OT_retime_range,
    ANIMLATTICE_PT_panel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

if __name__ == "__main__":
    register()
