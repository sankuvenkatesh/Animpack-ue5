"""
Anim Lattice - Graph Editor Keyframe Lattice Deformer
Blender 5.0 Compatible Single-File Addon (Fixed Registration)
"""

import bpy
from bpy.types import Scene
import gpu
import blf
import math
from math import radians, degrees, pi, cos, sin
import numpy as np
from gpu_extras.batch import batch_for_shader

# Global addon state
_is_running = False
_handle = None

def draw_circle(shader, center, radius, color, num_segments=16):
    """Draw circle using triangle fan."""
    vertices = []
    for i in range(num_segments + 1):
        angle = 2 * pi * i / num_segments
        x = center[0] + radius * cos(angle)
        y = center[1] + radius * sin(angle)
        vertices.append((x, y))
    
    batch = batch_for_shader(shader, 'TRI_FAN', {"pos": vertices})
    shader.bind()
    shader.uniform_float("color", color)
    batch.draw(shader)

def draw_rhomboid(shader, center, size, color):
    """Draw rhomboid shape."""
    half = size / 2
    x, y = center
    vertices = [
        (x, y + half),
        (x + half, y),
        (x, y - half),
        (x - half, y),
        (x, y + half),  # Close the shape
    ]
    batch = batch_for_shader(shader, 'TRI_FAN', {"pos": vertices})
    shader.bind()
    shader.uniform_float("color", color)
    batch.draw(shader)

def draw_gui_help_text(context, x, y):
    """Draw help text overlay."""
    props = context.scene.keyframe_lattice_settings
    
    lines = [
        "______________________",
        "Anim Lattice Help:",
        "______________________",
        "",
        "Drag Control points to scale",
        "",
        "______________________",
        "Snap to Full Frames (F)",
        "______________________",
        "",
        "ESC/Enter/Right Click - Exit",
        "Ctrl+Z = Undo"
    ]
    
    if props.snap_lattice_to_full_frames:
        lines[7] = "Snap to Full Frames (F) - Enabled"
    else:
        lines[7] = "Snap to Full Frames (F) - Disabled"
    
    blf.enable(0, blf.SHADOW)
    blf.shadow(0, 6, 0, 0, 0, 1)
    blf.shadow_offset(0, 2, -2)
    font_id = 0
    blf.size(font_id, 12)
    blf.color(font_id, 1.0, 1.0, 1.0, 1.0)
    
    for line in reversed(lines):
        text_width, text_height = blf.dimensions(font_id, line)
        blf.position(font_id, x, y, 0)
        blf.draw(font_id, line)
        y += text_height + 5
    
    blf.disable(0, blf.SHADOW)

class ControlPoint:
    def __init__(self, index, position, operator, shape="square", section=(0, 0)):
        self.index = index
        self.position = position
        self.size = 10
        self.is_hovered = False
        self.shape = shape
        self.section = section
        self.operator = operator

    def draw(self):
        cp_color = (1.0, 0.5, 0.0, 1.0) if self.is_hovered else (1.0, 1.0, 1.0, 1.0)
        screen_pos = self.operator.graph_to_screen(*self.position)
        
        shader = gpu.shader.from_builtin("UNIFORM_COLOR")
        
        if self.shape == "circle":
            draw_circle(shader, screen_pos, self.size / 2, cp_color)
        elif self.shape == "rhomboid":
            draw_rhomboid(shader, screen_pos, self.size, cp_color)
        else:  # square
            half_size = self.size / 2
            x, y = screen_pos
            vertices = [
                (x - half_size, y - half_size),
                (x + half_size, y - half_size),
                (x + half_size, y + half_size),
                (x - half_size, y + half_size),
                (x - half_size, y - half_size),  # Close shape
            ]
            batch = batch_for_shader(shader, 'TRI_FAN', {"pos": vertices})
            shader.bind()
            shader.uniform_float("color", cp_color)
            batch.draw(shader)

    def check_hover(self, mouse_x, mouse_y):
        screen_x, screen_y = self.operator.graph_to_screen(*self.position)
        half_size = self.size / 2
        
        is_now_hovered = (
            screen_x - half_size <= mouse_x <= screen_x + half_size and
            screen_y - half_size <= mouse_y <= screen_y + half_size
        )
        
        hovered = False
        if is_now_hovered and not self.is_hovered:
            self.is_hovered = True
            bpy.context.window.cursor_set("SCROLL_XY")
            hovered = True
        elif not is_now_hovered and self.is_hovered:
            self.is_hovered = False
            bpy.context.window.cursor_set("DEFAULT")
        return hovered

class LoopControlPoint(ControlPoint):
    def __init__(self, index, position, operator, orientation="horizontal", 
                 associated_cp=None, section=(0, 0)):
        super().__init__(index, position, operator, shape="rhomboid", section=section)
        self.orientation = orientation
        self.associated_cp = associated_cp
        self.display_distance = self.size * 20
        self.is_displayed = False

    def draw(self):
        if not self.is_displayed:
            return
        super().draw()

    def check_hover(self, mouse_x, mouse_y):
        screen_x, screen_y = self.operator.graph_to_screen(*self.position)
        display_half_size = self.display_distance / 2
        mouse_distance = math.hypot(mouse_x - screen_x, mouse_y - screen_y)
        
        if mouse_distance <= display_half_size:
            self.is_displayed = True
        else:
            self.is_displayed = False
            self.is_hovered = False
            return False
        
        return super().check_hover(mouse_x, mouse_y)

# FIXED: Proper PropertyGroup definition
class AMPPGAnimLatticeSettings(bpy.types.PropertyGroup):
    snap_lattice_to_full_frames: bpy.props.BoolProperty(
        name="Snap to Full Frames",
        description="Snap keyframe frames to nearest integer value",
        default=True,
    )
    display_values: bpy.props.BoolProperty(
        name="Display Values",
        description="Display values of the control points",
        default=False,
    )
    mode: bpy.props.EnumProperty(
        name="Mode",
        description="Mode of the lattice",
        items=[
            ("NORMAL", "Normal", "Bounding box scaling"),
            ("WARP", "Warp", "Grid deformation"),
        ],
        default="NORMAL",
    )
    lattice_x: bpy.props.IntProperty(
        name="Lattice X",
        description="Number of divisions in the X-axis",
        default=2,
        min=1,
        max=10,
    )
    lattice_y: bpy.props.IntProperty(
        name="Lattice Y",
        description="Number of divisions in the Y-axis",
        default=2,
        min=1,
        max=10,
    )
    lock_direction: bpy.props.BoolProperty(
        name="Lock Direction",
        description="Lock movement to dominant axis",
        default=False,
    )

class AMP_OT_anim_lattice(bpy.types.Operator):
    bl_idname = "anim.amp_anim_lattice"
    bl_label = "Anim Lattice"
    bl_options = {'REGISTER'}
    bl_description = "Drag control points to scale keyframes proportionally within bounding box"

    VERTICAL_PADDING = 0.0001
    HORIZONTAL_PADDING = 1

    def __init__(self):
        self.current_mode = "NORMAL"
        self.previous_lattice_x = 2
        self.previous_lattice_y = 2
        self.control_points = []
        self.loop_control_points = []
        self.mouse_x = 0
        self.mouse_y = 0
        self.mouse_graph_x = 0.0
        self.mouse_graph_y = 0.0
        self.dragging_control_point = None
        self.initial_mouse_x = 0
        self.initial_mouse_y = 0
        self.initial_mouse_graph_x = 0.0
        self.initial_mouse_graph_y = 0.0
        self.initial_bounds = None
        self.initial_control_point_positions = {}
        self.fcurves_to_update = set()
        self.undo_stack = []
        self.context = None
        self.initial_co_array = None
        self.indices_array = None
        self.fcurves_array = None
        self.is_rotation_curve_array = None
        self.relative_co = None
        self.initial_use_normalization = False
        self._handle = None

    @classmethod
    def poll(cls, context):
        return (context.area and context.area.type == 'GRAPH_EDITOR')

    def invoke(self, context, event):
        if event.shift:
            return context.window_manager.invoke_props_dialog(self)
        return self.execute(context)

    def init_tool(self, context):
        self.context = context
        self.collect_initial_keyframe_data()
        
        if len(self.initial_co_array) == 0:
            self.report({'WARNING'}, "No keyframes selected")
            return {'CANCELLED'}
        
        self.initial_bounds = self.get_initial_bounds()
        if not self.initial_bounds:
            self.report({'WARNING'}, "Unable to determine keyframe bounds")
            return {'CANCELLED'}
        
        self.compute_relative_positions()
        self.init_control_points(context)
        
        args = (self, context)
        self._handle = bpy.types.SpaceGraphEditor.draw_handler_add(
            self.draw_callback, args, 'WINDOW', 'POST_PIXEL')
        context.area.tag_redraw()
        self.push_undo(context)
        return {'RUNNING_MODAL'}

    def graph_to_screen(self, graph_x, graph_y):
        view2d = self.context.region.view2d
        screen_x, screen_y = view2d.view_to_region(graph_x, graph_y, clip=False)
        return screen_x, screen_y

    def screen_to_graph(self, screen_x, screen_y):
        view2d = self.context.region.view2d
        gx, gy = view2d.region_to_view(screen_x, screen_y)
        return gx, gy

    def push_undo(self, context):
        if len(self.undo_stack) == 0:
            return
        
        state = self.undo_stack[-1].copy()
        self.undo_stack.append(state)

    def init_control_points(self, context):
        min_x, max_x, min_y, max_y = self.initial_bounds
        props = context.scene.keyframe_lattice_settings
        
        self.control_points = []
        self.loop_control_points = []
        
        if props.mode == "WARP":
            lattice_x = props.lattice_x
            lattice_y = props.lattice_y
            index_counter = 0
            for row in range(lattice_y + 1):
                for col in range(lattice_x + 1):
                    u = col / lattice_x if lattice_x != 0 else 0.0
                    v = row / lattice_y if lattice_y != 0 else 0.0
                    x = min_x + u * (max_x - min_x)
                    y = min_y + v * (max_y - min_y)
                    self.control_points.append(
                        ControlPoint(index_counter, (x, y), self, shape="circle", section=(row, col)))
                    index_counter += 1
        else:
            positions = [
                (0, (min_x, min_y)),   # Bottom-left
                (1, (max_x, min_y)),   # Bottom-right
                (2, (max_x, max_y)),   # Top-right
                (3, (min_x, max_y)),   # Top-left
                (4, ((min_x + max_x)/2, min_y)),     # Bottom mid
                (5, (max_x, (min_y + max_y)/2)),     # Right mid
                (6, ((min_x + max_x)/2, max_y)),     # Top mid
                (7, (min_x, (min_y + max_y)/2)),     # Left mid
            ]
            self.control_points = [ControlPoint(index, pos, self) for index, pos in positions]

    def modal(self, context, event):
        props = context.scene.keyframe_lattice_settings
        
        # Mode/lattice change handling
        if (props.mode != self.current_mode or 
            (props.mode == "WARP" and 
             (props.lattice_x != self.previous_lattice_x or props.lattice_y != self.previous_lattice_y))):
            self.current_mode = props.mode
            self.previous_lattice_x = props.lattice_x
            self.previous_lattice_y = props.lattice_y
            self.init_control_points(context)
            context.area.tag_redraw()
        
        self.previous_lattice_x = props.lattice_x
        self.previous_lattice_y = props.lattice_y
        
        # Exit conditions
        if event.type in {'ESC', 'RET'} and event.value == 'PRESS':
            return self.cancel(context)
        
        if event.type == 'RIGHTMOUSE' and event.value == 'PRESS':
            context.window.cursor_modal_set('DEFAULT')
            return {'RUNNING_MODAL'}
        
        # Mouse move
        if event.type == 'MOUSEMOVE':
            self.mouse_x = event.mouse_region_x
            self.mouse_y = event.mouse_region_y
            self.mouse_graph_x, self.mouse_graph_y = self.screen_to_graph(
                self.mouse_x, self.mouse_y)
            
            if self.dragging_control_point is not None:
                self.handle_mouse_move_drag(context, event)
            else:
                self.handle_mouse_move_hover(context, event)
            context.area.tag_redraw()
            return {'PASS_THROUGH'}
        
        # Drag start
        if event.type == 'LEFTMOUSE' and event.value == 'PRESS':
            for cp in self.control_points + self.loop_control_points:
                if cp.check_hover(self.mouse_x, self.mouse_y):
                    context.window.cursor_set('SCROLL_XY')
                    self.dragging_control_point = cp.index
                    self.initial_mouse_x = event.mouse_region_x
                    self.initial_mouse_y = event.mouse_region_y
                    self.initial_mouse_graph_x, self.initial_mouse_graph_y = self.screen_to_graph(
                        self.initial_mouse_x, self.initial_mouse_y)
                    self.initial_control_point_positions = {
                        cp.index: cp.position for cp in self.control_points + self.loop_control_points
                    }
                    context.area.tag_redraw()
                    return {'RUNNING_MODAL'}
        
        # Drag end
        if event.type == 'LEFTMOUSE' and event.value == 'RELEASE':
            context.window.cursor_set('DEFAULT')
            self.dragging_control_point = None
            context.area.tag_redraw()
            return {'RUNNING_MODAL'}
        
        # Toggle snap
        if event.type == 'F' and event.value == 'PRESS':
            props.snap_lattice_to_full_frames = not props.snap_lattice_to_full_frames
            context.area.tag_redraw()
            return {'RUNNING_MODAL'}
        
        # Undo
        if (event.type == 'Z' and (event.ctrl or event.oskey)) and event.value == 'PRESS':
            self.pop_undo(context)
            context.area.tag_redraw()
            return {'RUNNING_MODAL'}
        
        context.area.tag_redraw()
        return {'PASS_THROUGH'}

    def handle_mouse_move_hover(self, context, event):
        for cp in self.control_points + self.loop_control_points:
            cp.check_hover(self.mouse_x, self.mouse_y)

    def handle_mouse_move_drag(self, context, event):
        cp = next((c for c in self.control_points + self.loop_control_points 
                  if c.index == self.dragging_control_point), None)
        if not cp:
            return
        
        delta_x = self.mouse_graph_x - self.initial_mouse_graph_x
        delta_y = self.mouse_graph_y - self.initial_mouse_graph_y
        
        self.handle_drag(cp, delta_x, delta_y)
        self.update_keyframes(context)

    def handle_drag(self, cp, delta_x, delta_y):
        ix, iy = self.initial_control_point_positions[cp.index]
        cp.position = (ix + delta_x, iy + delta_y)

    def execute(self, context):
        if _is_running:
            return self.cancel(context)
        
        self.initial_use_normalization = context.space_data.use_normalization
        if self.initial_use_normalization:
            context.space_data.use_normalization = False
        
        bpy.ops.graph.view_selected()
        result = self.init_tool(context)
        if result == {'CANCELLED'}:
            return result
        
        context.window_manager.modal_handler_add(self)
        global _is_running
        _is_running = True
        return {'RUNNING_MODAL'}

    def cancel(self, context):
        global _is_running
        _is_running = False
        
        if self.initial_use_normalization:
            context.space_data.use_normalization = True
        
        if self._handle is not None:
            bpy.types.SpaceGraphEditor.draw_handler_remove(self._handle, 'WINDOW')
            self._handle = None
        
        if context.area:
            context.area.tag_redraw()
        return {'CANCELLED'}

    def draw_callback(self, _self, context):
        props = context.scene.keyframe_lattice_settings
        shader = gpu.shader.from_builtin("UNIFORM_COLOR")
        gpu.state.blend_set('ALPHA')
        
        # Draw bounding box (NORMAL mode)
        if props.mode == "NORMAL" and len(self.control_points) >= 4:
            corners = [self.graph_to_screen(*self.control_points[i].position) 
                      for i in [0,1,2,3] if i < len(self.control_points)]
            if len(corners) == 4:
                batch = batch_for_shader(shader, 'LINE_LOOP', {"pos": corners})
                shader.bind()
                shader.uniform_float("color", (1.0, 1.0, 1.0, 1.0))
                batch.draw(shader)
        
        # Draw control points
        for cp in self.control_points + getattr(self, 'loop_control_points', []):
            cp.draw()
        
        # Draw help
        draw_gui_help_text(context, 30, 40)
        gpu.state.blend_set('NONE')

    def collect_initial_keyframe_data(self):
        selected_fcurves = bpy.context.selected_editable_fcurves
        
        fcurves_list = []
        indices_list = []
        is_rotation_list = []
        co_list = []
        
        for fcurve in selected_fcurves:
            for idx, kf in enumerate(fcurve.keyframe_points):
                if kf.select_control_point:
                    self.fcurves_to_update.add(fcurve)
                    # Simple rotation check
                    is_rot = 'rotation' in fcurve.data_path.lower()
                    
                    y_val = degrees(kf.co[1]) if is_rot else kf.co[1]
                    
                    fcurves_list.append(fcurve)
                    indices_list.append(idx)
                    is_rotation_list.append(is_rot)
                    co_list.append([kf.co[0], y_val])
        
        self.fcurves_array = np.array(fcurves_list, dtype=object)
        self.indices_array = np.array(indices_list, dtype=int)
        self.is_rotation_curve_array = np.array(is_rotation_list, dtype=bool)
        self.initial_co_array = np.array(co_list, dtype=float)

    def compute_relative_positions(self):
        min_x, max_x, min_y, max_y = self.initial_bounds
        
        denom_x = max_x - min_x if max_x != min_x else 1.0
        denom_y = max_y - min_y if max_y != min_y else 1.0
        
        u = (self.initial_co_array[:, 0] - min_x) / denom_x
        v = (self.initial_co_array[:, 1] - min_y) / denom_y
        
        self.relative_co = np.column_stack((u, v))

    def get_initial_bounds(self):
        if len(self.initial_co_array) == 0:
            return None
        return (
            np.min(self.initial_co_array[:, 0]),
            np.max(self.initial_co_array[:, 0]),
            np.min(self.initial_co_array[:, 1]),
            np.max(self.initial_co_array[:, 1]),
        )

    def update_keyframes(self, context):
        props = context.scene.keyframe_lattice_settings
        
        if props.mode != "NORMAL" or self.dragging_control_point is None:
            return
        
        min_x0, max_x0, min_y0, max_y0 = self.initial_bounds
        cp_pos = {cp.index: cp.position for cp in self.control_points}
        
        # Update bounds based on dragged point
        min_x, max_x, min_y, max_y = min_x0, max_x0, min_y0, max_y0
        
        drag_idx = self.dragging_control_point
        if drag_idx in [1, 2, 5]:  # Right
            max_x = cp_pos[drag_idx][0]
        if drag_idx in [2, 3, 6]:  # Top
            max_y = cp_pos[drag_idx][1]
        if drag_idx in [0, 3, 7]:  # Left
            min_x = cp_pos[drag_idx][0]
        if drag_idx in [0, 1, 4]:  # Bottom
            min_y = cp_pos[drag_idx][1]
        
        # Apply padding
        if max_x - min_x < self.HORIZONTAL_PADDING:
            max_x = min_x + self.HORIZONTAL_PADDING
        if max_y - min_y < self.VERTICAL_PADDING:
            max_y = min_y + self.VERTICAL_PADDING
        
        denom_x = max_x - min_x
        denom_y = max_y - min_y
        
        new_x = min_x + self.relative_co[:, 0] * denom_x
        new_y = min_y + self.relative_co[:, 1] * denom_y
        
        if props.snap_lattice_to_full_frames:
            new_x = np.round(new_x)
        
        # Update keyframes
        for i in range(len(self.indices_array)):
            fcurve = self.fcurves_array[i]
            idx = self.indices_array[i]
            kf = fcurve.keyframe_points[idx]
            is_rot = self.is_rotation_curve_array[i]
            
            kf.co[0] = new_x[i]
            kf.co[1] = radians(new_y[i]) if is_rot else new_y[i]

    def pop_undo(self, context):
        if len(self.undo_stack) < 2:
            self.report({'INFO'}, "Nothing to undo")
            return
        self.undo_stack.pop()
        context.area.tag_redraw()

class AMP_PT_AnimLatticeOptions(bpy.types.Panel):
    bl_label = "Anim Lattice"
    bl_idname = "AMP_PT_AnimLatticeOptions"
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = "Anim Lattice"

    def draw(self, context):
        layout = self.layout
        props = context.scene.keyframe_lattice_settings
        layout.use_property_split = True
        
        layout.prop(props, "mode")
        if props.mode == "WARP":
            col = layout.column()
            col.prop(props, "lattice_x")
            col.prop(props, "lattice_y")
        layout.prop(props, "snap_lattice_to_full_frames")
        layout.prop(props, "lock_direction")

# FIXED: Proper registration order
classes = [
    AMPPGAnimLatticeSettings,
    AMP_OT_anim_lattice,
    AMP_PT_AnimLatticeOptions,
]

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    # CRITICAL: Register pointer AFTER PropertyGroup
    Scene.keyframe_lattice_settings = bpy.props.PointerProperty(
        type=AMPPGAnimLatticeSettings
    )

def unregister():
    # CRITICAL: Remove pointer BEFORE unregistering classes
    if hasattr(Scene, 'keyframe_lattice_settings'):
        del Scene.keyframe_lattice_settings
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

if __name__ == "__main__":
    register()
