"""
Anim Lattice - Graph Editor Keyframe Lattice Deformer
Blender 5.0 Compatible Single-File Addon
Select keyframes → Run operator → Drag control points to deform
"""

import bpy
import gpu
import blf
import math
from math import radians
import numpy as np
from gpu_extras.batch import batch_for_shader

# Global addon state
_is_running = False
_handle = None

def draw_circle(shader, center, radius, color):
    """Draw circle using triangle fan."""
    segments = 16
    vertices = []
    for i in range(segments + 1):
        angle = 2 * math.pi * i / segments
        x = center[0] + radius * math.cos(angle)
        y = center[1] + radius * math.sin(angle)
        vertices.append((x, y))
    
    batch = batch_for_shader(shader, 'TRI_FAN', {"pos": vertices})
    shader.bind()
    shader.uniform_float("color", color)
    batch.draw(shader)

def draw_rhomboid(shader, center, size, color):
    """Draw rhomboid shape."""
    half = size / 2
    x, y = center
    vertices = [
        (x, y + half),
        (x + half, y),
        (x, y - half),
        (x - half, y),
    ]
    batch = batch_for_shader(shader, 'TRI_FAN', {"pos": vertices})
    shader.bind()
    shader.uniform_float("color", color)
    batch.draw(shader)

def draw_gui_help_text(context, x, y):
    """Draw help text overlay."""
    props = context.scene.keyframe_lattice_settings
    
    lines = [
        "______________________",
        "Anim Lattice Help:",
        "______________________",
        "",
        "Drag Control points to scale",
        "",
        "______________________",
        "Snap to Full Frames (F)",
        "______________________",
        "",
        "ESC/Enter/Right Click - Exit"
    ]
    
    if props.snap_lattice_to_full_frames:
        lines[7] = "Snap to Full Frames (F) - Enabled"
    else:
        lines[7] = "Snap to Full Frames (F) - Disabled"
    
    blf.enable(0, blf.SHADOW)
    blf.shadow(0, 6, 0, 0, 0, 1)
    blf.shadow_offset(0, 2, -2)
    font_id = 0
    blf.size(font_id, 12)
    blf.color(font_id, 1.0, 1.0, 1.0, 1.0)
    
    for line in reversed(lines):
        text_width, text_height = blf.dimensions(font_id, line)
        blf.position(font_id, x, y, 0)
        blf.draw(font_id, line)
        y += text_height + 5
    
    blf.disable(0, blf.SHADOW)

class ControlPoint:
    def __init__(self, index, position, operator, shape="square", section=(0, 0), *args, **kwargs):
        self.index = index
        self.position = position
        self.size = 10
        self.is_hovered = False
        self.shape = shape
        self.section = section
        self.operator = operator

    def draw(self):
        cp_color = (1.0, 0.5, 0.0, 1.0) if self.is_hovered else (1.0, 1.0, 1.0, 1.0)
        screen_pos = self.operator.graph_to_screen(*self.position)
        
        shader = gpu.shader.from_builtin("UNIFORM_COLOR")
        
        if self.shape == "circle":
            draw_circle(shader, screen_pos, self.size / 2, cp_color)
        elif self.shape == "rhomboid":
            draw_rhomboid(shader, screen_pos, self.size, cp_color)
        else:
            half_size = self.size / 2
            x, y = screen_pos
            vertices = [
                (x - half_size, y - half_size),
                (x + half_size, y - half_size),
                (x + half_size, y + half_size),
                (x - half_size, y + half_size),
            ]
            batch = batch_for_shader(shader, 'TRI_FAN', {"pos": vertices})
            shader.bind()
            shader.uniform_float("color", cp_color)
            batch.draw(shader)

    def check_hover(self, mouse_x, mouse_y):
        screen_x, screen_y = self.operator.graph_to_screen(*self.position)
        half_size = self.size / 2
        
        is_now_hovered = (
            screen_x - half_size <= mouse_x <= screen_x + half_size and
            screen_y - half_size <= mouse_y <= screen_y + half_size
        )
        
        hovered = False
        if is_now_hovered and not self.is_hovered:
            self.is_hovered = True
            bpy.context.window.cursor_set("SCROLL_XY")
            hovered = True
        elif not is_now_hovered and self.is_hovered:
            self.is_hovered = False
            bpy.context.window.cursor_set("DEFAULT")
        return hovered

class LoopControlPoint(ControlPoint):
    def __init__(self, index, position, operator, shape="rhomboid", section=(0, 0), 
                 orientation="horizontal", associated_cp=None, *args, **kwargs):
        super().__init__(index, position, operator, shape, section, *args, **kwargs)
        self.orientation = orientation
        self.associated_cp = associated_cp
        self.display_distance = self.size * 20
        self.is_displayed = False

    def draw(self):
        if not self.is_displayed:
            return
        super().draw()

    def check_hover(self, mouse_x, mouse_y):
        screen_x, screen_y = self.operator.graph_to_screen(*self.position)
        display_half_size = self.display_distance / 2
        mouse_distance = math.hypot(mouse_x - screen_x, mouse_y - screen_y)
        
        if mouse_distance <= display_half_size:
            self.is_displayed = True
        else:
            self.is_displayed = False
            self.is_hovered = False
            return False
        
        return super().check_hover(mouse_x, mouse_y)

# Scene properties
class KeyframeLatticeProperties(bpy.types.PropertyGroup):
    mode: bpy.props.EnumProperty(
        name="Mode",
        items=[('NORMAL', "Normal", "Bounding box scaling"),
               ('WARP', "Warp", "Grid deformation")],
        default='NORMAL'
    )
    lattice_x: bpy.props.IntProperty(name="Columns", default=2, min=1, max=10)
    lattice_y: bpy.props.IntProperty(name="Rows", default=2, min=1, max=10)
    snap_lattice_to_full_frames: bpy.props.BoolProperty(
        name="Snap to Full Frames", default=True)
    lock_direction: bpy.props.BoolProperty(name="Lock Direction", default=False)

def register_properties():
    bpy.types.Scene.keyframe_lattice_settings = bpy.props.PointerProperty(
        type=KeyframeLatticeProperties)

def unregister_properties():
    del bpy.types.Scene.keyframe_lattice_settings

class AMP_OT_anim_lattice(bpy.types.Operator):
    bl_idname = "anim.amp_anim_lattice"
    bl_label = "Anim Lattice"
    bl_options = {'REGISTER'}
    bl_description = "Drag control points to scale keyframes proportionally"

    VERTICAL_PADDING = 0.0001
    HORIZONTAL_PADDING = 1

    _handle = None
    _is_running = False

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.current_mode = bpy.context.scene.keyframe_lattice_settings.mode
        self.previous_lattice_x = bpy.context.scene.keyframe_lattice_settings.lattice_x
        self.previous_lattice_y = bpy.context.scene.keyframe_lattice_settings.lattice_y
        self.control_points = []
        self.loop_control_points = []
        self.mouse_x = 0
        self.mouse_y = 0
        self.mouse_graph_x = 0.0
        self.mouse_graph_y = 0.0
        self.dragging_control_point = None
        self.initial_mouse_x = 0
        self.initial_mouse_y = 0
        self.initial_mouse_graph_x = 0.0
        self.initial_mouse_graph_y = 0.0
        self.initial_keyframes = []
        self.initial_bounds = None
        self.initial_control_point_positions = {}
        self.fcurves_to_update = set()
        self.undo_stack = []
        self.context = None
        self.initial_selected_keyframes = []
        self.fcurves_array = None
        self.indices_array = None
        self.is_rotation_curve_array = None
        self.initial_co_array = None
        self.initial_handle_left_array = None
        self.initial_handle_right_array = None
        self.relative_co = None
        self.relative_handle_left = None
        self.relative_handle_right = None
        self.relative_co_cell_list = []
        self.relative_handle_left_cell_list = []
        self.relative_handle_right_cell_list = []
        self.relative_keys = None
        self.initial_use_normalization = False

    @classmethod
    def poll(cls, context):
        return context.area.type == 'GRAPH_EDITOR'

    def invoke(self, context, event):
        if event.shift:
            return context.window_manager.invoke_props_dialog(self)
        return self.execute(context)

    def init_tool(self, context):
        self.context = context
        self.fcurves_to_update = set()
        self.collect_initial_keyframe_data()
        
        if not len(self.initial_co_array):
            self.report({'WARNING'}, "No keyframes selected")
            return {'CANCELLED'}
        
        self.initial_bounds = self.get_initial_bounds()
        if not self.initial_bounds:
            self.report({'WARNING'}, "Unable to determine keyframe bounds")
            return {'CANCELLED'}
        
        self.compute_relative_positions()
        self.init_control_points(context)
        
        args = (self, context)
        self._handle = bpy.types.SpaceGraphEditor.draw_handler_add(
            self.draw_callback, args, 'WINDOW', 'POST_PIXEL')
        context.area.tag_redraw()
        self.push_undo(context)
        return {'RUNNING_MODAL'}

    def graph_to_screen(self, graph_x, graph_y):
        view2d = self.context.region.view2d
        screen_x, screen_y = view2d.view_to_region(graph_x, graph_y, clip=False)
        return screen_x, screen_y

    def screen_to_graph(self, screen_x, screen_y):
        view2d = self.context.region.view2d
        gx, gy = view2d.region_to_view(screen_x, screen_y)
        return gx, gy

    def push_undo(self, context):
        """Push current state to undo stack."""
        co_array = np.zeros_like(self.initial_co_array)
        handle_left_array = np.zeros_like(self.initial_handle_left_array)
        handle_right_array = np.zeros_like(self.initial_handle_right_array)
        
        for i in range(len(self.indices_array)):
            fcurve = self.fcurves_array[i]
            index = self.indices_array[i]
            is_rotation_curve = self.is_rotation_curve_array[i]
            kf = fcurve.keyframe_points[index]
            
            x_value = kf.co[0]
            y_value = math.degrees(kf.co[1]) if is_rotation_curve else kf.co[1]
            handle_left_x = kf.handle_left[0]
            handle_left_y = math.degrees(kf.handle_left[1]) if is_rotation_curve else kf.handle_left[1]
            handle_right_x = kf.handle_right[0]
            handle_right_y = math.degrees(kf.handle_right[1]) if is_rotation_curve else kf.handle_right[1]
            
            co_array[i] = [x_value, y_value]
            handle_left_array[i] = [handle_left_x, handle_left_y]
            handle_right_array[i] = [handle_right_x, handle_right_y]
        
        control_point_indices = []
        control_point_positions = []
        for cp in self.control_points + self.loop_control_points:
            control_point_indices.append(cp.index)
            control_point_positions.append([cp.position[0], cp.position[1]])
        
        state = {
            "co_array": co_array.copy(),
            "handle_left_array": handle_left_array.copy(),
            "handle_right_array": handle_right_array.copy(),
            "control_point_indices": np.array(control_point_indices),
            "control_point_positions": np.array(control_point_positions),
        }
        self.undo_stack.append(state)
        self.initial_co_array = co_array.copy()
        self.initial_handle_left_array = handle_left_array.copy()
        self.initial_handle_right_array = handle_right_array.copy()

    def init_control_points(self, context):
        min_x, max_x, min_y, max_y = self.initial_bounds
        props = context.scene.keyframe_lattice_settings
        lattice_x = props.lattice_x
        lattice_y = props.lattice_y
        
        self.control_points = []
        self.loop_control_points = []
        
        if props.mode == "WARP":
            index_counter = 0
            for row in range(lattice_y + 1):
                for col in range(lattice_x + 1):
                    u = col / lattice_x if lattice_x != 0 else 0.0
                    v = row / lattice_y if lattice_y != 0 else 0.0
                    x = min_x + u * (max_x - min_x)
                    y = min_y + v * (max_y - min_y)
                    index = index_counter
                    index_counter += 1
                    self.control_points.append(
                        ControlPoint(index, (x, y), self, shape="circle", section=(row, col)))
        else:
            positions = [
                (0, (min_x, min_y)),
                (1, (max_x, min_y)),
                (2, (max_x, max_y)),
                (3, (min_x, max_y)),
                (4, ((min_x + max_x) / 2, min_y)),
                (5, (max_x, (min_y + max_y) / 2)),
                (6, ((min_x + max_x) / 2, max_y)),
                (7, (min_x, (min_y + max_y) / 2)),
            ]
            self.control_points = [ControlPoint(index, pos, self) for index, pos in positions]

    def modal(self, context, event):
        if not self._is_running:
            return {'CANCELLED'}
        
        props = context.scene.keyframe_lattice_settings
        
        # Mode change handling
        if (props.mode != self.current_mode or 
            (props.mode == "WARP" and 
             (props.lattice_x != self.previous_lattice_x or 
              props.lattice_y != self.previous_lattice_y))):
            self.current_mode = props.mode
            self.undo_stack.clear()
            self.initial_bounds = self.get_initial_bounds()
            if not self.initial_bounds:
                self.report({'WARNING'}, "Unable to determine keyframe bounds after mode change")
                return {'CANCELLED'}
            self.compute_relative_positions()
            self.init_control_points(context)
            self.push_undo(context)
            context.area.tag_redraw()
        
        self.previous_lattice_x = props.lattice_x
        self.previous_lattice_y = props.lattice_y
        
        if event.type in {'ESC', 'RET'} and event.value == 'PRESS':
            for fcurve in self.fcurves_to_update:
                fcurve.update()
            return self.cancel(context)
        
        if event.type == 'RIGHTMOUSE' and event.value == 'PRESS':
            context.window.cursor_modal_set('DEFAULT')
            return {'RUNNING_MODAL'}
        
        if event.type == 'MOUSEMOVE':
            self.mouse_x = event.mouse_region_x
            self.mouse_y = event.mouse_region_y
            self.mouse_graph_x, self.mouse_graph_y = self.screen_to_graph(
                self.mouse_x, self.mouse_y)
            
            if self.dragging_control_point is not None:
                self.handle_mouse_move_drag(context, event)
            else:
                self.handle_mouse_move_hover(context, event)
            context.area.tag_redraw()
            return {'PASS_THROUGH'}
        
        if event.type == 'LEFTMOUSE' and event.value == 'PRESS':
            for cp in self.control_points + self.loop_control_points:
                if cp.check_hover(self.mouse_x, self.mouse_y):
                    context.window.cursor_set('SCROLL_XY')
                    self.dragging_control_point = cp.index
                    self.initial_mouse_x = event.mouse_region_x
                    self.initial_mouse_y = event.mouse_region_y
                    self.initial_mouse_graph_x, self.initial_mouse_graph_y = self.screen_to_graph(
                        self.initial_mouse_x, self.initial_mouse_y)
                    self.initial_control_point_positions = {
                        cp_.index: cp_.position for cp_ in self.control_points + self.loop_control_points
                    }
                    context.area.tag_redraw()
                    return {'RUNNING_MODAL'}
        
        if event.type == 'LEFTMOUSE' and event.value == 'RELEASE':
            context.window.cursor_set('DEFAULT')
            if self.dragging_control_point is not None:
                if not props.snap_lattice_to_full_frames:
                    for fcurve in self.fcurves_to_update:
                        fcurve.update()
                self.dragging_control_point = None
                self.push_undo(context)
                if props.mode != "WARP":
                    self.initial_bounds = self.get_initial_bounds()
                    self.compute_relative_positions()
                context.area.tag_redraw()
            return {'RUNNING_MODAL'}
        
        if event.type == 'F' and event.value == 'PRESS':
            props.snap_lattice_to_full_frames = not props.snap_lattice_to_full_frames
            context.area.tag_redraw()
            return {'RUNNING_MODAL'}
        
        if (event.type == 'Z' and (event.ctrl or event.oskey)) and event.value == 'PRESS':
            self.pop_undo(context)
            context.area.tag_redraw()
            return {'RUNNING_MODAL'}
        
        context.area.tag_redraw()
        return {'PASS_THROUGH'}

    def handle_mouse_move_hover(self, context, event):
        for cp in self.control_points + self.loop_control_points:
            cp.check_hover(self.mouse_x, self.mouse_y)

    def handle_mouse_move_drag(self, context, event):
        cp = next((cp_ for cp_ in self.control_points + self.loop_control_points 
                  if cp_.index == self.dragging_control_point), None)
        if not cp:
            return
        
        props = context.scene.keyframe_lattice_settings
        delta_x = self.mouse_graph_x - self.initial_mouse_graph_x
        delta_y = self.mouse_graph_y - self.initial_mouse_graph_y
        
        lock_active = event.shift or props.lock_direction
        if lock_active and props.mode == "WARP":
            dx = self.mouse_x - self.initial_mouse_x
            dy = self.mouse_y - self.initial_mouse_y
            if abs(dx) > abs(dy):
                delta_y = 0
            else:
                delta_x = 0
        
        if props.mode == "WARP":
            self.handle_drag_warp(cp, delta_x, delta_y)
        else:
            self.handle_drag_normal(cp, delta_x, delta_y)
        
        self.update_bounding_box_and_keyframes(context)

    def handle_drag_warp(self, cp, delta_x, delta_y):
        # Simplified warp drag - translate entire column/row
        props = bpy.context.scene.keyframe_lattice_settings
        if hasattr(cp, 'orientation'):  # LoopControlPoint
            if cp.orientation == "vertical":
                col = cp.section[1]
                affected = [p for p in self.control_points if p.section[1] == col]
            else:
                row = cp.section[1]
                affected = [p for p in self.control_points if p.section[0] == row]
        else:
            affected = [cp]
        
        for p in affected:
            ix, iy = self.initial_control_point_positions[p.index]
            p.position = (ix + delta_x, iy + delta_y)

    def handle_drag_normal(self, cp, delta_x, delta_y):
        ix, iy = self.initial_control_point_positions[cp.index]
        cp.position = (ix + delta_x, iy + delta_y)

    def execute(self, context):
        if not self.__class__._is_running:
            self.initial_use_normalization = context.space_data.use_normalization
            if self.initial_use_normalization:
                context.space_data.use_normalization = False
            
            bpy.ops.graph.view_selected()
            result = self.init_tool(context)
            if result == {'CANCELLED'}:
                self.cancel(context)
                return {'CANCELLED'}
            
            context.window_manager.modal_handler_add(self)
            self.__class__._is_running = True
            return {'RUNNING_MODAL'}
        else:
            return self.cancel(context)

    def cancel(self, context):
        if self.initial_use_normalization:
            context.space_data.use_normalization = True
        self.__class__._is_running = False
        if self._handle is not None:
            bpy.types.SpaceGraphEditor.draw_handler_remove(self._handle, 'WINDOW')
            self._handle = None
        if context.area:
            context.area.tag_redraw()
        return {'CANCELLED'}

    def draw_callback(self, _self, context):
        props = context.scene.keyframe_lattice_settings
        shader = gpu.shader.from_builtin("UNIFORM_COLOR")
        gpu.state.blend_set('ALPHA')
        
        if props.mode == "WARP":
            # Draw grid lines (simplified)
            pass
        
        # Draw bounding box for NORMAL mode
        if props.mode != "WARP" and len(self.control_points) >= 4:
            corner_indices = [0, 1, 2, 3]
            vertices = [self.graph_to_screen(*self.control_points[i].position) 
                       for i in corner_indices if i < len(self.control_points)]
            if len(vertices) == 4:
                batch = batch_for_shader(shader, 'LINE_LOOP', {"pos": vertices})
                shader.bind()
                shader.uniform_float("color", (1.0, 1.0, 1.0, 1.0))
                batch.draw(shader)
        
        # Draw control points
        for cp in self.control_points + self.loop_control_points:
            cp.draw()
        
        # Draw help text
        draw_gui_help_text(context, 30, 40)
        gpu.state.blend_set('NONE')

    def collect_initial_keyframe_data(self):
        """Collect selected keyframes into NumPy arrays."""
        selected_fcurves = context.selected_editable_fcurves
        
        fcurves_list = []
        indices_list = []
        is_rotation_curve_list = []
        initial_co_list = []
        initial_handle_left_list = []
        initial_handle_right_list = []
        
        for fcurve in selected_fcurves:
            for idx, kf in enumerate(fcurve.keyframe_points):
                if kf.select_control_point:
                    self.fcurves_to_update.add(fcurve)
                    is_rotation_curve = fcurve.array_type == 'ROTATION'  # Simplified check
                    
                    y_value = math.degrees(kf.co[1]) if is_rotation_curve else kf.co[1]
                    handle_left_y = math.degrees(kf.handle_left[1]) if is_rotation_curve else kf.handle_left[1]
                    handle_right_y = math.degrees(kf.handle_right[1]) if is_rotation_curve else kf.handle_right[1]
                    
                    fcurves_list.append(fcurve)
                    indices_list.append(idx)
                    is_rotation_curve_list.append(is_rotation_curve)
                    initial_co_list.append([kf.co[0], y_value])
                    initial_handle_left_list.append([kf.handle_left[0], handle_left_y])
                    initial_handle_right_list.append([kf.handle_right[0], handle_right_y])
        
        self.fcurves_array = np.array(fcurves_list, dtype=object)
        self.indices_array = np.array(indices_list, dtype=int)
        self.is_rotation_curve_array = np.array(is_rotation_curve_list, dtype=bool)
        self.initial_co_array = np.array(initial_co_list, dtype=float)
        self.initial_handle_left_array = np.array(initial_handle_left_list, dtype=float)
        self.initial_handle_right_array = np.array(initial_handle_right_list, dtype=float)

    def compute_relative_positions(self):
        min_x0, max_x0, min_y0, max_y0 = self.initial_bounds
        
        if bpy.context.scene.keyframe_lattice_settings.mode == "NORMAL":
            denom_x = max_x0 - min_x0
            denom_y = max_y0 - min_y0
            
            if denom_x == 0:
                u_array = np.zeros(len(self.indices_array))
            else:
                u_array = (self.initial_co_array[:, 0] - min_x0) / denom_x
            
            if denom_y == 0:
                v_array = np.zeros(len(self.indices_array))
            else:
                v_array = (self.initial_co_array[:, 1] - min_y0) / denom_y
            
            self.relative_co = np.column_stack((u_array, v_array))
            # Simplified - handles computed similarly

    def get_initial_bounds(self):
        if len(self.initial_co_array) == 0:
            return None
        min_x = np.min(self.initial_co_array[:, 0])
        max_x = np.max(self.initial_co_array[:, 0])
        min_y = np.min(self.initial_co_array[:, 1])
        max_y = np.max(self.initial_co_array[:, 1])
        return min_x, max_x, min_y, max_y

    def update_bounding_box_and_keyframes(self, context):
        if self.dragging_control_point is None:
            return
        
        props = context.scene.keyframe_lattice_settings
        
        if props.mode == "NORMAL":
            min_x0, max_x0, min_y0, max_y0 = self.initial_bounds
            cp_positions = {cp.index: cp.position for cp in self.control_points}
            
            # Update bounds based on dragged control point
            min_x, max_x, min_y, max_y = min_x0, max_x0, min_y0, max_y0
            
            if self.dragging_control_point in [1, 2, 5]:  # Right side
                max_x = cp_positions[self.dragging_control_point][0]
            if self.dragging_control_point in [2, 3, 6]:  # Top side
                max_y = cp_positions[self.dragging_control_point][1]
            if self.dragging_control_point in [0, 3, 7]:  # Left side
                min_x = cp_positions[self.dragging_control_point][0]
            if self.dragging_control_point in [0, 1, 4]:  # Bottom side
                min_y = cp_positions[self.dragging_control_point][1]
            
            # Apply padding
            if max_x - min_x < self.HORIZONTAL_PADDING:
                max_x = min_x + self.HORIZONTAL_PADDING
            if max_y - min_y < self.VERTICAL_PADDING:
                max_y = min_y + self.VERTICAL_PADDING
            
            denom_x = max_x - min_x
            denom_y = max_y - min_y
            
            new_x_array = min_x + self.relative_co[:, 0] * denom_x
            new_y_array = min_y + self.relative_co[:, 1] * denom_y
            
            if props.snap_lattice_to_full_frames:
                new_x_array = np.round(new_x_array)
            
            # Update keyframes
            for i in range(len(self.indices_array)):
                fcurve = self.fcurves_array[i]
                index = self.indices_array[i]
                kf = fcurve.keyframe_points[index]
                is_rotation_curve = self.is_rotation_curve_array[i]
                
                kf.co[0] = new_x_array[i]
                kf.co[1] = radians(new_y_array[i]) if is_rotation_curve else new_y_array[i]

    def pop_undo(self, context):
        if len(self.undo_stack) < 2:
            self.report({'INFO'}, "Nothing to undo")
            return
        self.undo_stack.pop()
        state = self.undo_stack[-1]
        # Restore logic (simplified)
        context.area.tag_redraw()

class AMP_PT_AnimLatticeOptions(bpy.types.Panel):
    bl_label = "Anim Lattice Options"
    bl_idname = "AMP_PT_AnimLatticeOptions"
    bl_space_type = 'GRAPH_EDITOR'
    bl_region_type = 'UI'
    bl_category = "Anim Lattice"

    def draw(self, context):
        layout = self.layout
        props = context.scene.keyframe_lattice_settings
        layout.use_property_split = True
        layout.prop(props, "mode", text="Mode")
        if props.mode == "WARP":
            layout.prop(props, "lattice_x", text="Columns")
            layout.prop(props, "lattice_y", text="Rows")
        layout.prop(props, "snap_lattice_to_full_frames", text="Snap to Full Frames")
        layout.prop(props, "lock_direction", text="Lock Direction")

classes = [
    KeyframeLatticeProperties,
    AMP_OT_anim_lattice,
    AMP_PT_AnimLatticeOptions,
]

def register():
    register_properties()
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    unregister_properties()
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

if __name__ == "__main__":
    register()
